<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PsycheView - Standalone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Animated Background */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #fb5607);
            background-size: 400% 400%;
            animation: psychedelicFlow 120s ease-in-out infinite;
        }

        @keyframes psychedelicFlow {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        /* Floating elements */
        .psychedelic-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(2px);
            animation: psychedelicFloat 20s ease-in-out infinite;
        }

        .psychedelic-orb:nth-child(1) {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 0, 110, 0.8), transparent);
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .psychedelic-orb:nth-child(2) {
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(131, 56, 236, 0.8), transparent);
            top: 60%;
            right: 15%;
            animation-delay: -5s;
        }

        .psychedelic-orb:nth-child(3) {
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, rgba(58, 134, 255, 0.8), transparent);
            bottom: 20%;
            left: 20%;
            animation-delay: -10s;
        }

        .psychedelic-orb:nth-child(4) {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(6, 255, 165, 0.8), transparent);
            top: 30%;
            right: 40%;
            animation-delay: -15s;
        }

        @keyframes psychedelicFloat {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            25% { transform: translate(50px, -30px) scale(1.2) rotate(90deg); }
            50% { transform: translate(-30px, 40px) scale(0.8) rotate(180deg); }
            75% { transform: translate(40px, 20px) scale(1.1) rotate(270deg); }
        }

        /* Main container */
        .app-container {
            position: relative;
            min-height: 100vh;
        }



        /* Image Viewer */
        .image-viewer {
            position: relative;
            margin: 60px auto;
            overflow: hidden;
            cursor: grab;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.4);
        }

        .image-viewer:active {
            cursor: grabbing;
        }

        .viewer-content {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        /* Tiled Background */
        .tiled-background {
            position: absolute;
            width: 1000%;
            height: 1000%;
            top: -450%;
            left: -450%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255, 0, 255, 0.15) 20%, transparent 25%),
                radial-gradient(circle at 0% 0%, rgba(0, 255, 255, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 0%, rgba(255, 255, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 0% 100%, rgba(255, 100, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 100%, rgba(100, 255, 100, 0.12) 15%, transparent 20%),
                linear-gradient(0deg, transparent 45%, rgba(255, 0, 100, 0.08) 47%, rgba(255, 0, 100, 0.08) 53%, transparent 55%),
                linear-gradient(60deg, transparent 45%, rgba(100, 0, 255, 0.08) 47%, rgba(100, 0, 255, 0.08) 53%, transparent 55%),
                linear-gradient(120deg, transparent 45%, rgba(0, 255, 150, 0.08) 47%, rgba(0, 255, 150, 0.08) 53%, transparent 55%),
                radial-gradient(ellipse 30px 52px at 50% 50%, rgba(255, 150, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 0% 0%, rgba(150, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 100% 100%, rgba(255, 0, 150, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 40px 20px at 25% 25%, rgba(255, 255, 0, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 40px 20px at 75% 75%, rgba(0, 255, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 75% 25%, rgba(255, 0, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 25% 75%, rgba(100, 255, 100, 0.06) 0%, transparent 70%);
            background-size: 
                120px 120px,
                240px 240px,
                240px 240px,
                240px 240px,
                240px 240px,
                80px 138px,
                80px 138px,
                80px 138px,
                60px 104px,
                120px 208px,
                120px 208px,
                160px 160px,
                160px 160px,
                160px 160px,
                160px 160px;
            background-position:
                60px 60px,
                0px 0px,
                120px 0px,
                0px 120px,
                120px 120px,
                0px 0px,
                40px 69px,
                80px 0px,
                30px 52px,
                60px 104px,
                90px 156px,
                0px 0px,
                80px 80px,
                40px 120px,
                120px 40px;
            background-repeat: repeat;
            opacity: 0.5;
            mix-blend-mode: multiply;
            filter: saturate(1.3) contrast(1.1) brightness(1.2);
            animation: islamicShift 90s ease-in-out infinite;
        }

        @keyframes islamicShift {
            0%, 100% { 
                filter: saturate(1.3) contrast(1.1) brightness(1.2) hue-rotate(0deg);
                opacity: 0.5;
            }
            25% { 
                filter: saturate(1.6) contrast(1.3) brightness(1.0) hue-rotate(90deg);
                opacity: 0.6;
            }
            50% { 
                filter: saturate(1.4) contrast(1.4) brightness(1.3) hue-rotate(180deg);
                opacity: 0.4;
            }
            75% { 
                filter: saturate(1.8) contrast(1.2) brightness(1.1) hue-rotate(270deg);
                opacity: 0.7;
            }
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes subtleGridShift {
            0%, 100% { 
                opacity: 0.3;
                filter: hue-rotate(0deg) saturate(1.2);
            }
            33% { 
                opacity: 0.4;
                filter: hue-rotate(120deg) saturate(1.4);
            }
            66% { 
                opacity: 0.2;
                filter: hue-rotate(240deg) saturate(1.1);
            }
        }

        /* Main Image - Fill container for consistent sizing */
        .main-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;  /* Maintain aspect ratio, fit within container */
            z-index: 3;
        }

        /* Zoom indicator - hidden by default, shown only in debug mode */
        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-family: monospace;
            display: none;
        }

        /* Queue indicator - always visible, positioned top-right but left of debug windows */
        .queue-indicator {
            position: fixed;
            top: 20px;
            right: 300px; /* Left of debug windows (280px width + 20px margin) */
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            display: block; /* Always visible */
        }



        /* API Key Input */
        .api-key-input {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }

        .api-key-input input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            width: 200px;
            outline: none;
        }

        .api-key-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .api-key-input input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .api-key-input button {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .api-key-input button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .api-key-input button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }



        /* Debug Preview Window - styled like debug windows, no header/footer */
        .debug-preview {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 280px;
            height: 50vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-right: 2px solid #444;
            border-top: 2px solid #444;
            z-index: 1000;
            display: none;
            overflow: hidden;
            padding: 0;
        }

        .debug-preview.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .debug-preview-image {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
        }
    </style>
</head>
<body>
    <div class="animated-background">
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
    </div>

    <div class="app-container">

        


        <div class="api-key-input" id="apiKeyContainer">
            <input type="password" id="apiKeyInput" placeholder="Enter Stability AI API Key" />
            <button id="setApiKeyBtn">Set Key</button>
            <button id="testApiBtn">Test API</button>
        </div>

        <div class="image-viewer" id="imageViewer">
            <canvas class="grid-overlay" id="gridCanvas"></canvas>
            <div class="viewer-content" id="viewerContent">
                <div class="tiled-background"></div>
                <img class="main-image" id="mainImage" src="psychedelic-flora.jpg" alt="Psychedelic Flora" draggable="false" crossorigin="anonymous">
            </div>
            <div class="zoom-indicator" id="zoomIndicator">1.00x</div>

        </div>
    </div>

    <!-- Queue indicator - always visible in top row -->
    <div class="queue-indicator" id="queueIndicator">Active: 0 | Expansion: Waiting</div>

    <!-- Debug windows positioned outside app-container for true browser window positioning -->
    <div class="debug-info" id="debugInfo" style="position: fixed; top: 0; right: 0; width: 280px; height: 50vh; background: rgba(0,0,0,0.85); color: white; padding: 12px; font-family: monospace; font-size: 10px; z-index: 1000; overflow-y: auto; border-left: 2px solid #444; backdrop-filter: blur(10px); display: none;">
        Debug Info
    </div>
    
    <!-- Console capture div positioned outside app-container for true browser window positioning -->
    <div id="consoleCapture" style="position: fixed; top: 50vh; right: 0; width: 280px; height: 50vh; background: rgba(0,0,0,0.9); color: #00ff00; padding: 12px; font-family: monospace; font-size: 9px; z-index: 1001; overflow-y: auto; border-left: 2px solid #333; backdrop-filter: blur(10px); display: none;">
        <div style="color: #ffff00; margin-bottom: 8px; font-weight: bold;">üñ•Ô∏è CONSOLE OUTPUT:</div>
        <div id="consoleLogs"></div>
    </div>

    <!-- Debug Preview Window - simplified, no header/footer -->
    <div class="debug-preview" id="debugPreview">
        <img class="debug-preview-image" id="debugPreviewImage" alt="Generated Image" style="display: none;">
    </div>

    <script>
        // Override console to capture logs
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const logs = [];
        
        console.log = function(...args) {
            logs.push({type: 'log', message: args.join(' '), time: new Date().toLocaleTimeString()});
            originalConsoleLog.apply(console, args);
            updateDebugConsole();
            updateConsoleCapture();
        };
        
        console.error = function(...args) {
            logs.push({type: 'error', message: args.join(' '), time: new Date().toLocaleTimeString()});
            originalConsoleError.apply(console, args);
            updateDebugConsole();
            updateConsoleCapture();
        };
        
        function updateDebugConsole() {
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                const lastLogs = logs.slice(-10); // Show last 10 logs
                debugInfo.innerHTML = 'Debug Console:<br>' + lastLogs.map(log => 
                    `<span style="color: ${log.type === 'error' ? '#ff4444' : '#44ff44'}">[${log.time}] ${log.message}</span>`
                ).join('<br>');
                // Auto-scroll to bottom
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        function updateConsoleCapture() {
            const consoleDiv = document.getElementById('consoleLogs');
            if (consoleDiv) {
                const lastLogs = logs.slice(-20); // Show last 20 logs
                consoleDiv.innerHTML = lastLogs.map(log =>
                    `<div style="color: ${log.type === 'error' ? '#ff4444' : '#00ff00'}; margin-bottom: 2px; font-size: 10px;">[${log.time}] ${log.message}</div>`
                ).join('');
                // Auto-scroll to bottom
                const captureDiv = document.getElementById('consoleCapture');
                if (captureDiv) {
                    captureDiv.scrollTop = captureDiv.scrollHeight;
                }
            }
        }
        
        class ImageViewer {
            constructor() {
                this.viewer = document.getElementById('imageViewer');
                this.content = document.getElementById('viewerContent');
                this.image = document.getElementById('mainImage');
                
                // API Configuration
                this.config = {
                    endpoint: 'https://api.stability.ai/v2beta/stable-image/edit/outpaint',
                    prompt: "Extend this image of a portion of a yakuza's body tatoo.  Match the scale of the floral pattern and extend it in the same style.  Then embedded within the pattern just like the lizard in the input image, are style matching y≈çkai, all the great ones includinge kappa, tengu, oni, and kitsune, etc.",
                    output_format: 'jpeg',
                    creativity: 0.35,
                    seed: 0
                };
                this.zoomIndicator = document.getElementById('zoomIndicator');
                this.queueIndicator = document.getElementById('queueIndicator');

                this.debugInfo = document.getElementById('debugInfo');
                this.apiKeyInput = document.getElementById('apiKeyInput');
                this.setApiKeyBtn = document.getElementById('setApiKeyBtn');
                this.testApiBtn = document.getElementById('testApiBtn');

                this.autoGenToggleBtn = document.getElementById('autoGenToggleBtn');
                this.apiCallsToggleBtn = document.getElementById('apiCallsToggleBtn');
                this.testPanBtn = document.getElementById('testPanBtn');
                this.zoomOutMaxBtn = document.getElementById('zoomOutMaxBtn');
                this.imageOpacityBtn = document.getElementById('imageOpacityBtn');
                this.blockLayerBtn = document.getElementById('blockLayerBtn');

                
                // Debug preview elements
                this.debugPreview = document.getElementById('debugPreview');
                this.debugPreviewImage = document.getElementById('debugPreviewImage');

                

                

                

                

                

                
                this.scale = 0.25;
                this.translateX = 0;
                this.translateY = 0;
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                this.minScale = 0.25;
                this.maxScale = 4;
                
                // Block size configuration (1 = same size as image, 4 = quarter size, etc.)
                this.blockDivisions = 1; // Default: blocks are same size as image for easier testing
                
                // Auto-generation control (default: true - blocks are added automatically)
                this.autoGenerateBlocks = true;
                
                // Simple expansion system - no complex spiral
                
                // API calls control
                this.apiCallsEnabled = true;
                
                // Image opacity control (false = 100%, true = 50%)
                this.imageTranslucent = false;
                
                // Block layer control (false = under image, true = over image)
                this.blocksOverImage = false;
                
                // Grid visibility control (false = hidden, true = visible)
                this.gridVisible = false;
                
                // API system - will be set from environment or user input
                this.apiKey = null;

                
                // Stability AI API Configuration
                this.apiConfig = {
                    endpoint: 'https://api.stability.ai/v2beta/stable-image/edit/outpaint',
                    prompt: "Extend this image of a portion of a yakuza's body tatoo.  Match the scale of the floral pattern and extend it in the same style.  Then embedded within the pattern just like the lizard in the input image, are style matching y≈çkai, all the great ones includinge kappa, tengu, oni, and kitsune, etc.",
                    seed: null, // null for random seed
                    output_format: 'jpeg',
                    creativity: 0.35,
                    style_preset: null // null for default style
                };
                
                // Outfill properties
                this.outfillBlocks = new Map();
                this.activeGenerations = 0;
                this.imageWidth = 0;
                this.imageHeight = 0;
                this.hasTriggeredExpansion = false; // Simple flag to trigger one expansion
                
                this.init();
            }
            
            init() {
                // Set up container size based on image aspect ratio - windowed approach
                const setupSize = () => {
                    // In standalone mode, provide fallback dimensions since image may not load due to CORS
                    if (window.location.protocol === 'file:' && (!this.image.naturalWidth || !this.image.naturalHeight)) {
                        console.log('üîß Standalone mode: Using fallback image dimensions (1600x1024)');
                        this.imageWidth = 1600;
                        this.imageHeight = 1024;
                    } else if (this.image.naturalWidth && this.image.naturalHeight) {
                        this.imageWidth = this.image.naturalWidth;
                        this.imageHeight = this.image.naturalHeight;
                    } else {
                        // Fallback size if image not loaded yet
                        this.imageWidth = 1600;
                        this.imageHeight = 1024;
                    }
                    
                    const aspectRatio = this.imageWidth / this.imageHeight;
                    
                    // Create a window sized to fit the image with some margin for the psychedelic background
                    const maxHeight = window.innerHeight - 120;
                    const maxWidth = window.innerWidth - 80;
                    
                    let finalWidth, finalHeight;
                    
                    if (maxWidth / aspectRatio <= maxHeight) {
                        finalWidth = maxWidth;
                        finalHeight = maxWidth / aspectRatio;
                    } else {
                        finalHeight = maxHeight;
                        finalWidth = maxHeight * aspectRatio;
                    }
                    
                    this.viewer.style.width = finalWidth + 'px';
                    this.viewer.style.height = finalHeight + 'px';
                    this.containerWidth = finalWidth;
                    this.containerHeight = finalHeight;
                    
                    // Update grid size to match image dimensions
                    this.updateGridSize();
                };
                
                this.image.onload = setupSize;
                // Also call immediately in case image is already loaded
                setupSize();
                
                // Mouse events
                this.viewer.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Wheel event for zooming
                this.viewer.addEventListener('wheel', this.handleWheel.bind(this));
                
                // Touch events for mobile
                this.viewer.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.viewer.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.viewer.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Prevent context menu
                this.viewer.addEventListener('contextmenu', e => e.preventDefault());
                

                
                // API key input
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.onclick = () => {
                        this.setApiKey();
                    };
                }
                
                if (this.apiKeyInput) {
                    this.apiKeyInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.setApiKey();
                        }
                    });
                }
                
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.addEventListener('click', () => this.setApiKey());
                }
                
                if (this.testApiBtn) {
                    this.testApiBtn.addEventListener('click', () => this.testApiCall());
                }
                


                if (this.autoGenToggleBtn) {
                    this.autoGenToggleBtn.addEventListener('click', () => this.toggleAutoGeneration());
                }

                if (this.apiCallsToggleBtn) {
                    this.apiCallsToggleBtn.addEventListener('click', () => this.toggleApiCalls());
                }

                if (this.testPanBtn) {
                    this.testPanBtn.addEventListener('click', () => this.testPan());
                }

                if (this.zoomOutMaxBtn) {
                    this.zoomOutMaxBtn.addEventListener('click', () => this.zoomOutMax());
                }
                
                if (this.imageOpacityBtn) {
                    this.imageOpacityBtn.addEventListener('click', () => this.toggleImageOpacity());
                }
                
                if (this.blockLayerBtn) {
                    this.blockLayerBtn.addEventListener('click', () => this.toggleBlockLayer());
                }
                
                // Debug preview close functionality removed (no close button)
                

                
                // Try to load API key from environment on startup
                this.initializeApiKey();
                
                // Set initial UI state for pre-configured API key
                this.updateInitialUIState();
                
                // Hide debug windows by default
                const debugInfo = document.getElementById('debugInfo');
                const consoleCapture = document.getElementById('consoleCapture');
                if (debugInfo && consoleCapture) {
                    debugInfo.style.display = 'none';
                    consoleCapture.style.display = 'none';
                }
                
                this.updateTransform();
                
                // Add resize handler to redraw grid
                window.addEventListener('resize', () => {
                    setTimeout(() => this.drawGrid(), 100);
                });
                
                // Add keyboard shortcut to toggle debug windows
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey && e.key === 'd')) {
                        e.preventDefault();
                        this.toggleDebug();
                    } else if (e.ctrlKey && (e.key === 'g' || e.key === 'G')) {
                        e.preventDefault();
                        this.toggleGrid();
                    }
                });
            }
            
            updateInitialUIState() {
                // Update API key input UI
                if (this.apiKey && this.apiKeyInput) {
                    this.apiKeyInput.placeholder = 'API Key Set ‚úì';
                    this.apiKeyInput.value = '';
                }
                
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.textContent = 'Update';
                }
                
                // Live mode is always enabled
                
                console.log('üîë API key pre-configured and live mode enabled');
            }
            
            setApiKey() {
                const apiKey = this.apiKeyInput.value.trim();
                if (apiKey) {
                    this.apiKey = apiKey;
                    this.apiKeyInput.value = '';
                    this.apiKeyInput.placeholder = 'API Key Set ‚úì';
                    this.setApiKeyBtn.textContent = 'Update';
                    
                    // Live mode is always enabled
                    
                    console.log('API key set successfully');
                } else {
                    alert('Please enter a valid API key');
                }
            }
            
            async testApiCall() {
                if (!this.apiKey) {
                    alert('Please set an API key first');
                    return;
                }

                if (!this.apiCallsEnabled) {
                    console.log('üö´ API calls disabled - creating grey loading block only');
                    this.testApiBtn.textContent = 'Test API';
                    this.testApiBtn.disabled = false;
                    
                    // Clear existing blocks first to test new sizing
                    this.outfillBlocks.clear();
                    const existingBlocks = document.querySelectorAll('[id^="outfill-"]');
                    existingBlocks.forEach(block => block.remove());
                    
                    // Create grey loading block for testing scaling
                    const testBlockKey = '1,0';
                    this.outfillBlocks.set(testBlockKey, { status: 'generating', progress: 0, imageData: null });
                    this.updateOutfillBlock(testBlockKey, this.outfillBlocks.get(testBlockKey));
                    console.log('üéØ Grey loading block created for scaling test');
                    return;
                }
                
                console.log('üß™ Testing API call...');
                this.testApiBtn.textContent = 'Testing...';
                this.testApiBtn.disabled = true;
                
                try {
                    // Manually trigger an outfill for testing (works regardless of auto-generation setting)
                    const testBlockKey = '1,0'; // Block to the right of the image (outside image bounds)
                    this.outfillBlocks.set(testBlockKey, { status: 'generating', progress: 0, imageData: null });
                    this.updateOutfillBlock(testBlockKey, this.outfillBlocks.get(testBlockKey));
                    
                    // Use the EXACT same code path as auto-filled blocks
                    const result = await this.generateOutfill(testBlockKey);
                    console.log('‚úÖ API test successful!', result);
                    
                    // The debug preview is already shown by generateOutfill, just log success
                    console.log('üéØ Test API completed - check debug preview window for results');
                    
                } catch (error) {
                    console.error('‚ùå API test failed:', error);
                    
                    // Show error in debug preview window
                    this.showDebugError('API Test Failed', error.message);
                } finally {
                    this.testApiBtn.textContent = 'Test API';
                    this.testApiBtn.disabled = false;
                }
            }

            testPan() {
                console.log('üß™ Testing pan functionality...');
                
                // Pan the image to the right by 200px to expose left edge
                this.translateX += 200;
                this.updateTransform();
                this.checkVisibleBlocks();
                
                console.log('‚úÖ Pan test completed - image moved right by 200px');
            }

            zoomOutMax() {
                console.log('üîç Zooming out to maximum...');
                
                // Set scale to minimum (0.25x)
                this.scale = 0.25;
                this.updateTransform();
                this.checkVisibleBlocks();
                
                console.log('‚úÖ Zoomed out to maximum scale: 0.25x');
            }
            
            
            async getImageAsBlob() {
                return new Promise((resolve, reject) => {
                    // Check if we're in file:// protocol - canvas will be tainted
                    if (window.location.protocol === 'file:') {
                        reject(new Error('Canvas operations not available in file:// protocol due to browser security restrictions. Please use a local server or enable Live mode with API key.'));
                        return;
                    }
                    
                    const img = this.image;
                    
                    // Debug: Log image state
                    console.log('üîß getImageAsBlob() debug:', {
                        imgSrc: img.src.substring(0, 50) + '...',
                        naturalWidth: img.naturalWidth,
                        naturalHeight: img.naturalHeight,
                        complete: img.complete,
                        crossOrigin: img.crossOrigin
                    });
                    
                    // CRITICAL FIX: Wait for image to load if not ready
                    if (!img.complete || img.naturalWidth === 0) {
                        console.log('‚è≥ Image not loaded, waiting for load event...');
                        img.onload = () => {
                            console.log('‚úÖ Image loaded, retrying blob creation...');
                            this.createBlobFromLoadedImage(img, resolve, reject);
                        };
                        img.onerror = () => {
                            reject(new Error('Image failed to load'));
                        };
                        return;
                    }
                    
                    // Image is already loaded, proceed immediately
                    this.createBlobFromLoadedImage(img, resolve, reject);
                });
            }
            
            // Helper: Create blob from fully loaded image
            createBlobFromLoadedImage(img, resolve, reject) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                
                console.log('üé® Creating blob from loaded image:', {
                    width: img.naturalWidth,
                    height: img.naturalHeight
                });
                
                try {
                    ctx.drawImage(img, 0, 0);
                    
                    // Try toBlob first (preferred method)
                    canvas.toBlob((blob) => {
                        if (blob) {
                            console.log('‚úÖ toBlob() success:', blob.size, 'bytes');
                            resolve(blob);
                        } else {
                            console.log('‚ö†Ô∏è toBlob() returned null, trying dataURL fallback...');
                            // Fallback: Convert dataURL to blob
                            try {
                                const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                                if (!dataURL || dataURL === 'data:,') {
                                    throw new Error('Canvas toDataURL returned empty data');
                                }
                                const blob = this.dataURLToBlob(dataURL);
                                console.log('‚úÖ dataURL fallback success:', blob.size, 'bytes');
                                resolve(blob);
                            } catch (fallbackError) {
                                console.error('‚ùå Both toBlob() and dataURL fallback failed:', fallbackError.message);
                                reject(new Error('Failed to create image blob: ' + fallbackError.message));
                            }
                        }
                    }, 'image/jpeg', 0.9);
                } catch (error) {
                    reject(new Error('Canvas tainted - cannot process image: ' + error.message));
                }
            }
            
            // Helper: Convert dataURL to blob
            dataURLToBlob(dataURL) {
                if (!dataURL || typeof dataURL !== 'string') {
                    throw new Error('Invalid dataURL provided');
                }
                
                const arr = dataURL.split(',');
                if (arr.length !== 2) {
                    throw new Error('Invalid dataURL format');
                }
                
                const mimeMatch = arr[0].match(/:(.*?);/);
                if (!mimeMatch) {
                    throw new Error('Could not extract MIME type from dataURL');
                }
                
                const mime = mimeMatch[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new Blob([u8arr], { type: mime });
            }
            
            // üåÄ BREAKTHROUGH: Sample composite image for next generation
            async getCompositeImageForBlock(blockKey) {
                console.log(`üåÄ Sampling composite image for block ${blockKey}...`);
                
                return new Promise((resolve, reject) => {
                    // Check if we're in file:// protocol - canvas will be tainted
                    if (window.location.protocol === 'file:') {
                        reject(new Error('Canvas operations not available in file:// protocol due to browser security restrictions. Please use a local server or enable Live mode with API key.'));
                        return;
                    }
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas to image size (1 block size)
                    canvas.width = this.imageWidth;
                    canvas.height = this.imageHeight;
                    
                    // Get the block position to determine what adjacent area to sample
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    
                    // Calculate the source area to sample from the composite
                    // This should be the adjacent block that will be used as input
                    let sourceGridX, sourceGridY;
                    
                    // Determine which adjacent block to sample based on direction
                    if (gridX > 0) {
                        // Extending right, sample from left adjacent block
                        sourceGridX = gridX - 1;
                        sourceGridY = gridY;
                    } else if (gridX < 0) {
                        // Extending left, sample from right adjacent block  
                        sourceGridX = gridX + 1;
                        sourceGridY = gridY;
                    } else if (gridY > 0) {
                        // Extending down, sample from up adjacent block
                        sourceGridX = gridX;
                        sourceGridY = gridY - 1;
                    } else if (gridY < 0) {
                        // Extending up, sample from down adjacent block
                        sourceGridX = gridX;
                        sourceGridY = gridY + 1;
                    } else {
                        // This shouldn't happen for outfill blocks
                        console.error('üö® Invalid block position for outfill:', blockKey);
                        sourceGridX = 0;
                        sourceGridY = 0;
                    }
                    
                    console.log(`üåÄ Block ${blockKey} will sample from adjacent block (${sourceGridX},${sourceGridY})`);
                    
                    // Sample the appropriate area from the current composite
                    if (sourceGridX === 0 && sourceGridY === 0) {
                        // Sample from original image with CORS/tainting protection
                        try {
                            ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
                            console.log(`üåÄ Sampled original image for block ${blockKey}`);
                        } catch (error) {
                            console.warn('üîß Canvas tainted when sampling original image');
                            reject(new Error('Canvas tainted - cannot process image'));
                            return;
                        }
                    } else {
                        // Sample from existing outfill block
                        const sourceBlockKey = `${sourceGridX},${sourceGridY}`;
                        const sourceBlock = this.outfillBlocks.get(sourceBlockKey);
                        
                        if (sourceBlock && sourceBlock.imageData && sourceBlock.status === 'completed') {
                            // Create temporary image to sample from
                            const tempImg = new Image();
                            tempImg.onload = () => {
                                // The source block image is 2x2 (2*imageWidth x 2*imageHeight)
                                // We need to extract the portion that will be adjacent to the new block
                                const sourceWidth = tempImg.width;
                                const sourceHeight = tempImg.height;
                                
                                // Calculate which quadrant to sample based on direction
                                let sampleX, sampleY;
                                const quadrantWidth = sourceWidth / 2;
                                const quadrantHeight = sourceHeight / 2;
                                
                                // Determine sampling quadrant based on relative position
                                if (gridX > sourceGridX) {
                                    // New block is to the right, sample right edge of source
                                    sampleX = quadrantWidth; // Right half
                                } else if (gridX < sourceGridX) {
                                    // New block is to the left, sample left edge of source
                                    sampleX = 0; // Left half
                                } else {
                                    // Same X, sample center
                                    sampleX = quadrantWidth / 2;
                                }
                                
                                if (gridY > sourceGridY) {
                                    // New block is below, sample bottom edge of source
                                    sampleY = quadrantHeight; // Bottom half
                                } else if (gridY < sourceGridY) {
                                    // New block is above, sample top edge of source
                                    sampleY = 0; // Top half
                                } else {
                                    // Same Y, sample center
                                    sampleY = quadrantHeight / 2;
                                }
                                
                                const sampleWidth = quadrantWidth;
                                const sampleHeight = quadrantHeight;
                                
                                ctx.drawImage(tempImg, 
                                    sampleX, sampleY, sampleWidth, sampleHeight,
                                    0, 0, this.imageWidth, this.imageHeight
                                );
                                
                                console.log(`üåÄ Sampled from block ${sourceBlockKey} for block ${blockKey}`);
                                
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        resolve(blob);
                                    } else {
                                        reject(new Error('Failed to create composite image blob'));
                                    }
                                }, 'image/jpeg', 0.9);
                            };
                            tempImg.onerror = () => {
                                console.error(`üö® Failed to load source block image for ${sourceBlockKey}`);
                                // Fallback to original image with CORS protection
                                try {
                                    ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
                                    canvas.toBlob(resolve, 'image/jpeg', 0.9);
                                } catch (error) {
                                    console.warn('üîß Canvas tainted in fallback');
                                    reject(error);
                                }
                            };
                            tempImg.src = sourceBlock.imageData;
                        } else {
                            console.warn(`üö® Source block ${sourceBlockKey} not available, using original image`);
                            // Fallback to original image with CORS protection
                            try {
                                ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        resolve(blob);
                                    } else {
                                        reject(new Error('Failed to create fallback image blob'));
                                    }
                                }, 'image/jpeg', 0.9);
                            } catch (error) {
                                console.warn('üîß Canvas tainted in final fallback');
                                reject(error);
                            }
                        }
                    }
                });
            }
            
            async initializeApiKey() {

                this.apiKey = "sk-fiMPhfEsjhT7GxYJUttnKZagHH4Py4Ru1Bsl5dgmnSBHF9Lc"
                this.apiKeyInput.placeholder = 'API Key Set ‚úì';
                this.setApiKeyBtn.textContent = 'Update';
                console.log('üîë API key loaded from environment variable');
            }
            

            
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.content.style.transition = 'none';
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastX;
                const deltaY = e.clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                console.log('üñ±Ô∏è Mouse move:', { deltaX, deltaY, translateX: this.translateX, translateY: this.translateY });
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateTransform();
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.viewer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const mouseX = e.clientX - centerX;
                const mouseY = e.clientY - centerY;
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * delta));
                
                if (newScale !== this.scale) {
                    const scaleDiff = newScale / this.scale;
                    
                    this.translateX = mouseX - (mouseX - this.translateX) * scaleDiff;
                    this.translateY = mouseY - (mouseY - this.translateY) * scaleDiff;
                    
                    console.log('üîç Wheel zoom:', { newScale, translateX: this.translateX, translateY: this.translateY });
                    
                    this.scale = newScale;
                    this.updateTransform();
                }
            }
            
            handleTouchStart(e) {
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    this.content.style.transition = 'none';
                }
                e.preventDefault();
            }
            
            handleTouchMove(e) {
                if (!this.isDragging || e.touches.length !== 1) return;
                
                const deltaX = e.touches[0].clientX - this.lastX;
                const deltaY = e.touches[0].clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                this.lastX = e.touches[0].clientX;
                this.lastY = e.touches[0].clientY;
                
                this.updateTransform();
                e.preventDefault();
            }
            
            handleTouchEnd() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            getVisibleBlocks() {
                if (!this.containerWidth || !this.containerHeight || !this.imageWidth || !this.imageHeight) {
                    return new Set();
                }

                const visibleBlocks = new Set();
                
                // BLOCK SYSTEM: Each block is exactly the original image size
                const blockWidth = this.imageWidth;
                const blockHeight = this.imageHeight;

                // Calculate viewport bounds in world coordinates
                // Original image is at world position (0,0) to (imageWidth, imageHeight)
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + this.containerWidth / this.scale;
                const viewportBottom = viewportTop + this.containerHeight / this.scale;

                // Calculate which blocks are visible
                const leftmostBlock = Math.floor(viewportLeft / blockWidth);
                const rightmostBlock = Math.ceil(viewportRight / blockWidth);
                const topmostBlock = Math.floor(viewportTop / blockHeight);
                const bottommostBlock = Math.ceil(viewportBottom / blockHeight);

                // Add all visible blocks (including original at 0,0)
                for (let x = leftmostBlock; x < rightmostBlock; x++) {
                    for (let y = topmostBlock; y < bottommostBlock; y++) {
                        visibleBlocks.add(`${x},${y}`);
                    }
                }

                return visibleBlocks;
            }
            
            updateGridSize() {
                this.drawGrid();
            }
            
            drawGrid() {
                // GRID ALIGNMENT: Grid lines should align with actual image boundaries
                // Need to account for how the image is positioned within the container
                
                const canvas = document.getElementById('gridCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Exit early if grid is not visible
                if (!this.gridVisible) return;
                
                // Block dimensions (each block = full image size)
                const blockWidth = this.imageWidth || 1600;   // 1600px
                const blockHeight = this.imageHeight || 1024; // 1024px
                
                // Calculate where the actual image is positioned within the container
                // The image uses object-fit: contain, so it's centered and scaled to fit
                const containerWidth = this.containerWidth;
                const containerHeight = this.containerHeight;
                const imageAspect = blockWidth / blockHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let actualImageWidth, actualImageHeight, imageOffsetX, imageOffsetY;
                
                if (imageAspect > containerAspect) {
                    // Image is wider - fits to container width
                    actualImageWidth = containerWidth;
                    actualImageHeight = containerWidth / imageAspect;
                    imageOffsetX = 0;
                    imageOffsetY = (containerHeight - actualImageHeight) / 2;
                } else {
                    // Image is taller - fits to container height
                    actualImageWidth = containerHeight * imageAspect;
                    actualImageHeight = containerHeight;
                    imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    imageOffsetY = 0;
                }
                
                console.log(`üîç IMAGE POSITIONING: container=${containerWidth}x${containerHeight}, actual=${actualImageWidth}x${actualImageHeight}, offset=(${imageOffsetX},${imageOffsetY})`);
                
                // Set grid line style
                ctx.strokeStyle = 'rgba(255, 255, 255, 1.0)';
                ctx.lineWidth = 1;
                
                // Draw complete infinite grid with image boundaries as reference
                // Image occupies one grid cell, bounded by grid lines
                
                // Calculate the center of the container (where image is positioned before transform)
                const containerCenterX = canvas.width / 2;
                const containerCenterY = canvas.height / 2;
                
                // Calculate where the top-left corner of the actual image appears
                // Image is centered, so top-left is at center minus half the scaled image size
                const scaledImageWidth = actualImageWidth * this.scale;
                const scaledImageHeight = actualImageHeight * this.scale;
                
                const imageTopLeftX = containerCenterX - (scaledImageWidth / 2) + this.translateX;
                const imageTopLeftY = containerCenterY - (scaledImageHeight / 2) + this.translateY;
                
                // Grid spacing equals scaled image dimensions
                const gridSpacingX = scaledImageWidth;
                const gridSpacingY = scaledImageHeight;
                
                // Draw vertical grid lines extending infinitely
                for (let i = -50; i <= 50; i++) {
                    const lineX = imageTopLeftX + (i * gridSpacingX);
                    
                    // Only draw lines that could be visible
                    if (lineX >= -canvas.width && lineX <= canvas.width * 2) {
                        ctx.beginPath();
                        ctx.moveTo(lineX, 0);
                        ctx.lineTo(lineX, canvas.height);
                        ctx.stroke();
                    }
                }
                
                // Draw horizontal grid lines extending infinitely
                for (let i = -50; i <= 50; i++) {
                    const lineY = imageTopLeftY + (i * gridSpacingY);
                    
                    // Only draw lines that could be visible
                    if (lineY >= -canvas.height && lineY <= canvas.height * 2) {
                        ctx.beginPath();
                        ctx.moveTo(0, lineY);
                        ctx.lineTo(canvas.width, lineY);
                        ctx.stroke();
                    }
                }
                
                console.log(`üîç INFINITE GRID: topLeft=(${imageTopLeftX},${imageTopLeftY}), spacing=(${gridSpacingX},${gridSpacingY}), scale=${this.scale}`);
            }
            
            showNotConnectedOverlay(blockKey) {
                const block = this.outfillBlocks.get(blockKey);
                if (block) {
                    block.status = 'not-connected';
                    this.updateOutfillBlock(blockKey, block);
                }
            }


            blobToDataUrl(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // Debug function to save blob to file
            saveDebugBlob(blob, blockKey, description = 'api-response') {

                
                try {
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const filename = `${description}_block-${blockKey}_${timestamp}.${blob.type.split('/')[1] || 'jpg'}`;
                    
                    // Create download link - COMMENTED OUT
                    // const url = URL.createObjectURL(blob);
                    // const a = document.createElement('a');
                    // a.href = url;
                    // a.download = filename;
                    // a.style.display = 'none';
                    
                    // // Trigger download
                    // document.body.appendChild(a);
                    // a.click();
                    // document.body.removeChild(a);
                    
                    // // Clean up URL
                    // setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    console.log('üêõ DEBUG: Saved blob to file:', filename, {
                        size: blob.size,
                        type: blob.type,
                        sizeKB: Math.round(blob.size / 1024)
                    });
                } catch (error) {
                    console.error('‚ùå Failed to save debug blob:', error);
                }
            }

            // Toggle debug windows and indicators
            toggleDebug() {
                const debugInfo = document.getElementById('debugInfo');
                const consoleCapture = document.getElementById('consoleCapture');

                if (debugInfo && consoleCapture) {
                    const isVisible = debugInfo.style.display !== 'none';
                    const newDisplay = isVisible ? 'none' : 'block';

                    debugInfo.style.display = newDisplay;
                    consoleCapture.style.display = newDisplay;

                    // Toggle zoom indicator only (queue indicator stays always visible)
                    if (this.zoomIndicator) {
                        this.zoomIndicator.style.display = newDisplay;
                    }

                    // Toggle debug preview window visibility (show/hide with debug mode)
                    if (this.debugPreview) {
                        if (newDisplay === 'block') {
                            // Show debug preview window when debug mode is enabled
                            this.debugPreview.classList.add('visible');
                            // Show placeholder or keep image hidden until content loads
                            if (!this.debugPreviewImage.src || this.debugPreviewImage.src === '') {
                                this.debugPreviewImage.style.display = 'none';
                            }
                        } else {
                            // Hide debug preview window when debug mode is disabled
                            this.debugPreview.classList.remove('visible');
                        }
                    }

                    console.log(`üîß Debug windows ${isVisible ? 'hidden' : 'shown'} (F12 or Ctrl+D to toggle)`);
                }
            }

            // Toggle grid visibility
            toggleGrid() {
                this.gridVisible = !this.gridVisible;
                this.drawGrid(); // Redraw grid with new visibility state
                console.log(`üîß Grid ${this.gridVisible ? 'shown' : 'hidden'} (Ctrl+G to toggle)`);
            }

            // Toggle auto-generation mode
            toggleAutoGeneration() {
                this.autoGenerateBlocks = !this.autoGenerateBlocks;

                if (this.autoGenToggleBtn) {
                    this.autoGenToggleBtn.textContent = this.autoGenerateBlocks ? 'Auto-Gen: ON' : 'Auto-Gen: OFF';
                    this.autoGenToggleBtn.style.background = this.autoGenerateBlocks ? '#4CAF50' : '#757575';
                }

                console.log('üîÑ Auto-generation:', this.autoGenerateBlocks ? 'ENABLED' : 'DISABLED');
                console.log('üîÑ Blocks will', this.autoGenerateBlocks ? 'be automatically added when visible' : 'NOT be automatically added (manual only)');
            }

            // Toggle API calls
            toggleApiCalls() {
                this.apiCallsEnabled = !this.apiCallsEnabled;

                if (this.apiCallsToggleBtn) {
                    this.apiCallsToggleBtn.textContent = this.apiCallsEnabled ? 'API: ON' : 'API: OFF';
                    this.apiCallsToggleBtn.style.background = this.apiCallsEnabled ? '#4CAF50' : '#757575';
                }

                console.log('üîÑ API calls:', this.apiCallsEnabled ? 'ENABLED' : 'DISABLED');
                console.log('üîÑ Blocks will', this.apiCallsEnabled ? 'make real API calls' : 'show grey loading blocks only');
            }
            
            // Toggle image opacity
            toggleImageOpacity() {
                this.imageTranslucent = !this.imageTranslucent;
                
                if (this.imageOpacityBtn) {
                    this.imageOpacityBtn.textContent = this.imageTranslucent ? 'Image: 50%' : 'Image: 100%';
                    this.imageOpacityBtn.style.background = this.imageTranslucent ? '#4CAF50' : '#757575';
                }
                
                // Apply opacity to main image
                if (this.image) {
                    this.image.style.opacity = this.imageTranslucent ? '0.5' : '1.0';
                }
                
                console.log('üîÑ Image opacity:', this.imageTranslucent ? '50%' : '100%');
            }
            
            // Toggle block layer (under/over image)
            toggleBlockLayer() {
                this.blocksOverImage = !this.blocksOverImage;
                
                if (this.blockLayerBtn) {
                    this.blockLayerBtn.textContent = this.blocksOverImage ? 'Blocks: Over' : 'Blocks: Under';
                    this.blockLayerBtn.style.background = this.blocksOverImage ? '#4CAF50' : '#757575';
                }
                
                // Update z-index of all existing outfill blocks
                const existingBlocks = document.querySelectorAll('[id^="outfill-"]');
                existingBlocks.forEach(block => {
                    block.style.zIndex = this.blocksOverImage ? '4' : '2';
                });
                
                console.log('üîÑ Block layer:', this.blocksOverImage ? 'OVER image' : 'UNDER image');
            }

            // Show debug preview with blob
            showDebugPreview(blob, blockKey, description = 'api-response') {
                if (!this.debugPreview) return;
                
                try {
                    // Create object URL for the blob
                    const imageUrl = URL.createObjectURL(blob);
                    
                    // Load image to get dimensions and resize window
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        // Scale down large images to reasonable preview size
                        const maxWidth = 400;
                        const maxHeight = 300;
                        let width = tempImg.width;
                        let height = tempImg.height;
                        
                        console.log(`üêõ DEBUG PREVIEW: Original image dimensions: ${width}x${height}, aspect ratio: ${(width/height).toFixed(3)}`);
                        
                        // Scale down if too large
                        if (width > maxWidth || height > maxHeight) {
                            const scaleX = maxWidth / width;
                            const scaleY = maxHeight / height;
                            const scale = Math.min(scaleX, scaleY);
                            width = Math.round(width * scale);
                            height = Math.round(height * scale);
                        }
                        
                        console.log(`üêõ DEBUG PREVIEW: Scaled dimensions: ${width}x${height}, aspect ratio: ${(width/height).toFixed(3)}`);
                        
                        // Resize debug preview window to scaled dimensions
                        this.debugPreview.style.width = width + 'px';
                        this.debugPreview.style.height = height + 'px';
                        
                        // Ensure left and bottom positioning
                        this.debugPreview.style.left = '0px';
                        this.debugPreview.style.bottom = '0px';
                        
                        // Update preview content - just show the image
                        this.debugPreviewImage.src = imageUrl;
                        this.debugPreviewImage.style.display = 'block';
                        
                        // Show the preview window
                        this.debugPreview.classList.add('visible');
                    };
                    tempImg.src = imageUrl;
                    
                    // Clean up the URL after a delay
                    setTimeout(() => {
                        URL.revokeObjectURL(imageUrl);
                    }, 30000); // Keep for 30 seconds
                    
                    console.log('üêõ DEBUG: Preview window updated with blob:', {
                        size: blob.size,
                        type: blob.type,
                        blockKey: blockKey,
                        description: description
                    });
                } catch (error) {
                    console.error('‚ùå Failed to show debug preview:', error);
                }
            }

            // Hide debug preview
            hideDebugPreview() {
                if (this.debugPreview) {
                    this.debugPreview.classList.remove('visible');
                    
                    // Clear the image source to free memory
                    if (this.debugPreviewImage) {
                        this.debugPreviewImage.src = '';
                    }
                }
            }
            
            showDebugError(title, errorMessage) {
                if (!this.debugPreview) return;
                
                // For simplified debug preview, just hide the image on error
                this.debugPreview.classList.add('visible');
                this.debugPreviewImage.style.display = 'none';
                console.error(`‚ùå ${title}: ${errorMessage}`);
            }
            
            updateOutfillBlock(blockKey, block) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // BLOCK SYSTEM: Each block is exactly the original image size
                const blockWidth = this.imageWidth;   // 1600px
                const blockHeight = this.imageHeight; // 1024px
                
                // Calculate where the original image is positioned within the container
                // The image uses object-fit: contain, so it's centered and scaled to fit
                const containerWidth = this.containerWidth;
                const containerHeight = this.containerHeight;
                const imageAspect = blockWidth / blockHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let actualImageWidth, actualImageHeight, imageOffsetX, imageOffsetY;
                
                if (imageAspect > containerAspect) {
                    // Image is wider - fits to container width
                    actualImageWidth = containerWidth;
                    actualImageHeight = containerWidth / imageAspect;
                    imageOffsetX = 0;
                    imageOffsetY = (containerHeight - actualImageHeight) / 2;
                } else {
                    // Image is taller - fits to container height
                    actualImageWidth = containerHeight * imageAspect;
                    actualImageHeight = containerHeight;
                    imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    imageOffsetY = 0;
                }
                
                // Calculate block position relative to the original image position
                // IMPORTANT: Blocks must be positioned relative to the UNTRANSFORMED image
                // because they are children of this.content which gets the CSS transform applied
                const blockLeft = imageOffsetX + (gridX * actualImageWidth);
                const blockTop = imageOffsetY + (gridY * actualImageHeight);
                
                let blockElement = document.getElementById(`outfill-${blockKey}`);
                if (!blockElement) {
                    blockElement = document.createElement('div');
                    blockElement.id = `outfill-${blockKey}`;
                    blockElement.style.position = 'absolute';
                    blockElement.style.zIndex = this.blocksOverImage ? '4' : '2';
                    this.content.appendChild(blockElement);
                }
                
                // Position block to align with grid (relative to untransformed coordinates)
                // The CSS transform on this.content will handle scaling and translation
                blockElement.style.left = blockLeft + 'px';
                blockElement.style.top = blockTop + 'px';
                blockElement.style.width = actualImageWidth + 'px';
                blockElement.style.height = actualImageHeight + 'px';
                
                console.log(`üîß Block ${blockKey} positioning: left=${blockLeft}px, top=${blockTop}px, width=${actualImageWidth}px, height=${actualImageHeight}px`);
                
                if (block.status === 'ready' || block.status === 'completed') {
                    console.log('üñºÔ∏è Setting block image:', blockKey, 'imageData:', block.imageData.substring(0, 50) + '...');
                    blockElement.style.backgroundImage = `url(${block.imageData})`;
                    blockElement.style.backgroundRepeat = 'no-repeat';
                    blockElement.style.backgroundColor = 'transparent';
                    blockElement.innerHTML = '';
                    
                    // SEAMLESS FIX: The extracted block image is already the correct size (blockSizeX x blockSizeY)
                    // We need to scale it to match the current container-fitted dimensions
                    // This maintains the aspect ratio and ensures seamless alignment
                    blockElement.style.backgroundSize = `${actualImageWidth}px ${actualImageHeight}px`;
                    blockElement.style.backgroundPosition = '0px 0px';
                    
                    console.log('üñºÔ∏è Block element updated with proper scaling:', blockElement.id, `extracted->display: ${this.imageWidth}x${this.imageHeight}->${actualImageWidth}x${actualImageHeight}`);
                } else if (block.status === 'generating') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                    const progressPercent = Math.round(block.progress * 100);
                    const circumference = 2 * Math.PI * 20; // radius = 20
                    const strokeDashoffset = circumference - (block.progress * circumference);
                    
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 50px;
                            height: 50px;
                        ">
                            <svg width="50" height="50" style="transform: rotate(-90deg);">
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(255, 255, 255, 0.2)" 
                                    stroke-width="3"/>
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(0, 255, 255, 0.8)" 
                                    stroke-width="3"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${strokeDashoffset}"
                                    stroke-linecap="round"
                                    style="transition: stroke-dashoffset 0.2s ease;"/>
                            </svg>
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                color: rgba(255, 255, 255, 0.9);
                                font-size: 10px;
                                font-weight: bold;
                                text-align: center;
                            ">${progressPercent}%</div>
                        </div>
                    `;
                } else if (block.status === 'queued') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.6);
                            font-size: 12px;
                            text-align: center;
                        ">‚è≥</div>
                    `;
                } else if (block.status === 'failed') {
                    blockElement.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.9);
                            font-size: 12px;
                            text-align: center;
                        ">‚ùå</div>
                    `;
                } else if (block.status === 'not-connected') {
                    blockElement.style.backgroundColor = 'rgba(255, 165, 0, 0.3)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.9);
                            font-size: 10px;
                            text-align: center;
                            line-height: 1.2;
                        ">üîå<br>No API</div>
                    `;
                }
            }
            
            isBlockAdjacentToContent(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // Check if block is adjacent to the original image at (0,0) or any completed blocks
                const adjacentPositions = [
                    [gridX - 1, gridY],     // Left
                    [gridX + 1, gridY],     // Right
                    [gridX, gridY - 1],     // Top
                    [gridX, gridY + 1],     // Bottom
                    [gridX - 1, gridY - 1], // Top-left
                    [gridX + 1, gridY - 1], // Top-right
                    [gridX - 1, gridY + 1], // Bottom-left
                    [gridX + 1, gridY + 1]  // Bottom-right
                ];
                
                for (const [adjX, adjY] of adjacentPositions) {
                    // Check if adjacent to original image at (0,0)
                    if (adjX === 0 && adjY === 0) {
                        return true;
                    }
                    
                    // Check if adjacent to any completed outfill block
                    const adjBlockKey = `${adjX},${adjY}`;
                    const adjBlock = this.outfillBlocks.get(adjBlockKey);
                    if (adjBlock && (adjBlock.status === 'ready' || adjBlock.status === 'completed')) {
                        return true;
                    }
                }
                
                return false;
            }
            
            checkForNewlyAdjacentBlocks(completedBlockKey) {
                const [completedX, completedY] = completedBlockKey.split(',').map(Number);
                
                // Check all positions adjacent to the completed block
                const adjacentPositions = [
                    [completedX - 1, completedY],     // Left
                    [completedX + 1, completedY],     // Right
                    [completedX, completedY - 1],     // Top
                    [completedX, completedY + 1],     // Bottom
                    [completedX - 1, completedY - 1], // Top-left
                    [completedX + 1, completedY - 1], // Top-right
                    [completedX - 1, completedY + 1], // Bottom-left
                    [completedX + 1, completedY + 1]  // Bottom-right
                ];
                
                const newlyAdjacentBlocks = [];
                
                for (const [adjX, adjY] of adjacentPositions) {
                    const adjBlockKey = `${adjX},${adjY}`;
                    
                    // Skip if this position is part of the original image
                    if (adjX >= 0 && adjX < this.blockDivisions && adjY >= 0 && adjY < this.blockDivisions) {
                        continue;
                    }
                    
                    // Skip if this block already exists in our system
                    if (this.outfillBlocks.has(adjBlockKey)) {
                        continue;
                    }
                    
                    // Check if this position is currently visible
                    const currentVisibleBlocks = this.getVisibleBlocks();
                    if (!currentVisibleBlocks.has(adjBlockKey)) {
                        continue;
                    }
                    
                    // This block is now adjacent to completed content and visible
                    newlyAdjacentBlocks.push(adjBlockKey);
                    console.log(`üÜï Found newly adjacent block: ${adjBlockKey} (adjacent to completed ${completedBlockKey})`);
                }
                
                // No longer adding to queue - using simple expansion trigger instead
                if (newlyAdjacentBlocks.length > 0) {
                    console.log('üöÄ Found newly adjacent blocks (no longer queuing):', newlyAdjacentBlocks);
                }
            }

            isBlockAdjacentToOriginalImage(gridX, gridY) {
                // Original image occupies blocks from (0,0) to (blockDivisions-1, blockDivisions-1)
                const originalMinX = 0;
                const originalMaxX = this.blockDivisions - 1;
                const originalMinY = 0;
                const originalMaxY = this.blockDivisions - 1;
                
                // Check if block is directly adjacent to the original image bounds
                const isLeftAdjacent = gridX === originalMinX - 1 && gridY >= originalMinY && gridY <= originalMaxY;
                const isRightAdjacent = gridX === originalMaxX + 1 && gridY >= originalMinY && gridY <= originalMaxY;
                const isTopAdjacent = gridY === originalMinY - 1 && gridX >= originalMinX && gridX <= originalMaxX;
                const isBottomAdjacent = gridY === originalMaxY + 1 && gridX >= originalMinX && gridX <= originalMaxX;
                
                // Check corner adjacency
                const isTopLeftCorner = gridX === originalMinX - 1 && gridY === originalMinY - 1;
                const isTopRightCorner = gridX === originalMaxX + 1 && gridY === originalMinY - 1;
                const isBottomLeftCorner = gridX === originalMinX - 1 && gridY === originalMaxY + 1;
                const isBottomRightCorner = gridX === originalMaxX + 1 && gridY === originalMaxY + 1;
                
                return isLeftAdjacent || isRightAdjacent || isTopAdjacent || isBottomAdjacent ||
                       isTopLeftCorner || isTopRightCorner || isBottomLeftCorner || isBottomRightCorner;
            }

            checkVisibleBlocks() {
                // Update debug info
                this.debugInfo.innerHTML = `
                    <div>Image: ${this.imageWidth}x${this.imageHeight}</div>
                    <div>Container: ${this.containerWidth}x${this.containerHeight}</div>
                    <div>Transform: ${this.translateX.toFixed(1)}, ${this.translateY.toFixed(1)}</div>
                    <div>Scale: ${this.scale.toFixed(2)}</div>
                    <div>Active: ${this.activeGenerations}</div>
                `;
                
                // Simple expansion trigger: when user gets near edge and we haven't expanded yet
                if (this.autoGenerateBlocks && !this.hasTriggeredExpansion && this.activeGenerations === 0) {
                    if (this.isNearImageEdge()) {
                        console.log('üéØ User near edge - triggering 3-block expansion');
                        this.triggerExpansion();
                    }
                }
            }
            
            // Simple edge detection - check if user is near any edge of the original image
            isNearImageEdge() {
                const margin = 200; // pixels from edge to trigger expansion
                
                // Calculate image bounds in screen coordinates
                const imageLeft = (this.containerWidth - this.imageWidth * this.scale) / 2 + this.translateX;
                const imageTop = (this.containerHeight - this.imageHeight * this.scale) / 2 + this.translateY;
                const imageRight = imageLeft + this.imageWidth * this.scale;
                const imageBottom = imageTop + this.imageHeight * this.scale;
                
                // Check if any edge is close to viewport
                const nearLeft = imageLeft > -margin;
                const nearRight = imageRight < this.containerWidth + margin;
                const nearTop = imageTop > -margin;
                const nearBottom = imageBottom < this.containerHeight + margin;
                
                return nearLeft || nearRight || nearTop || nearBottom;
            }
            
            // Create a placeholder block in the outfillBlocks map
            createBlock(blockKey) {
                if (!this.outfillBlocks.has(blockKey)) {
                    this.outfillBlocks.set(blockKey, {
                        status: 'generating',
                        progress: 0,
                        imageData: null
                    });
                    console.log(`üî≤ Created placeholder block ${blockKey}`);
                }
            }
            
            // Trigger the single strategic expansion - 2x2 call for blocks (0,0), (1,0), (0,1), (1,1)
            async triggerExpansion() {
                this.hasTriggeredExpansion = true;
                console.log('üéØ STRATEGIC EXPANSION: Making single 2x2 API call for 3-block trick');
                
                // Use direction (1,1) to get a 2x2 response covering:
                // (0,0) = original, (1,0) = right, (0,1) = down, (1,1) = diagonal
                const blockKey = '1,1'; // Target the diagonal block
                const directionX = 1;
                const directionY = 1;
                
                // Create placeholder blocks for the 3 new blocks we'll get
                this.createBlock('1,0'); // right
                this.createBlock('0,1'); // down  
                this.createBlock('1,1'); // diagonal
                
                // Make the strategic API call
//                await this.generateOutfill(blockKey, directionX, directionY);
                await this.callStabilityAPI(blockKey, directionX, directionY);
            }
            
            calculateBlockPriority(blockKey) {
                const [x, y] = blockKey.split(',').map(Number);
                const blockSizeX = this.imageWidth / this.blockDivisions;
                const blockSizeY = this.imageHeight / this.blockDivisions;
                
                // Calculate block bounds in image coordinates
                const blockLeft = x * blockSizeX;
                const blockTop = y * blockSizeY;
                const blockRight = blockLeft + blockSizeX;
                const blockBottom = blockTop + blockSizeY;
                
                // Get current viewport bounds in image coordinates
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + (this.containerWidth / this.scale);
                const viewportBottom = viewportTop + (this.containerHeight / this.scale);
                
                // Calculate intersection
                const intersectLeft = Math.max(blockLeft, viewportLeft);
                const intersectTop = Math.max(blockTop, viewportTop);
                const intersectRight = Math.min(blockRight, viewportRight);
                const intersectBottom = Math.min(blockBottom, viewportBottom);
                
                // Calculate visibility percentage
                let visibilityPercentage = 0;
                if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
                    const intersectArea = (intersectRight - intersectLeft) * (intersectBottom - intersectTop);
                    const blockArea = blockSizeX * blockSizeY;
                    visibilityPercentage = intersectArea / blockArea;
                }
                
                // Calculate distance from original image center (prioritize blocks closer to original content)
                const originalCenterX = this.imageWidth / 2;
                const originalCenterY = this.imageHeight / 2;
                const blockCenterX = blockLeft + blockSizeX / 2;
                const blockCenterY = blockTop + blockSizeY / 2;
                const distanceFromOriginal = Math.sqrt(
                    Math.pow(blockCenterX - originalCenterX, 2) + 
                    Math.pow(blockCenterY - originalCenterY, 2)
                );
                
                // Calculate distance from viewport center
                const viewportCenterX = viewportLeft + (this.containerWidth / this.scale) / 2;
                const viewportCenterY = viewportTop + (this.containerHeight / this.scale) / 2;
                const distanceFromViewport = Math.sqrt(
                    Math.pow(blockCenterX - viewportCenterX, 2) + 
                    Math.pow(blockCenterY - viewportCenterY, 2)
                );
                
                // Normalize distances
                const maxDistance = Math.sqrt(
                    Math.pow(this.imageWidth * 2, 2) + Math.pow(this.imageHeight * 2, 2)
                );
                const normalizedDistanceFromOriginal = 1 - (distanceFromOriginal / maxDistance);
                const normalizedDistanceFromViewport = 1 - (distanceFromViewport / maxDistance);
                
                // Calculate priority score
                let priority = visibilityPercentage * 100; // Base score from visibility (0-100)
                priority += normalizedDistanceFromOriginal * 50; // Proximity to original content (0-50)
                priority += normalizedDistanceFromViewport * 20; // Proximity to viewport (0-20)
                
                // Bonus for fully visible blocks
                if (visibilityPercentage >= 0.99) {
                    priority += 30;
                }
                
                // Extra bonus for blocks directly adjacent to original image
                if (this.isBlockAdjacentToOriginalImage(x, y)) {
                    priority += 100; // High priority for first-ring outpaint
                }
                
                return priority;
            }

            // Removed complex queue management and spiral system
            // Removed all strategic multi-block functions  
            // Replaced with simple 3-block trick expansion

            updateQueueIndicator() {
                const activeCount = this.activeGenerations;
                this.queueIndicator.textContent = `Active: ${activeCount} | Expansion: ${this.hasTriggeredExpansion ? 'Done' : 'Waiting'}`;
            }

            // All spiral system functions removed - replaced with simple strategic expansion

            async generateMaskForBlock(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // Create a canvas for the mask (2x2 for outpaint extensions)
                const canvas = document.createElement('canvas');
                canvas.width = this.imageWidth * 2;
                canvas.height = this.imageHeight * 2;
                const ctx = canvas.getContext('2d');
                
                // Fill with black (keep existing content)
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // BLOCKSIZE=1 SYSTEM: Original image is at center (0,0)
                // Mark the original image area as black (preserve)
                ctx.fillStyle = 'black';
                ctx.fillRect(
                    this.imageWidth / 2,
                    this.imageHeight / 2,
                    this.imageWidth,
                    this.imageHeight
                );
                
                // Mark the target extension area as white (outpaint)
                ctx.fillStyle = 'white';
                const targetX = this.imageWidth / 2 + (gridX * this.imageWidth);
                const targetY = this.imageHeight / 2 + (gridY * this.imageHeight);
                
                ctx.fillRect(
                    targetX,
                    targetY,
                    this.imageWidth,
                    this.imageHeight
                );
                
                console.log(`üé≠ Generated mask for block ${blockKey}: target area at (${targetX}, ${targetY})`);
                
                // Convert canvas to blob
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
            }

            getOutpaintDirections(blockKey) {
                const [targetGridX, targetGridY] = blockKey.split(',').map(Number);
                
                // CORE CONCEPT: Find the best filled adjacent block to use as source
                // Then calculate direction from source to target
                
                // Find adjacent filled blocks (up, down, left, right)
                const adjacentBlocks = [
                    { key: `${targetGridX-1},${targetGridY}`, dirX: 1, dirY: 0 }, // left neighbor -> go right
                    { key: `${targetGridX+1},${targetGridY}`, dirX: -1, dirY: 0 }, // right neighbor -> go left  
                    { key: `${targetGridX},${targetGridY-1}`, dirX: 0, dirY: 1 }, // up neighbor -> go down
                    { key: `${targetGridX},${targetGridY+1}`, dirX: 0, dirY: -1 }  // down neighbor -> go up
                ];
                
                // Find the first available filled block to use as source
                let sourceBlock = null;
                let directionX = 0;
                let directionY = 0;
                
                for (const adj of adjacentBlocks) {
                    if (this.outfillBlocks.has(adj.key) && this.outfillBlocks.get(adj.key).status === 'completed') {
                        sourceBlock = adj.key;
                        directionX = adj.dirX;
                        directionY = adj.dirY;
                        break;
                    }
                }
                
                // If no adjacent filled blocks, use original (0,0) as source
                if (!sourceBlock) {
                    sourceBlock = '0,0';
                    directionX = targetGridX > 0 ? 1 : (targetGridX < 0 ? -1 : 0);
                    directionY = targetGridY > 0 ? 1 : (targetGridY < 0 ? -1 : 0);
                }
                
                console.log(`üéØ Block ${blockKey}: source=${sourceBlock}, direction=(${directionX},${directionY})`);
                
                return { 
                    directionX, 
                    directionY, 
                    gridX: targetGridX, 
                    gridY: targetGridY,
                    sourceBlock: sourceBlock
                };
            }

            positionOutpaintBackground(blockElement, blockKey, directions) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                const gridSizeX = this.containerWidth / this.blockDivisions;
                const gridSizeY = this.containerHeight / this.blockDivisions;
                
                console.log(`üé® Positioning outpaint background for block ${blockKey}, directions:`, directions);
                console.log(`üé® Block divisions: ${this.blockDivisions}, Grid size: ${gridSizeX} √ó ${gridSizeY}`);
                console.log(`üé® Container size: ${this.containerWidth} √ó ${this.containerHeight}`);
                
                // The Stability AI outpaint API returns an image that contains:
                // 1. The original image in its original position
                // 2. The extended content in the requested directions
                // We need to position this composite image so that:
                // - The original image portion aligns with the actual original image
                // - Only the extended portion shows in this block
                
                if (directions.includes('right') && !directions.includes('left') && !directions.includes('up') && !directions.includes('bottom')) {
                    // Pure right outpaint
                    // Generated image = [original image][new content]
                    // We want to show only the new content in this block
                    // So we position the background so the new content aligns with this block
                    blockElement.style.backgroundSize = `${this.containerWidth + gridSizeX}px ${this.containerHeight}px`;
                    blockElement.style.backgroundPosition = `${-this.containerWidth}px 0px`;
                    console.log(`üé® Right outpaint: backgroundSize=${this.containerWidth + gridSizeX}x${this.containerHeight}, position=${-this.containerWidth},0`);
                    
                } else if (directions.includes('left') && !directions.includes('right') && !directions.includes('up') && !directions.includes('bottom')) {
                    // Pure left outpaint
                    // Generated image = [new content][original image]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth + gridSizeX}px ${this.containerHeight}px`;
                    blockElement.style.backgroundPosition = `0px 0px`;
                    console.log(`üé® Left outpaint: backgroundSize=${this.containerWidth + gridSizeX}x${this.containerHeight}, position=0,0`);
                    
                } else if (directions.includes('bottom') && !directions.includes('top') && !directions.includes('left') && !directions.includes('right')) {
                    // Pure bottom outpaint
                    // Generated image = [original image]
                    //                   [new content]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth}px ${this.containerHeight + gridSizeY}px`;
                    blockElement.style.backgroundPosition = `0px ${-this.containerHeight}px`;
                    console.log(`üé® Bottom outpaint: backgroundSize=${this.containerWidth}x${this.containerHeight + gridSizeY}, position=0,${-this.containerHeight}`);
                    
                } else if (directions.includes('up') && !directions.includes('bottom') && !directions.includes('left') && !directions.includes('right')) {
                    // Pure top outpaint
                    // Generated image = [new content]
                    //                   [original image]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth}px ${this.containerHeight + gridSizeY}px`;
                    blockElement.style.backgroundPosition = `0px 0px`;
                    console.log(`üé® Top outpaint: backgroundSize=${this.containerWidth}x${this.containerHeight + gridSizeY}, position=0,0`);
                    
                } else if (directions.length > 1) {
                    // Multi-direction outpaint (corner blocks)
                    // Calculate the total size of the generated image
                    const totalWidth = this.containerWidth + (directions.includes('left') ? gridSizeX : 0) + (directions.includes('right') ? gridSizeX : 0);
                    const totalHeight = this.containerHeight + (directions.includes('up') ? gridSizeY : 0) + (directions.includes('bottom') ? gridSizeY : 0);
                    
                    // Calculate the position offset to align the original image portion
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    // If there's left extension, the original image is shifted right in the generated image
                    if (directions.includes('left')) {
                        offsetX = -gridSizeX;
                    }
                    // If there's top extension, the original image is shifted down in the generated image
                    if (directions.includes('up')) {
                        offsetY = -gridSizeY;
                    }
                    
                    // Adjust offset based on which block we're positioning
                    if (directions.includes('right') && gridX >= this.blockDivisions) {
                        offsetX -= this.containerWidth;
                    }
                    if (directions.includes('bottom') && gridY >= this.blockDivisions) {
                        offsetY -= this.containerHeight;
                    }
                    
                    blockElement.style.backgroundSize = `${totalWidth}px ${totalHeight}px`;
                    blockElement.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
                    console.log(`üé® Multi-direction outpaint: backgroundSize=${totalWidth}x${totalHeight}, position=${offsetX},${offsetY}`);
                    
                } else {
                    // Fallback: simple fill
                    blockElement.style.backgroundSize = `${gridSizeX}px ${gridSizeY}px`;
                    blockElement.style.backgroundPosition = '0px 0px';
                    console.log(`üé® Fallback: Simple fill - backgroundSize=${gridSizeX}x${gridSizeY}, position=0,0`);
                }
            }

            async getSourceBlockAsBlob(sourceBlockKey) {
                if (sourceBlockKey === '0,0') {
                    // Use original image
                    return await this.getImageAsBlob();
                } else {
                    // Get the filled block's image
                    const sourceBlock = this.outfillBlocks.get(sourceBlockKey);
                    if (sourceBlock && sourceBlock.element && sourceBlock.element.style.backgroundImage) {
                        // Extract the background image URL and convert to blob
                        const bgImage = sourceBlock.element.style.backgroundImage;
                        const urlMatch = bgImage.match(/url\("?([^"]*)"?\)/);
                        if (urlMatch && urlMatch[1]) {
                            const response = await fetch(urlMatch[1]);
                            return await response.blob();
                        }
                    }
                    
                    // Fallback to original image if source block not available
                    console.warn(`‚ö†Ô∏è Source block ${sourceBlockKey} not available, using original image`);
                    return await this.getImageAsBlob();
                }
            }

            async callStabilityAPI(blockKey) {
                if (!this.apiCallsEnabled) {
                    console.log('üö´ API calls disabled - keeping grey loading block');
                    return;
                }
                
                if (!this.apiKey) {
                    throw new Error('No API key available');
                }

                try {
                    const { directionX, directionY, gridX, gridY, sourceBlock } = this.getOutpaintDirections(blockKey);
                    
                    // BLOCKSIZE=1: Each block is exactly the original image size
                    const blockSizeX = this.imageWidth;   // 1600px
                    const blockSizeY = this.imageHeight;  // 1024px
                    
                    console.log(`üé® API Call for block ${blockKey}: source=${sourceBlock}, direction=(${directionX},${directionY}), blockSize=${blockSizeX}x${blockSizeY}`);
                    
                    // Get the source block image as blob
                    const imageBlob = await this.getSourceBlockAsBlob(sourceBlock);
                    
                    // Prepare form data
                    const formData = new FormData();
                    formData.append('image', imageBlob, 'image.jpg');
                    formData.append('prompt', this.apiConfig.prompt);
                    formData.append('creativity', this.apiConfig.creativity.toString());
                    formData.append('output_format', this.apiConfig.output_format);
                    
                    // Add direction-based outpaint parameters
                    if (directionX > 0) {
                        formData.append('right', blockSizeX.toString());
                    } else if (directionX < 0) {
                        formData.append('left', blockSizeX.toString());
                    }
                    
                    if (directionY > 0) {
                        formData.append('down', blockSizeY.toString());
                    } else if (directionY < 0) {
                        formData.append('up', blockSizeY.toString());
                    }
                    
                    // Add optional parameters
                    if (this.apiConfig.seed !== null) {
                        formData.append('seed', this.apiConfig.seed.toString());
                    }
                    if (this.apiConfig.style_preset !== null) {
                        formData.append('style_preset', this.apiConfig.style_preset);
                    }
                    
                    console.log(`üì§ API Request: ${directionX > 0 ? 'right=' + blockSizeX : ''}${directionX < 0 ? 'left=' + blockSizeX : ''}${directionY > 0 ? ' down=' + blockSizeY : ''}${directionY < 0 ? ' up=' + blockSizeY : ''}`);
                    
                    // Make API call
                    const response = await fetch(this.apiConfig.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Accept': 'image/*'
                        },
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API call failed: ${response.status} - ${errorText}`);
                    }
                    
                    // Get the response blob
                    const responseBlob = await response.blob();
                    
                    // Process multi-block response
                    return await this.processMultiBlockResponse(responseBlob, blockKey, directionX, directionY);
                    
                } catch (error) {
                    console.error('Stability API error:', error);
                    throw error;
                }
            }
// FUNC
            async processMultiBlockResponse(responseBlob, targetBlockKey, directionX, directionY) {
                console.log(`üéØ SIMPLE OVERLAY: Just position 2x2 response over original image`);
                
                // Create image element for the 2x2 response
                const responseImage = new Image();
                const imageUrl = URL.createObjectURL(responseBlob);
                
                return new Promise((resolve, reject) => {
                    responseImage.onload = () => {
                        try {
                            console.log(`üìê 2x2 Response: ${responseImage.width}x${responseImage.height}`);
                            
                            // Create overlay div positioned at original image location
                            const overlay = document.createElement('div');
                            overlay.id = 'expansion-overlay';
                            overlay.style.position = 'absolute';
                            overlay.style.left = '0px';  // Align with original image
                            overlay.style.top = '0px';   // Align with original image
                            overlay.style.width = `${responseImage.width}px`;
                            overlay.style.height = `${responseImage.height}px`;
                            overlay.style.backgroundImage = `url(${imageUrl})`;
                            overlay.style.backgroundSize = 'contain';
                            overlay.style.backgroundRepeat = 'no-repeat';
                            overlay.style.zIndex = '10';
                            overlay.style.pointerEvents = 'none';
                            
                            // Add to viewer content container
                            const viewerContent = document.getElementById('viewerContent');
                            if (viewerContent) {
                                viewerContent.appendChild(overlay);
                                console.log(`‚úÖ Overlay added to viewerContent`);
                            } else {
                                console.error('‚ùå viewerContent not found');
                                reject(new Error('viewerContent container not found'));
                                return;
                            }
                            
                            console.log(`‚úÖ 2x2 overlay created and positioned`);
                            
                            // üåÄ Start iterative expansion after first overlay
                            setTimeout(() => {
                                console.log('üåÄ Triggering iterative expansion in 5 seconds...');
                                this.startIterativeExpansion();
                            }, 5000);
                            
                            resolve(imageUrl);
                            
                        } catch (error) {
                            console.error('Error creating overlay:', error);
                            reject(error);
                        }
                    };
                    
                    responseImage.onerror = () => {
                        reject(new Error('Failed to load response image'));
                    };
                    
                    responseImage.src = imageUrl;
                });
            }

            // Create single 2x2 overlay positioned over original image
            create2x2Overlay(responseImage, sourceBlock, directionX, directionY, targetBlockKey) {
                try {
                    console.log(`üñºÔ∏è Creating 2x2 overlay: source=${sourceBlock}, direction=(${directionX},${directionY})`);
                    
                    const [sourceGridX, sourceGridY] = sourceBlock.split(',').map(Number);
                    const blockWidth = this.imageWidth;   // 1600px
                    const blockHeight = this.imageHeight; // 1024px
                    
                    // Create overlay element
                    const overlayDiv = document.createElement('div');
                    overlayDiv.className = 'outfill-block overlay-2x2';
                    overlayDiv.style.position = 'absolute';
                    overlayDiv.style.pointerEvents = 'none';
                    overlayDiv.style.zIndex = '10'; // Above regular blocks
                    
                    // Size = 2x2 blocks
                    overlayDiv.style.width = (blockWidth * 2) + 'px';
                    overlayDiv.style.height = (blockHeight * 2) + 'px';
                    
                    // Position so top-left aligns with source block
                    const sourceLeft = sourceGridX * blockWidth;
                    const sourceTop = sourceGridY * blockHeight;
                    overlayDiv.style.left = sourceLeft + 'px';
                    overlayDiv.style.top = sourceTop + 'px';
                    
                    // Create image element
                    const img = document.createElement('img');
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.display = 'block';
                    
                    // Convert response image to blob URL
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = responseImage.width;
                    canvas.height = responseImage.height;
                    ctx.drawImage(responseImage, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            const imageUrl = URL.createObjectURL(blob);
                            img.src = imageUrl;
                            
                            // Clean up URL after image loads
                            img.onload = () => {
                                setTimeout(() => URL.revokeObjectURL(imageUrl), 1000);
                            };
                        }
                    }, 'image/jpeg', 0.9);
                    
                    overlayDiv.appendChild(img);
                    
                    // Add to viewer content container
                    const viewerContent = document.querySelector('.viewer-content');
                    if (viewerContent) {
                        viewerContent.appendChild(overlayDiv);
                        console.log(`‚úÖ 2x2 overlay created: ${blockWidth*2}x${blockHeight*2} at (${sourceLeft},${sourceTop})`);
                    } else {
                        console.error('‚ùå Viewer content container not found for 2x2 overlay');
                    }
                    
                    // Store overlay reference for cleanup
                    const overlayKey = `overlay-${targetBlockKey}`;
                    if (!this.overlays) this.overlays = new Map();
                    this.overlays.set(overlayKey, overlayDiv);
                    
                } catch (error) {
                    console.error('‚ùå Error creating 2x2 overlay:', error);
                }
            }

            extract2x2Blocks(responseImage, sourceBlock, directionX, directionY, newBlocks) {
                const blockWidth = this.imageWidth;   // 1600px
                const blockHeight = this.imageHeight; // 1024px
                
                console.log(`üß© Extracting blocks from 2x2 response: ${responseImage.width}x${responseImage.height}`);
                
                // Create canvas for extraction
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = blockWidth;
                canvas.height = blockHeight;
                
                // Extract each new block from the 2x2 response
                for (const blockKey of newBlocks) {
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    const [sourceGridX, sourceGridY] = sourceBlock.split(',').map(Number);
                    
                    // Calculate position in 2x2 response
                    let sourceX = 0;
                    let sourceY = 0;
                    
                    if (gridX > sourceGridX) sourceX = blockWidth;  // Right half
                    if (gridY > sourceGridY) sourceY = blockHeight; // Bottom half
                    
                    console.log(`üß© Extracting block ${blockKey} from position (${sourceX},${sourceY})`);
                    
                    // Clear canvas and extract block
                    ctx.clearRect(0, 0, blockWidth, blockHeight);
                    ctx.drawImage(responseImage, sourceX, sourceY, blockWidth, blockHeight, 0, 0, blockWidth, blockHeight);
                    
                    // Convert to blob and create block
                    canvas.toBlob((blob) => {
                        if (blob) {
                            const imageUrl = URL.createObjectURL(blob);
                            this.createFilledBlock(blockKey, imageUrl);
                        }
                    }, 'image/jpeg', 0.9);
                }
            }
            
            createFilledBlock(blockKey, imageUrl) {
                console.log(`‚úÖ Creating filled block ${blockKey}`);
                
                // Create block element
                const blockElement = document.createElement('div');
                blockElement.className = 'outfill-block';
                blockElement.style.backgroundImage = `url(${imageUrl})`;
                blockElement.style.backgroundSize = 'cover';
                blockElement.style.backgroundPosition = 'center';
                
                // Position block in grid
                const [gridX, gridY] = blockKey.split(',').map(Number);
                const blockSizeX = this.containerWidth;
                const blockSizeY = this.containerHeight;
                
                blockElement.style.position = 'absolute';
                blockElement.style.left = (gridX * blockSizeX) + 'px';
                blockElement.style.top = (gridY * blockSizeY) + 'px';
                blockElement.style.width = blockSizeX + 'px';
                blockElement.style.height = blockSizeY + 'px';
                blockElement.style.zIndex = this.blocksOverImage ? '5' : '1';
                
                // Add to container
                this.content.appendChild(blockElement);
                
                // Store in blocks map
                this.outfillBlocks.set(blockKey, {
                    status: 'completed',
                    progress: 1,
                    element: blockElement,
                    imageUrl: imageUrl
                });
                
                console.log(`‚úÖ Block ${blockKey} created and positioned`);
            }

            updateTransform() {
                this.content.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
                this.zoomIndicator.textContent = `${this.scale.toFixed(2)}x`;
                this.drawGrid(); // Redraw grid when transform changes
                this.checkVisibleBlocks();
            }

            // üåÄ ITERATIVE EXPANSION SYSTEM
            // Captures current expanded image and uses it for next API call
            async startIterativeExpansion() {
                console.log('üåÄ STARTING ITERATIVE EXPANSION SYSTEM');
                
                // Wait for current expansion to complete
                await this.waitForCurrentExpansion();
                
                // Start expansion loop
                this.expansionLoop();
            }

            async waitForCurrentExpansion() {
                // Wait until no active generations
                while (this.activeGenerations > 0) {
                    console.log('‚è≥ Waiting for current expansion to complete...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                console.log('‚úÖ Current expansion complete, ready for next iteration');
            }

            async expansionLoop() {
                console.log('üîÑ Starting expansion loop');
                
                // Capture current expanded image (original + all overlays)
                const expandedImageBlob = await this.captureExpandedImage();
                
                if (expandedImageBlob) {
                    console.log('üì∏ Captured expanded image, making next API call');
                    
                    // Make next API call using expanded image
                    await this.expandFromCapturedImage(expandedImageBlob);
                    
                    // Schedule next iteration
                    setTimeout(() => {
                        this.expansionLoop();
                    }, 3000); // 3 second delay between expansions
                } else {
                    console.log('‚ùå Failed to capture expanded image, stopping expansion');
                }
            }

            async captureExpandedImage() {
                try {
                    console.log('üì∏ Capturing current expanded image...');
                    
                    // Get the viewer content container
                    const viewerContent = document.getElementById('viewerContent');
                    if (!viewerContent) {
                        throw new Error('viewerContent not found');
                    }

                    // Create canvas to capture the current state
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Find the expansion overlay (the 2x2 result)
                    const overlay = document.getElementById('expansion-overlay');
                    if (!overlay) {
                        console.log('‚ö†Ô∏è No expansion overlay found, using original image');
                        return await this.getImageAsBlob();
                    }

                    // Get overlay dimensions
                    const overlayRect = overlay.getBoundingClientRect();
                    canvas.width = overlayRect.width;
                    canvas.height = overlayRect.height;

                    // Draw the overlay background image to canvas
                    const overlayImage = new Image();
                    const overlayBgImage = overlay.style.backgroundImage;
                    const imageUrl = overlayBgImage.slice(5, -2); // Remove 'url("' and '")'
                    
                    return new Promise((resolve) => {
                        overlayImage.onload = () => {
                            ctx.drawImage(overlayImage, 0, 0, canvas.width, canvas.height);
                            
                            canvas.toBlob((blob) => {
                                console.log(`‚úÖ Captured expanded image: ${blob.size} bytes`);
                                resolve(blob);
                            }, 'image/jpeg', 0.9);
                        };
                        
                        overlayImage.onerror = () => {
                            console.log('‚ùå Failed to load overlay image, using original');
                            resolve(null);
                        };
                        
                        overlayImage.src = imageUrl;
                    });

                } catch (error) {
                    console.error('‚ùå Error capturing expanded image:', error);
                    return null;
                }
            }

            async expandFromCapturedImage(imageBlob) {
                try {
                    console.log('üé® Making API call with captured expanded image');
                    
                    // Remove existing overlay to prepare for new one
                    const existingOverlay = document.getElementById('expansion-overlay');
                    if (existingOverlay) {
                        existingOverlay.remove();
                        console.log('üóëÔ∏è Removed existing overlay');
                    }

                    // Make API call with the captured image
                    const response = await this.callStabilityAPIWithBlob(imageBlob, 'right', 1600, 'down', 1024);
                    
                    if (response) {
                        console.log('‚úÖ Iterative expansion API call successful');
                        await this.processMultiBlockResponse(response, '1,0', 1, 0);
                    } else {
                        console.log('‚ùå Iterative expansion API call failed');
                    }

                } catch (error) {
                    console.error('‚ùå Error in iterative expansion:', error);
                }
            }

            async callStabilityAPIWithBlob(imageBlob, ...directions) {
                // Use the existing API call logic but with provided blob
                const originalGetImageAsBlob = this.getImageAsBlob;
                
                // Temporarily override getImageAsBlob to return our captured image
                this.getImageAsBlob = () => Promise.resolve(imageBlob);
                
                try {
                    // Make the API call
                    const response = await this.makeStabilityAPICall(...directions);
                    return response;
                } finally {
                    // Restore original method
                    this.getImageAsBlob = originalGetImageAsBlob;
                }
            }

            async makeStabilityAPICall(leftDirection, leftPixels, rightDirection, rightPixels, upDirection, upPixels, downDirection, downPixels) {
                try {
                    const imageBlob = await this.getImageAsBlob();
                    
                    const formData = new FormData();
                    formData.append('image', imageBlob, 'image.jpg');
                    
                    // Add direction parameters
                    if (leftDirection && leftPixels) formData.append(leftDirection, leftPixels);
                    if (rightDirection && rightPixels) formData.append(rightDirection, rightPixels);
                    if (upDirection && upPixels) formData.append(upDirection, upPixels);
                    if (downDirection && downPixels) formData.append(downDirection, downPixels);
                    
                    formData.append('prompt', 'psychedelic floral pattern, vibrant colors, organic shapes, detailed botanical elements');
                    formData.append('creativity', '0.35');
                    formData.append('output_format', 'jpeg');

                    const response = await fetch('https://api.stability.ai/v2beta/stable-image/edit/outpaint', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Accept': 'image/*'
                        },
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`API call failed: ${response.status} ${response.statusText}`);
                    }

                    return await response.blob();
                } catch (error) {
                    console.error('‚ùå API call error:', error);
                    return null;
                }
            }
            

        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // In standalone mode, convert image to data URL to avoid canvas tainting
            if (window.location.protocol === 'file:') {
                const img = document.getElementById('mainImage');
                
                // Remove crossorigin attribute for file:// protocol to avoid CORS issues
                img.removeAttribute('crossorigin');
                
                // Force reload the image to ensure it loads without crossorigin
                const originalSrc = img.src;
                img.src = '';
                
                img.onload = () => {
                    console.log('üîß Image loaded successfully, converting to data URL...');
                    convertAndInitialize();
                };
                
                img.onerror = (error) => {
                    console.error('‚ùå Image failed to load:', error);
                    // Initialize viewer anyway
                    window.viewer = new ImageViewer();
                };
                
                // Reload the image
                img.src = originalSrc;
                
                function convertAndInitialize() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Use actual image dimensions
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        
                        console.log('üîß Converting image to data URL...', {
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            src: img.src
                        });
                        
                        // Draw the image to canvas
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert to data URL (this should work since crossorigin is removed)
                        const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                        
                        // Replace image source with data URL
                        img.src = dataURL;
                        console.log('‚úÖ Successfully converted image to data URL');
                        
                        // Initialize viewer after successful conversion
                        setTimeout(() => {
                            window.viewer = new ImageViewer();
                        }, 100);
                        
                    } catch (error) {
                        console.error('‚ùå Failed to convert image to data URL:', error.message);
                        // Initialize viewer anyway but it will have tainting issues
                        window.viewer = new ImageViewer();
                    }
                }
            } else {
                // Server mode - initialize normally with crossorigin for CORS
                const img = document.getElementById('mainImage');
                img.setAttribute('crossorigin', 'anonymous');
                window.viewer = new ImageViewer();
            }
        });
        
        // Replace the placeholder image with your actual image
        // Just change the src attribute of the img element to your image path
        // document.getElementById('mainImage').src = 'path/to/your/psychedelic-flora.jpg';
    </script>
</body>
</html>