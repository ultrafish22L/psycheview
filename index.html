<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PsycheView - Standalone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Animated Background */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #fb5607);
            background-size: 400% 400%;
            animation: psychedelicFlow 120s ease-in-out infinite;
        }

        @keyframes psychedelicFlow {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        /* Floating elements */
        .psychedelic-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(2px);
            animation: psychedelicFloat 20s ease-in-out infinite;
        }

        .psychedelic-orb:nth-child(1) {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 0, 110, 0.8), transparent);
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .psychedelic-orb:nth-child(2) {
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(131, 56, 236, 0.8), transparent);
            top: 60%;
            right: 15%;
            animation-delay: -5s;
        }

        .psychedelic-orb:nth-child(3) {
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, rgba(58, 134, 255, 0.8), transparent);
            bottom: 20%;
            left: 20%;
            animation-delay: -10s;
        }

        .psychedelic-orb:nth-child(4) {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(6, 255, 165, 0.8), transparent);
            top: 30%;
            right: 40%;
            animation-delay: -15s;
        }

        @keyframes psychedelicFloat {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            25% { transform: translate(50px, -30px) scale(1.2) rotate(90deg); }
            50% { transform: translate(-30px, 40px) scale(0.8) rotate(180deg); }
            75% { transform: translate(40px, 20px) scale(1.1) rotate(270deg); }
        }

        /* Main container */
        .app-container {
            position: relative;
            min-height: 100vh;
        }



        /* Image Viewer */
        .image-viewer {
            position: relative;
            margin: 60px auto;
            overflow: hidden;
            cursor: grab;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.4);
        }

        .image-viewer:active {
            cursor: grabbing;
        }

        .viewer-content {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        /* Tiled Background */
        .tiled-background {
            position: absolute;
            width: 1000%;
            height: 1000%;
            top: -450%;
            left: -450%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255, 0, 255, 0.15) 20%, transparent 25%),
                radial-gradient(circle at 0% 0%, rgba(0, 255, 255, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 0%, rgba(255, 255, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 0% 100%, rgba(255, 100, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 100%, rgba(100, 255, 100, 0.12) 15%, transparent 20%),
                linear-gradient(0deg, transparent 45%, rgba(255, 0, 100, 0.08) 47%, rgba(255, 0, 100, 0.08) 53%, transparent 55%),
                linear-gradient(60deg, transparent 45%, rgba(100, 0, 255, 0.08) 47%, rgba(100, 0, 255, 0.08) 53%, transparent 55%),
                linear-gradient(120deg, transparent 45%, rgba(0, 255, 150, 0.08) 47%, rgba(0, 255, 150, 0.08) 53%, transparent 55%),
                radial-gradient(ellipse 30px 52px at 50% 50%, rgba(255, 150, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 0% 0%, rgba(150, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 100% 100%, rgba(255, 0, 150, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 40px 20px at 25% 25%, rgba(255, 255, 0, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 40px 20px at 75% 75%, rgba(0, 255, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 75% 25%, rgba(255, 0, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 25% 75%, rgba(100, 255, 100, 0.06) 0%, transparent 70%);
            background-size: 
                120px 120px,
                240px 240px,
                240px 240px,
                240px 240px,
                240px 240px,
                80px 138px,
                80px 138px,
                80px 138px,
                60px 104px,
                120px 208px,
                120px 208px,
                160px 160px,
                160px 160px,
                160px 160px,
                160px 160px;
            background-position:
                60px 60px,
                0px 0px,
                120px 0px,
                0px 120px,
                120px 120px,
                0px 0px,
                40px 69px,
                80px 0px,
                30px 52px,
                60px 104px,
                90px 156px,
                0px 0px,
                80px 80px,
                40px 120px,
                120px 40px;
            background-repeat: repeat;
            opacity: 0.5;
            mix-blend-mode: multiply;
            filter: saturate(1.3) contrast(1.1) brightness(1.2);
            animation: islamicShift 90s ease-in-out infinite;
        }

        @keyframes islamicShift {
            0%, 100% { 
                filter: saturate(1.3) contrast(1.1) brightness(1.2) hue-rotate(0deg);
                opacity: 0.5;
            }
            25% { 
                filter: saturate(1.6) contrast(1.3) brightness(1.0) hue-rotate(90deg);
                opacity: 0.6;
            }
            50% { 
                filter: saturate(1.4) contrast(1.4) brightness(1.3) hue-rotate(180deg);
                opacity: 0.4;
            }
            75% { 
                filter: saturate(1.8) contrast(1.2) brightness(1.1) hue-rotate(270deg);
                opacity: 0.7;
            }
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes subtleGridShift {
            0%, 100% { 
                opacity: 0.3;
                filter: hue-rotate(0deg) saturate(1.2);
            }
            33% { 
                opacity: 0.4;
                filter: hue-rotate(120deg) saturate(1.4);
            }
            66% { 
                opacity: 0.2;
                filter: hue-rotate(240deg) saturate(1.1);
            }
        }

        /* Main Image - Fill container for consistent sizing */
        .main-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;  /* Maintain aspect ratio, fit within container */
            z-index: 3;
        }

        /* Zoom indicator - hidden by default, shown only in debug mode */
        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-family: monospace;
            display: none;
        }

        /* Queue indicator - always visible, positioned top-right but left of debug windows */
        .queue-indicator {
            position: fixed;
            top: 20px;
            right: 300px; /* Left of debug windows (280px width + 20px margin) */
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            display: block; /* Always visible */
        }



        /* API Key Input */
        .api-key-input {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }

        .api-key-input input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            width: 200px;
            outline: none;
        }

        .api-key-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .api-key-input input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .api-key-input button {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .api-key-input button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .api-key-input button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }



        /* Debug Preview Window - styled like debug windows, no header/footer */
        .debug-preview {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 280px;
            height: 50vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-right: 2px solid #444;
            border-top: 2px solid #444;
            z-index: 1000;
            display: none;
            overflow: hidden;
            padding: 0;
        }

        .debug-preview.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .debug-preview-image {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
        }
    </style>
</head>
<body>
    <div class="animated-background">
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
    </div>

    <div class="app-container">

        


        <div class="api-key-input" id="apiKeyContainer">
            <input type="password" id="apiKeyInput" placeholder="Enter Stability AI API Key" />
            <button id="setApiKeyBtn">Set Key</button>


        </div>

        <div class="image-viewer" id="imageViewer">
            <canvas class="grid-overlay" id="gridCanvas"></canvas>
            <div class="viewer-content" id="viewerContent">
                <div class="tiled-background"></div>
                <img class="main-image" id="mainImage" src="psychedelic-flora.jpg" alt="Psychedelic Flora" draggable="false">
            </div>
            <div class="zoom-indicator" id="zoomIndicator">1.00x</div>

        </div>
    </div>

    <!-- Queue indicator - always visible in top row -->
    <div class="queue-indicator" id="queueIndicator">Queue: 0 | Active: 0</div>

    <!-- Debug windows positioned outside app-container for true browser window positioning -->
    <div class="debug-info" id="debugInfo" style="position: fixed; top: 0; right: 0; width: 280px; height: 50vh; background: rgba(0,0,0,0.85); color: white; padding: 12px; font-family: monospace; font-size: 10px; z-index: 1000; overflow-y: auto; border-left: 2px solid #444; backdrop-filter: blur(10px); display: none;">
        Debug Info
    </div>
    
    <!-- Console capture div positioned outside app-container for true browser window positioning -->
    <div id="consoleCapture" style="position: fixed; top: 50vh; right: 0; width: 280px; height: 50vh; background: rgba(0,0,0,0.9); color: #00ff00; padding: 12px; font-family: monospace; font-size: 9px; z-index: 1001; overflow-y: auto; border-left: 2px solid #333; backdrop-filter: blur(10px); display: none;">
        <div style="color: #ffff00; margin-bottom: 8px; font-weight: bold;">üñ•Ô∏è CONSOLE OUTPUT:</div>
        <div id="consoleLogs"></div>
    </div>

    <!-- Debug Preview Window - simplified, no header/footer -->
    <div class="debug-preview" id="debugPreview">
        <img class="debug-preview-image" id="debugPreviewImage" alt="Generated Image" style="display: none;">
    </div>

    <script>
        // Override console to capture logs
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const logs = [];
        
        console.log = function(...args) {
            logs.push({type: 'log', message: args.join(' '), time: new Date().toLocaleTimeString()});
            originalConsoleLog.apply(console, args);
            updateDebugConsole();
            updateConsoleCapture();
        };
        
        console.error = function(...args) {
            logs.push({type: 'error', message: args.join(' '), time: new Date().toLocaleTimeString()});
            originalConsoleError.apply(console, args);
            updateDebugConsole();
            updateConsoleCapture();
        };
        
        function updateDebugConsole() {
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                const lastLogs = logs.slice(-10); // Show last 10 logs
                debugInfo.innerHTML = 'Debug Console:<br>' + lastLogs.map(log => 
                    `<span style="color: ${log.type === 'error' ? '#ff4444' : '#44ff44'}">[${log.time}] ${log.message}</span>`
                ).join('<br>');
                // Auto-scroll to bottom
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        function updateConsoleCapture() {
            const consoleDiv = document.getElementById('consoleLogs');
            if (consoleDiv) {
                const lastLogs = logs.slice(-20); // Show last 20 logs
                consoleDiv.innerHTML = lastLogs.map(log =>
                    `<div style="color: ${log.type === 'error' ? '#ff4444' : '#00ff00'}; margin-bottom: 2px; font-size: 10px;">[${log.time}] ${log.message}</div>`
                ).join('');
                // Auto-scroll to bottom
                const captureDiv = document.getElementById('consoleCapture');
                if (captureDiv) {
                    captureDiv.scrollTop = captureDiv.scrollHeight;
                }
            }
        }
        
        class ImageViewer {
            constructor() {
                this.viewer = document.getElementById('imageViewer');
                this.content = document.getElementById('viewerContent');
                this.image = document.getElementById('mainImage');
                
                // API Configuration
                this.config = {
                    endpoint: 'https://api.stability.ai/v2beta/stable-image/edit/outpaint',
                    prompt: 'Extend this psychedelic floral pattern with vibrant colors, intricate botanical details, and flowing organic shapes that seamlessly blend with the existing artwork',
                    output_format: 'jpeg',
                    creativity: 0.35,
                    seed: null
                };
                this.zoomIndicator = document.getElementById('zoomIndicator');
                this.queueIndicator = document.getElementById('queueIndicator');

                this.debugInfo = document.getElementById('debugInfo');
                this.apiKeyInput = document.getElementById('apiKeyInput');
                this.setApiKeyBtn = document.getElementById('setApiKeyBtn');
                this.testApiBtn = document.getElementById('testApiBtn');

                this.autoGenToggleBtn = document.getElementById('autoGenToggleBtn');
                this.apiCallsToggleBtn = document.getElementById('apiCallsToggleBtn');
                this.testPanBtn = document.getElementById('testPanBtn');
                this.zoomOutMaxBtn = document.getElementById('zoomOutMaxBtn');
                this.imageOpacityBtn = document.getElementById('imageOpacityBtn');
                this.blockLayerBtn = document.getElementById('blockLayerBtn');

                
                // Debug preview elements
                this.debugPreview = document.getElementById('debugPreview');
                this.debugPreviewImage = document.getElementById('debugPreviewImage');

                

                

                

                

                

                
                this.scale = 0.5;
                this.translateX = 0;
                this.translateY = 0;
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                this.minScale = 0.25;
                this.maxScale = 4;
                
                // Block size configuration (1 = same size as image, 4 = quarter size, etc.)
                this.blockDivisions = 1; // Default: blocks are same size as image for easier testing
                
                // Auto-generation control (default: true - blocks are added automatically)
                this.autoGenerateBlocks = true;
                
                // API calls control
                this.apiCallsEnabled = true;
                
                // Image opacity control (false = 100%, true = 50%)
                this.imageTranslucent = false;
                
                // Block layer control (false = under image, true = over image)
                this.blocksOverImage = false;
                
                // Grid visibility control (false = hidden, true = visible)
                this.gridVisible = false;
                
                // Mode system
                this.isLiveMode = true; // Start in live mode by default
                this.apiKey = 'sk-khSJsDLcgZd4LxCCRoylXQhiZmPwbAWfdiKCuZ71YzkoJvm8';

                
                // Stability AI API Configuration
                this.apiConfig = {
                    endpoint: 'https://api.stability.ai/v2beta/stable-image/edit/outpaint',
                    prompt: 'Extend this psychedelic floral pattern with vibrant colors, intricate botanical details, and flowing organic shapes that seamlessly blend with the existing artwork',
                    seed: null, // null for random seed
                    output_format: 'jpeg',
                    creativity: 0.35,
                    style_preset: null // null for default style
                };
                
                // Outfill properties
                this.outfillBlocks = new Map();
                this.generationQueue = [];
                this.activeGenerations = 0;
                this.lastVisibleBlocks = new Set();
                this.imageWidth = 0;
                this.imageHeight = 0;
                
                this.init();
            }
            
            init() {
                // Set up container size based on image aspect ratio - windowed approach
                const setupSize = () => {
                    // In standalone mode, provide fallback dimensions since image may not load due to CORS
                    if (window.location.protocol === 'file:' && (!this.image.naturalWidth || !this.image.naturalHeight)) {
                        console.log('üîß Standalone mode: Using fallback image dimensions (1600x1024)');
                        this.imageWidth = 1600;
                        this.imageHeight = 1024;
                    } else if (this.image.naturalWidth && this.image.naturalHeight) {
                        this.imageWidth = this.image.naturalWidth;
                        this.imageHeight = this.image.naturalHeight;
                    } else {
                        // Fallback size if image not loaded yet
                        this.imageWidth = 1600;
                        this.imageHeight = 1024;
                    }
                    
                    const aspectRatio = this.imageWidth / this.imageHeight;
                    
                    // Create a window sized to fit the image with some margin for the psychedelic background
                    const maxHeight = window.innerHeight - 120;
                    const maxWidth = window.innerWidth - 80;
                    
                    let finalWidth, finalHeight;
                    
                    if (maxWidth / aspectRatio <= maxHeight) {
                        finalWidth = maxWidth;
                        finalHeight = maxWidth / aspectRatio;
                    } else {
                        finalHeight = maxHeight;
                        finalWidth = maxHeight * aspectRatio;
                    }
                    
                    this.viewer.style.width = finalWidth + 'px';
                    this.viewer.style.height = finalHeight + 'px';
                    this.containerWidth = finalWidth;
                    this.containerHeight = finalHeight;
                    
                    // Update grid size to match image dimensions
                    this.updateGridSize();
                };
                
                this.image.onload = setupSize;
                // Also call immediately in case image is already loaded
                setupSize();
                
                // Mouse events
                this.viewer.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Wheel event for zooming
                this.viewer.addEventListener('wheel', this.handleWheel.bind(this));
                
                // Touch events for mobile
                this.viewer.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.viewer.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.viewer.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Prevent context menu
                this.viewer.addEventListener('contextmenu', e => e.preventDefault());
                

                
                // API key input
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.onclick = () => {
                        this.setApiKey();
                    };
                }
                
                if (this.apiKeyInput) {
                    this.apiKeyInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.setApiKey();
                        }
                    });
                }
                
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.addEventListener('click', () => this.setApiKey());
                }
                
                if (this.testApiBtn) {
                    this.testApiBtn.addEventListener('click', () => this.testApiCall());
                }
                


                if (this.autoGenToggleBtn) {
                    this.autoGenToggleBtn.addEventListener('click', () => this.toggleAutoGeneration());
                }

                if (this.apiCallsToggleBtn) {
                    this.apiCallsToggleBtn.addEventListener('click', () => this.toggleApiCalls());
                }

                if (this.testPanBtn) {
                    this.testPanBtn.addEventListener('click', () => this.testPan());
                }

                if (this.zoomOutMaxBtn) {
                    this.zoomOutMaxBtn.addEventListener('click', () => this.zoomOutMax());
                }
                
                if (this.imageOpacityBtn) {
                    this.imageOpacityBtn.addEventListener('click', () => this.toggleImageOpacity());
                }
                
                if (this.blockLayerBtn) {
                    this.blockLayerBtn.addEventListener('click', () => this.toggleBlockLayer());
                }
                
                // Debug preview close functionality removed (no close button)
                

                
                // Try to load API key from environment on startup
                this.initializeApiKey();
                
                // Set initial UI state for pre-configured API key
                this.updateInitialUIState();
                
                // Hide debug windows by default
                const debugInfo = document.getElementById('debugInfo');
                const consoleCapture = document.getElementById('consoleCapture');
                if (debugInfo && consoleCapture) {
                    debugInfo.style.display = 'none';
                    consoleCapture.style.display = 'none';
                }
                
                this.updateTransform();
                
                // Add resize handler to redraw grid
                window.addEventListener('resize', () => {
                    setTimeout(() => this.drawGrid(), 100);
                });
                
                // Add keyboard shortcut to toggle debug windows
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F12' || (e.ctrlKey && e.key === 'd')) {
                        e.preventDefault();
                        this.toggleDebug();
                    } else if (e.key === 'g' || e.key === 'G') {
                        e.preventDefault();
                        this.toggleGrid();
                    }
                });
            }
            
            updateInitialUIState() {
                // Update API key input UI
                if (this.apiKey && this.apiKeyInput) {
                    this.apiKeyInput.placeholder = 'API Key Set ‚úì';
                    this.apiKeyInput.value = '';
                }
                
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.textContent = 'Update';
                }
                
                // Live mode is always enabled
                
                console.log('üîë API key pre-configured and live mode enabled');
            }
            
            setApiKey() {
                const apiKey = this.apiKeyInput.value.trim();
                if (apiKey) {
                    this.apiKey = apiKey;
                    this.apiKeyInput.value = '';
                    this.apiKeyInput.placeholder = 'API Key Set ‚úì';
                    this.setApiKeyBtn.textContent = 'Update';
                    
                    // Live mode is always enabled
                    
                    console.log('API key set successfully');
                } else {
                    alert('Please enter a valid API key');
                }
            }
            
            async testApiCall() {
                if (!this.apiKey) {
                    alert('Please set an API key first');
                    return;
                }

                if (!this.apiCallsEnabled) {
                    console.log('üö´ API calls disabled - creating grey loading block only');
                    this.testApiBtn.textContent = 'Test API';
                    this.testApiBtn.disabled = false;
                    
                    // Clear existing blocks first to test new sizing
                    this.outfillBlocks.clear();
                    const existingBlocks = document.querySelectorAll('[id^="outfill-"]');
                    existingBlocks.forEach(block => block.remove());
                    
                    // Create grey loading block for testing scaling
                    const testBlockKey = '1,0';
                    this.outfillBlocks.set(testBlockKey, { status: 'generating', progress: 0, imageData: null });
                    this.updateOutfillBlock(testBlockKey, this.outfillBlocks.get(testBlockKey));
                    console.log('üéØ Grey loading block created for scaling test');
                    return;
                }
                
                console.log('üß™ Testing API call...');
                this.testApiBtn.textContent = 'Testing...';
                this.testApiBtn.disabled = true;
                
                try {
                    // Manually trigger an outfill for testing (works regardless of auto-generation setting)
                    const testBlockKey = '1,0'; // Block to the right of the image (outside image bounds)
                    this.outfillBlocks.set(testBlockKey, { status: 'generating', progress: 0, imageData: null });
                    this.updateOutfillBlock(testBlockKey, this.outfillBlocks.get(testBlockKey));
                    
                    // Use the EXACT same code path as auto-filled blocks
                    const result = await this.generateOutfill(testBlockKey);
                    console.log('‚úÖ API test successful!', result);
                    
                    // The debug preview is already shown by generateOutfill, just log success
                    console.log('üéØ Test API completed - check debug preview window for results');
                    
                } catch (error) {
                    console.error('‚ùå API test failed:', error);
                    
                    // Show error in debug preview window
                    this.showDebugError('API Test Failed', error.message);
                } finally {
                    this.testApiBtn.textContent = 'Test API';
                    this.testApiBtn.disabled = false;
                }
            }

            testPan() {
                console.log('üß™ Testing pan functionality...');
                
                // Pan the image to the right by 200px to expose left edge
                this.translateX += 200;
                this.updateTransform();
                this.checkVisibleBlocks();
                
                console.log('‚úÖ Pan test completed - image moved right by 200px');
            }

            zoomOutMax() {
                console.log('üîç Zooming out to maximum...');
                
                // Set scale to minimum (0.25x)
                this.scale = 0.25;
                this.updateTransform();
                this.checkVisibleBlocks();
                
                console.log('‚úÖ Zoomed out to maximum scale: 0.25x');
            }
            
            async generateOutfill(blockKey) {
                console.log('üöÄ Starting generateOutfill for block:', blockKey);
                
                if (!this.apiKey) {
                    throw new Error('No API key set');
                }
                
                try {
                    // Get the current image as a blob
                    const imageBlob = await this.getImageAsBlob();
                    console.log('üì∏ Image blob size:', imageBlob.size, 'bytes');
                    
                    // Generate mask for the block
                    const maskBlob = await this.generateMaskForBlock(blockKey);
                    console.log('üé≠ Mask blob size:', maskBlob.size, 'bytes');
                    
                    // Prepare form data
                    const formData = new FormData();
                    formData.append('image', imageBlob, 'image.jpg');
                    
                    // Always add mask - required by Stability AI outpaint API
                    formData.append('mask', maskBlob, 'mask.png');
                    console.log('üé≠ Adding mask for outpaint (required by API)');
                    
                    formData.append('prompt', this.config.prompt);
                    formData.append('output_format', this.config.output_format);
                    formData.append('creativity', this.config.creativity.toString());
                    
                    // Add outpaint directions based on block position
                    const { directionX, directionY, gridX, gridY } = this.getOutpaintDirections(blockKey);
                    const blockSizeX = Math.round(this.imageWidth / this.blockDivisions);
                    const blockSizeY = Math.round(this.imageHeight / this.blockDivisions);
                    
                    console.log(`üéØ Block ${blockKey} outpaint directions: directionX=${directionX}, directionY=${directionY} (${blockSizeX}x${blockSizeY}px)`);
                    
                    // Add direction-based outpaint parameters
                    if (directionX > 0) {
                        formData.append('right', blockSizeX.toString());
                    } else if (directionX < 0) {
                        formData.append('left', blockSizeX.toString());
                    }
                    
                    if (directionY > 0) {
                        formData.append('down', blockSizeY.toString());
                    } else if (directionY < 0) {
                        formData.append('up', blockSizeY.toString());
                    }
                    
                    if (this.config.seed) {
                        formData.append('seed', this.config.seed.toString());
                    }
                    
                    console.log('üì§ Sending API request to:', this.config.endpoint);
                    
                    // Log detailed FormData contents
                    console.log('üì§ Request FormData contents:');
                    for (let [key, value] of formData.entries()) {
                        if (value instanceof File || value instanceof Blob) {
                            console.log(`  ${key}: ${value.constructor.name} (${value.size} bytes, type: ${value.type})`);
                        } else {
                            console.log(`  ${key}: ${JSON.stringify(value)}`);
                        }
                    }
                    
                    // Build request summary with actual directions being sent
                    const requestSummary = {
                        prompt: this.config.prompt,
                        output_format: this.config.output_format,
                        creativity: this.config.creativity,
                        seed: this.config.seed,
                        imageSize: imageBlob.size,
                        maskSize: maskBlob.size
                    };
                    
                    // Add the actual outpaint directions being sent
                    if (directionX > 0) {
                        requestSummary['right'] = blockSizeX.toString();
                    } else if (directionX < 0) {
                        requestSummary['left'] = blockSizeX.toString();
                    }
                    
                    if (directionY > 0) {
                        requestSummary['down'] = blockSizeY.toString();
                    } else if (directionY < 0) {
                        requestSummary['up'] = blockSizeY.toString();
                    }
                    console.log('üì§ Request parameters summary:', JSON.stringify(requestSummary, null, 2));
                    
                    // Make API call
                    const requestHeaders = {
                        'Authorization': `Bearer ${this.apiKey.substring(0, 10)}...${this.apiKey.substring(this.apiKey.length - 4)}`,
                        'Accept': 'image/*'
                    };
                    console.log('üì§ Request headers:', JSON.stringify(requestHeaders, null, 2));
                    
                    // Log all FormData entries for debugging
                    console.log('üì§ FormData entries:');
                    const formDataEntries = {};
                    for (let [key, value] of formData.entries()) {
                        if (value instanceof File || value instanceof Blob) {
                            console.log(`  ${key}: ${value.constructor.name} (${value.size} bytes, type: ${value.type})`);
                            formDataEntries[key] = `${value.constructor.name} (${value.size} bytes, type: ${value.type})`;
                        } else {
                            console.log(`  ${key}: ${value}`);
                            formDataEntries[key] = value;
                        }
                    }
                    console.log('üì§ Complete FormData summary:', JSON.stringify(formDataEntries, null, 2));
                    
                    const response = await fetch(this.config.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Accept': 'image/*'
                        },
                        body: formData
                    });
                    
                    const responseHeaders = Object.fromEntries(response.headers.entries());
                    console.log('üì• API Response status:', response.status);
                    console.log('üì• API Response headers:', JSON.stringify(responseHeaders, null, 2));
                    console.log('üì• API Response content-type:', response.headers.get('content-type'));
                    console.log('üì• API Response content-length:', response.headers.get('content-length'));
                    
                    // Check response status and content type
                    const contentType = response.headers.get('content-type');
                    console.log('üì• Response status:', response.status, response.statusText);
                    console.log('üì• Response ok:', response.ok);
                    
                    if (!response.ok) {
                        // Handle error responses - read as text to get error details
                        try {
                            const errorText = await response.text();
                            console.error('üö® API Error Response (raw):', errorText);
                            
                            // Try to parse as JSON for better error details
                            let errorMessage = `API Error (${response.status}): `;
                            try {
                                const errorJson = JSON.parse(errorText);
                                console.error('üö® API Error Response (parsed):', JSON.stringify(errorJson, null, 2));
                                if (errorJson.errors && Array.isArray(errorJson.errors)) {
                                    errorMessage += errorJson.errors.join(', ');
                                } else if (errorJson.error) {
                                    errorMessage += errorJson.error;
                                } else {
                                    errorMessage += errorText;
                                }
                            } catch (parseError) {
                                console.error('üö® Could not parse error as JSON:', parseError);
                                errorMessage += errorText;
                            }
                            throw new Error(errorMessage);
                        } catch (textError) {
                            console.error('üö® Could not read error response:', textError);
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                    }
                    
                    // Check if successful response is JSON (unexpected for image generation)
                    if (contentType && contentType.includes('application/json')) {
                        const jsonResponse = await response.json();
                        console.log('üì• API JSON Response (unexpected success):', JSON.stringify(jsonResponse, null, 2));
                        throw new Error(`API returned JSON instead of image: ${JSON.stringify(jsonResponse)}`);
                    }
                    
                    // Get the generated image (successful image response)
                    const imageBlob2 = await response.blob();
                    console.log('‚úÖ API Response successful!');
                    const blobDetails = {
                        size: imageBlob2.size,
                        type: imageBlob2.type,
                        sizeKB: Math.round(imageBlob2.size / 1024),
                        sizeMB: Math.round(imageBlob2.size / 1024 / 1024 * 100) / 100
                    };
                    console.log('‚úÖ Generated image blob details:', JSON.stringify(blobDetails, null, 2));
                    
                    // Save debug blob to file and show preview if debug mode is enabled
                    this.saveDebugBlob(imageBlob2, blockKey, 'stability-ai-outpaint');
                    this.showDebugPreview(imageBlob2, blockKey, 'Stability AI Outpaint');
                    
                    // Convert to data URL for display
                    const imageUrl = URL.createObjectURL(imageBlob2);
                    console.log('‚úÖ Generated image URL:', imageUrl);
                    
                    // Get image dimensions and adjust block positioning
                    const img = new Image();
                    img.onload = () => {
                        const generatedDimensions = {
                            width: img.width,
                            height: img.height,
                            aspectRatio: Math.round(img.width / img.height * 100) / 100
                        };
                        console.log('üìè Generated image dimensions:', generatedDimensions);
                        
                        // Adjust block positioning based on actual returned image dimensions
                        const block = this.outfillBlocks.get(blockKey);
                        if (block) {
                            this.adjustBlockPositionForActualDimensions(blockKey, block, generatedDimensions);
                        }
                    };
                    img.src = imageUrl;
                    
                    // Update the outfill block with the generated image
                    const block = this.outfillBlocks.get(blockKey);
                    console.log('üîç Block lookup for', blockKey, ':', block ? 'found' : 'NOT FOUND');
                    if (block) {
                        console.log('üîç Block before update:', JSON.stringify(block, null, 2));
                        block.status = 'completed';
                        block.imageData = imageUrl;
                        console.log('üîç About to call updateOutfillBlock with:', blockKey, block.status, block.imageData ? 'imageData present' : 'NO imageData');
                        this.updateOutfillBlock(blockKey, block);
                        console.log('‚úÖ Block', blockKey, 'generation completed');
                        
                        // Check for newly adjacent blocks that can now be queued
                        this.checkForNewlyAdjacentBlocks(blockKey);
                    } else {
                        console.error('‚ùå Block not found in outfillBlocks map for key:', blockKey);
                        console.log('üîç Current outfillBlocks keys:', Array.from(this.outfillBlocks.keys()));
                    }
                    
                    return {
                        imageUrl,
                        blockKey,
                        size: imageBlob2.size
                    };
                    
                } catch (error) {
                    console.error('‚ùå generateOutfill error:', error);
                    throw error;
                }
            }
            
            async getImageAsBlob() {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = this.image;
                    
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create image blob'));
                        }
                    }, 'image/jpeg', 0.9);
                });
            }
            
            async initializeApiKey() {
                try {
                    // Try to get API key from environment variable
                    const response = await fetch('/api/config');
                    const config = await response.json();
                    
                    if (config.hasApiKey && config.apiKey && config.apiKey !== 'test-key-for-demo') {
                        this.apiKey = config.apiKey;
                        this.apiKeyInput.placeholder = 'API Key Set ‚úì';
                        this.setApiKeyBtn.textContent = 'Update';
                        console.log('API key loaded from environment variable');
                        // Live mode is always enabled
                    }
                } catch (error) {
                    console.error('Failed to fetch API config:', error);
                }
            }
            

            
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.content.style.transition = 'none';
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastX;
                const deltaY = e.clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                console.log('üñ±Ô∏è Mouse move:', { deltaX, deltaY, translateX: this.translateX, translateY: this.translateY });
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateTransform();
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.viewer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const mouseX = e.clientX - centerX;
                const mouseY = e.clientY - centerY;
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * delta));
                
                if (newScale !== this.scale) {
                    const scaleDiff = newScale / this.scale;
                    
                    this.translateX = mouseX - (mouseX - this.translateX) * scaleDiff;
                    this.translateY = mouseY - (mouseY - this.translateY) * scaleDiff;
                    
                    console.log('üîç Wheel zoom:', { newScale, translateX: this.translateX, translateY: this.translateY });
                    
                    this.scale = newScale;
                    this.updateTransform();
                }
            }
            
            handleTouchStart(e) {
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    this.content.style.transition = 'none';
                }
                e.preventDefault();
            }
            
            handleTouchMove(e) {
                if (!this.isDragging || e.touches.length !== 1) return;
                
                const deltaX = e.touches[0].clientX - this.lastX;
                const deltaY = e.touches[0].clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                this.lastX = e.touches[0].clientX;
                this.lastY = e.touches[0].clientY;
                
                this.updateTransform();
                e.preventDefault();
            }
            
            handleTouchEnd() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            getVisibleBlocks() {
                if (!this.containerWidth || !this.containerHeight || !this.imageWidth || !this.imageHeight) {
                    return new Set();
                }

                const visibleBlocks = new Set();
                
                // BLOCK SYSTEM: Each block is exactly the original image size
                const blockWidth = this.imageWidth;   // 1600px
                const blockHeight = this.imageHeight; // 1024px

                // Calculate viewport bounds in world coordinates
                // Original image is at world position (0,0) to (imageWidth, imageHeight)
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + this.containerWidth / this.scale;
                const viewportBottom = viewportTop + this.containerHeight / this.scale;

                // Calculate which blocks are visible
                const leftmostBlock = Math.floor(viewportLeft / blockWidth);
                const rightmostBlock = Math.ceil(viewportRight / blockWidth);
                const topmostBlock = Math.floor(viewportTop / blockHeight);
                const bottommostBlock = Math.ceil(viewportBottom / blockHeight);

                // Add all visible blocks (including original at 0,0)
                for (let x = leftmostBlock; x < rightmostBlock; x++) {
                    for (let y = topmostBlock; y < bottommostBlock; y++) {
                        visibleBlocks.add(`${x},${y}`);
                    }
                }

                return visibleBlocks;
            }
            
            updateGridSize() {
                this.drawGrid();
            }
            
            drawGrid() {
                // GRID ALIGNMENT: Grid lines should align with actual image boundaries
                // Need to account for how the image is positioned within the container
                
                const canvas = document.getElementById('gridCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Exit early if grid is not visible
                if (!this.gridVisible) return;
                
                // Block dimensions (each block = full image size)
                const blockWidth = this.imageWidth || 1600;   // 1600px
                const blockHeight = this.imageHeight || 1024; // 1024px
                
                // Calculate where the actual image is positioned within the container
                // The image uses object-fit: contain, so it's centered and scaled to fit
                const containerWidth = this.containerWidth;
                const containerHeight = this.containerHeight;
                const imageAspect = blockWidth / blockHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let actualImageWidth, actualImageHeight, imageOffsetX, imageOffsetY;
                
                if (imageAspect > containerAspect) {
                    // Image is wider - fits to container width
                    actualImageWidth = containerWidth;
                    actualImageHeight = containerWidth / imageAspect;
                    imageOffsetX = 0;
                    imageOffsetY = (containerHeight - actualImageHeight) / 2;
                } else {
                    // Image is taller - fits to container height
                    actualImageWidth = containerHeight * imageAspect;
                    actualImageHeight = containerHeight;
                    imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    imageOffsetY = 0;
                }
                
                console.log(`üîç IMAGE POSITIONING: container=${containerWidth}x${containerHeight}, actual=${actualImageWidth}x${actualImageHeight}, offset=(${imageOffsetX},${imageOffsetY})`);
                
                // Set grid line style
                ctx.strokeStyle = 'rgba(255, 255, 255, 1.0)';
                ctx.lineWidth = 1;
                
                // Draw complete infinite grid with image boundaries as reference
                // Image occupies one grid cell, bounded by grid lines
                
                // Calculate the center of the container (where image is positioned before transform)
                const containerCenterX = canvas.width / 2;
                const containerCenterY = canvas.height / 2;
                
                // Calculate where the top-left corner of the actual image appears
                // Image is centered, so top-left is at center minus half the scaled image size
                const scaledImageWidth = actualImageWidth * this.scale;
                const scaledImageHeight = actualImageHeight * this.scale;
                
                const imageTopLeftX = containerCenterX - (scaledImageWidth / 2) + this.translateX;
                const imageTopLeftY = containerCenterY - (scaledImageHeight / 2) + this.translateY;
                
                // Grid spacing equals scaled image dimensions
                const gridSpacingX = scaledImageWidth;
                const gridSpacingY = scaledImageHeight;
                
                // Draw vertical grid lines extending infinitely
                for (let i = -50; i <= 50; i++) {
                    const lineX = imageTopLeftX + (i * gridSpacingX);
                    
                    // Only draw lines that could be visible
                    if (lineX >= -canvas.width && lineX <= canvas.width * 2) {
                        ctx.beginPath();
                        ctx.moveTo(lineX, 0);
                        ctx.lineTo(lineX, canvas.height);
                        ctx.stroke();
                    }
                }
                
                // Draw horizontal grid lines extending infinitely
                for (let i = -50; i <= 50; i++) {
                    const lineY = imageTopLeftY + (i * gridSpacingY);
                    
                    // Only draw lines that could be visible
                    if (lineY >= -canvas.height && lineY <= canvas.height * 2) {
                        ctx.beginPath();
                        ctx.moveTo(0, lineY);
                        ctx.lineTo(canvas.width, lineY);
                        ctx.stroke();
                    }
                }
                
                console.log(`üîç INFINITE GRID: topLeft=(${imageTopLeftX},${imageTopLeftY}), spacing=(${gridSpacingX},${gridSpacingY}), scale=${this.scale}`);
            }
            
            // Helper method to update API configuration
            updateApiConfig(newConfig) {
                this.apiConfig = { ...this.apiConfig, ...newConfig };
                console.log('üîß API Configuration Updated:', this.apiConfig);
            }
            
            async simulateGeneration(blockKey) {
                if (this.isLiveMode) {
                    return this.generateWithAPI(blockKey);
                } else {
                    return this.generateDemo(blockKey);
                }
            }

            generateDemo(blockKey) {
                return new Promise((resolve) => {
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 0.05;
                        const block = this.outfillBlocks.get(blockKey);
                        if (block) {
                            block.progress = progress;
                            this.updateOutfillBlock(blockKey, block);
                        }
                        
                        if (progress >= 1) {
                            clearInterval(interval);
                            
                            // Generate demo image and show in debug preview
                            this.createDemoImage(blockKey).then((demoBlob) => {
                                // Show in debug preview window
                                this.showDebugPreview(demoBlob, blockKey, 'Demo Generation');
                                
                                // Update block with demo image
                                const imageUrl = URL.createObjectURL(demoBlob);
                                const block = this.outfillBlocks.get(blockKey);
                                if (block) {
                                    block.status = 'completed';
                                    block.imageUrl = imageUrl;
                                    this.updateOutfillBlock(blockKey, block);
                                }
                                
                                resolve();
                            });
                        }
                    }, 200);
                });
            }
            // Create demo image blob for testing
            async createDemoImage(blockKey) {
                return new Promise((resolve) => {
                    // Create canvas for demo image
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    
                    // Create psychedelic gradient pattern
                    const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
                    gradient.addColorStop(0, `hsl(${Math.random() * 360}, 80%, 60%)`);
                    gradient.addColorStop(0.3, `hsl(${Math.random() * 360}, 70%, 50%)`);
                    gradient.addColorStop(0.6, `hsl(${Math.random() * 360}, 90%, 40%)`);
                    gradient.addColorStop(1, `hsl(${Math.random() * 360}, 60%, 30%)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 512, 512);
                    
                    // Add some organic shapes
                    for (let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        ctx.fillStyle = `hsla(${Math.random() * 360}, 70%, 50%, 0.3)`;
                        const x = Math.random() * 512;
                        const y = Math.random() * 512;
                        const radius = Math.random() * 50 + 10;
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Add block key text
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Block ${blockKey}`, 256, 256);
                    ctx.fillText('DEMO', 256, 290);
                    
                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/jpeg', 0.8);
                });
            }





            async generateWithAPI(blockKey) {
                try {
                    // Update progress to show API call in progress
                    const block = this.outfillBlocks.get(blockKey);
                    if (block) {
                        block.progress = 0.1;
                        this.updateOutfillBlock(blockKey, block);
                    }

                    console.log(`üöÄ Starting API generation for block ${blockKey}`);
                    
                    // Call Stability AI API - this now handles multi-block responses internally
                    await this.callStabilityAPI(blockKey);
                    
                    console.log(`‚úÖ API generation completed for block ${blockKey} and adjacent blocks`);
                    
                } catch (error) {
                    console.error('API generation failed:', error);
                    
                    // Mark as failed
                    this.outfillBlocks.set(blockKey, { 
                        status: 'failed', 
                        progress: 0, 
                        error: error.message 
                    });
                    this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                    
                    // Show error to user
                    alert(`Generation failed: ${error.message}`);
                }
            }

            blobToDataUrl(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // Debug function to save blob to file
            saveDebugBlob(blob, blockKey, description = 'api-response') {

                
                try {
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const filename = `${description}_block-${blockKey}_${timestamp}.${blob.type.split('/')[1] || 'jpg'}`;
                    
                    // Create download link - COMMENTED OUT
                    // const url = URL.createObjectURL(blob);
                    // const a = document.createElement('a');
                    // a.href = url;
                    // a.download = filename;
                    // a.style.display = 'none';
                    
                    // // Trigger download
                    // document.body.appendChild(a);
                    // a.click();
                    // document.body.removeChild(a);
                    
                    // // Clean up URL
                    // setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    console.log('üêõ DEBUG: Saved blob to file:', filename, {
                        size: blob.size,
                        type: blob.type,
                        sizeKB: Math.round(blob.size / 1024)
                    });
                } catch (error) {
                    console.error('‚ùå Failed to save debug blob:', error);
                }
            }

            // Toggle debug windows and indicators
            toggleDebug() {
                const debugInfo = document.getElementById('debugInfo');
                const consoleCapture = document.getElementById('consoleCapture');

                if (debugInfo && consoleCapture) {
                    const isVisible = debugInfo.style.display !== 'none';
                    const newDisplay = isVisible ? 'none' : 'block';

                    debugInfo.style.display = newDisplay;
                    consoleCapture.style.display = newDisplay;

                    // Toggle zoom indicator only (queue indicator stays always visible)
                    if (this.zoomIndicator) {
                        this.zoomIndicator.style.display = newDisplay;
                    }

                    // Toggle debug preview window visibility (show/hide with debug mode)
                    if (this.debugPreview) {
                        if (newDisplay === 'block') {
                            // Show debug preview window when debug mode is enabled
                            this.debugPreview.classList.add('visible');
                            // Show placeholder or keep image hidden until content loads
                            if (!this.debugPreviewImage.src || this.debugPreviewImage.src === '') {
                                this.debugPreviewImage.style.display = 'none';
                            }
                        } else {
                            // Hide debug preview window when debug mode is disabled
                            this.debugPreview.classList.remove('visible');
                        }
                    }

                    console.log(`üîß Debug windows ${isVisible ? 'hidden' : 'shown'} (F12 or Ctrl+D to toggle)`);
                }
            }

            // Toggle grid visibility
            toggleGrid() {
                this.gridVisible = !this.gridVisible;
                this.drawGrid(); // Redraw grid with new visibility state
                console.log(`üîß Grid ${this.gridVisible ? 'shown' : 'hidden'} (G key to toggle)`);
            }

            // Toggle auto-generation mode
            toggleAutoGeneration() {
                this.autoGenerateBlocks = !this.autoGenerateBlocks;

                if (this.autoGenToggleBtn) {
                    this.autoGenToggleBtn.textContent = this.autoGenerateBlocks ? 'Auto-Gen: ON' : 'Auto-Gen: OFF';
                    this.autoGenToggleBtn.style.background = this.autoGenerateBlocks ? '#4CAF50' : '#757575';
                }

                console.log('üîÑ Auto-generation:', this.autoGenerateBlocks ? 'ENABLED' : 'DISABLED');
                console.log('üîÑ Blocks will', this.autoGenerateBlocks ? 'be automatically added when visible' : 'NOT be automatically added (manual only)');
            }

            // Toggle API calls
            toggleApiCalls() {
                this.apiCallsEnabled = !this.apiCallsEnabled;

                if (this.apiCallsToggleBtn) {
                    this.apiCallsToggleBtn.textContent = this.apiCallsEnabled ? 'API: ON' : 'API: OFF';
                    this.apiCallsToggleBtn.style.background = this.apiCallsEnabled ? '#4CAF50' : '#757575';
                }

                console.log('üîÑ API calls:', this.apiCallsEnabled ? 'ENABLED' : 'DISABLED');
                console.log('üîÑ Blocks will', this.apiCallsEnabled ? 'make real API calls' : 'show grey loading blocks only');
            }
            
            // Toggle image opacity
            toggleImageOpacity() {
                this.imageTranslucent = !this.imageTranslucent;
                
                if (this.imageOpacityBtn) {
                    this.imageOpacityBtn.textContent = this.imageTranslucent ? 'Image: 50%' : 'Image: 100%';
                    this.imageOpacityBtn.style.background = this.imageTranslucent ? '#4CAF50' : '#757575';
                }
                
                // Apply opacity to main image
                if (this.image) {
                    this.image.style.opacity = this.imageTranslucent ? '0.5' : '1.0';
                }
                
                console.log('üîÑ Image opacity:', this.imageTranslucent ? '50%' : '100%');
            }
            
            // Toggle block layer (under/over image)
            toggleBlockLayer() {
                this.blocksOverImage = !this.blocksOverImage;
                
                if (this.blockLayerBtn) {
                    this.blockLayerBtn.textContent = this.blocksOverImage ? 'Blocks: Over' : 'Blocks: Under';
                    this.blockLayerBtn.style.background = this.blocksOverImage ? '#4CAF50' : '#757575';
                }
                
                // Update z-index of all existing outfill blocks
                const existingBlocks = document.querySelectorAll('[id^="outfill-"]');
                existingBlocks.forEach(block => {
                    block.style.zIndex = this.blocksOverImage ? '4' : '2';
                });
                
                console.log('üîÑ Block layer:', this.blocksOverImage ? 'OVER image' : 'UNDER image');
            }
            


            // Show debug preview with blob
            showDebugPreview(blob, blockKey, description = 'api-response') {
                if (!this.debugPreview) return;
                
                try {
                    // Create object URL for the blob
                    const imageUrl = URL.createObjectURL(blob);
                    
                    // Load image to get dimensions and resize window
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        // Scale down large images to reasonable preview size
                        const maxWidth = 400;
                        const maxHeight = 300;
                        let width = tempImg.width;
                        let height = tempImg.height;
                        
                        console.log(`üêõ DEBUG PREVIEW: Original image dimensions: ${width}x${height}, aspect ratio: ${(width/height).toFixed(3)}`);
                        
                        // Scale down if too large
                        if (width > maxWidth || height > maxHeight) {
                            const scaleX = maxWidth / width;
                            const scaleY = maxHeight / height;
                            const scale = Math.min(scaleX, scaleY);
                            width = Math.round(width * scale);
                            height = Math.round(height * scale);
                        }
                        
                        console.log(`üêõ DEBUG PREVIEW: Scaled dimensions: ${width}x${height}, aspect ratio: ${(width/height).toFixed(3)}`);
                        
                        // Resize debug preview window to scaled dimensions
                        this.debugPreview.style.width = width + 'px';
                        this.debugPreview.style.height = height + 'px';
                        
                        // Ensure left and bottom positioning
                        this.debugPreview.style.left = '0px';
                        this.debugPreview.style.bottom = '0px';
                        
                        // Update preview content - just show the image
                        this.debugPreviewImage.src = imageUrl;
                        this.debugPreviewImage.style.display = 'block';
                        
                        // Show the preview window
                        this.debugPreview.classList.add('visible');
                    };
                    tempImg.src = imageUrl;
                    
                    // Clean up the URL after a delay
                    setTimeout(() => {
                        URL.revokeObjectURL(imageUrl);
                    }, 30000); // Keep for 30 seconds
                    
                    console.log('üêõ DEBUG: Preview window updated with blob:', {
                        size: blob.size,
                        type: blob.type,
                        blockKey: blockKey,
                        description: description
                    });
                } catch (error) {
                    console.error('‚ùå Failed to show debug preview:', error);
                }
            }

            // Hide debug preview
            hideDebugPreview() {
                if (this.debugPreview) {
                    this.debugPreview.classList.remove('visible');
                    
                    // Clear the image source to free memory
                    if (this.debugPreviewImage) {
                        this.debugPreviewImage.src = '';
                    }
                }
            }
            
            showDebugError(title, errorMessage) {
                if (!this.debugPreview) return;
                
                // For simplified debug preview, just hide the image on error
                this.debugPreview.classList.add('visible');
                this.debugPreviewImage.style.display = 'none';
                console.error(`‚ùå ${title}: ${errorMessage}`);
            }
            
            updateOutfillBlock(blockKey, block) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // BLOCK SYSTEM: Each block is exactly the original image size
                const blockWidth = this.imageWidth;   // 1600px
                const blockHeight = this.imageHeight; // 1024px
                
                // Calculate where the original image is positioned within the container
                // The image uses object-fit: contain, so it's centered and scaled to fit
                const containerWidth = this.containerWidth;
                const containerHeight = this.containerHeight;
                const imageAspect = blockWidth / blockHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let actualImageWidth, actualImageHeight, imageOffsetX, imageOffsetY;
                
                if (imageAspect > containerAspect) {
                    // Image is wider - fits to container width
                    actualImageWidth = containerWidth;
                    actualImageHeight = containerWidth / imageAspect;
                    imageOffsetX = 0;
                    imageOffsetY = (containerHeight - actualImageHeight) / 2;
                } else {
                    // Image is taller - fits to container height
                    actualImageWidth = containerHeight * imageAspect;
                    actualImageHeight = containerHeight;
                    imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    imageOffsetY = 0;
                }
                
                // Calculate block position relative to the original image position
                // IMPORTANT: Blocks must be positioned relative to the UNTRANSFORMED image
                // because they are children of this.content which gets the CSS transform applied
                const blockLeft = imageOffsetX + (gridX * actualImageWidth);
                const blockTop = imageOffsetY + (gridY * actualImageHeight);
                
                let blockElement = document.getElementById(`outfill-${blockKey}`);
                if (!blockElement) {
                    blockElement = document.createElement('div');
                    blockElement.id = `outfill-${blockKey}`;
                    blockElement.style.position = 'absolute';
                    blockElement.style.zIndex = this.blocksOverImage ? '4' : '2';
                    this.content.appendChild(blockElement);
                }
                
                // Position block to align with grid (relative to untransformed coordinates)
                // The CSS transform on this.content will handle scaling and translation
                blockElement.style.left = blockLeft + 'px';
                blockElement.style.top = blockTop + 'px';
                blockElement.style.width = actualImageWidth + 'px';
                blockElement.style.height = actualImageHeight + 'px';
                
                console.log(`üîß Block ${blockKey} positioning: left=${blockLeft}px, top=${blockTop}px, width=${actualImageWidth}px, height=${actualImageHeight}px`);
                
                if (block.status === 'ready' || block.status === 'completed') {
                    console.log('üñºÔ∏è Setting block image:', blockKey, 'imageData:', block.imageData.substring(0, 50) + '...');
                    blockElement.style.backgroundImage = `url(${block.imageData})`;
                    blockElement.style.backgroundRepeat = 'no-repeat';
                    blockElement.style.backgroundColor = 'transparent';
                    blockElement.innerHTML = '';
                    
                    // SEAMLESS FIX: The extracted block image is already the correct size (blockSizeX x blockSizeY)
                    // We need to scale it to match the current container-fitted dimensions
                    // This maintains the aspect ratio and ensures seamless alignment
                    blockElement.style.backgroundSize = `${actualImageWidth}px ${actualImageHeight}px`;
                    blockElement.style.backgroundPosition = '0px 0px';
                    
                    console.log('üñºÔ∏è Block element updated with proper scaling:', blockElement.id, `extracted->display: ${this.imageWidth}x${this.imageHeight}->${actualImageWidth}x${actualImageHeight}`);
                } else if (block.status === 'generating') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                    const progressPercent = Math.round(block.progress * 100);
                    const circumference = 2 * Math.PI * 20; // radius = 20
                    const strokeDashoffset = circumference - (block.progress * circumference);
                    
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 50px;
                            height: 50px;
                        ">
                            <svg width="50" height="50" style="transform: rotate(-90deg);">
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(255, 255, 255, 0.2)" 
                                    stroke-width="3"/>
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(0, 255, 255, 0.8)" 
                                    stroke-width="3"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${strokeDashoffset}"
                                    stroke-linecap="round"
                                    style="transition: stroke-dashoffset 0.2s ease;"/>
                            </svg>
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                color: rgba(255, 255, 255, 0.9);
                                font-size: 10px;
                                font-weight: bold;
                                text-align: center;
                            ">${progressPercent}%</div>
                        </div>
                    `;
                } else if (block.status === 'queued') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.6);
                            font-size: 12px;
                            text-align: center;
                        ">‚è≥</div>
                    `;
                } else if (block.status === 'failed') {
                    blockElement.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.9);
                            font-size: 12px;
                            text-align: center;
                        ">‚ùå</div>
                    `;
                }
            }
            
            isBlockAdjacentToContent(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // Check if block is adjacent to the original image at (0,0) or any completed blocks
                const adjacentPositions = [
                    [gridX - 1, gridY],     // Left
                    [gridX + 1, gridY],     // Right
                    [gridX, gridY - 1],     // Top
                    [gridX, gridY + 1],     // Bottom
                    [gridX - 1, gridY - 1], // Top-left
                    [gridX + 1, gridY - 1], // Top-right
                    [gridX - 1, gridY + 1], // Bottom-left
                    [gridX + 1, gridY + 1]  // Bottom-right
                ];
                
                for (const [adjX, adjY] of adjacentPositions) {
                    // Check if adjacent to original image at (0,0)
                    if (adjX === 0 && adjY === 0) {
                        return true;
                    }
                    
                    // Check if adjacent to any completed outfill block
                    const adjBlockKey = `${adjX},${adjY}`;
                    const adjBlock = this.outfillBlocks.get(adjBlockKey);
                    if (adjBlock && (adjBlock.status === 'ready' || adjBlock.status === 'completed')) {
                        return true;
                    }
                }
                
                return false;
            }
            
            checkForNewlyAdjacentBlocks(completedBlockKey) {
                const [completedX, completedY] = completedBlockKey.split(',').map(Number);
                
                // Check all positions adjacent to the completed block
                const adjacentPositions = [
                    [completedX - 1, completedY],     // Left
                    [completedX + 1, completedY],     // Right
                    [completedX, completedY - 1],     // Top
                    [completedX, completedY + 1],     // Bottom
                    [completedX - 1, completedY - 1], // Top-left
                    [completedX + 1, completedY - 1], // Top-right
                    [completedX - 1, completedY + 1], // Bottom-left
                    [completedX + 1, completedY + 1]  // Bottom-right
                ];
                
                const newlyAdjacentBlocks = [];
                
                for (const [adjX, adjY] of adjacentPositions) {
                    const adjBlockKey = `${adjX},${adjY}`;
                    
                    // Skip if this position is part of the original image
                    if (adjX >= 0 && adjX < this.blockDivisions && adjY >= 0 && adjY < this.blockDivisions) {
                        continue;
                    }
                    
                    // Skip if this block already exists in our system
                    if (this.outfillBlocks.has(adjBlockKey)) {
                        continue;
                    }
                    
                    // Check if this position is currently visible
                    const currentVisibleBlocks = this.getVisibleBlocks();
                    if (!currentVisibleBlocks.has(adjBlockKey)) {
                        continue;
                    }
                    
                    // This block is now adjacent to completed content and visible
                    newlyAdjacentBlocks.push(adjBlockKey);
                    console.log(`üÜï Found newly adjacent block: ${adjBlockKey} (adjacent to completed ${completedBlockKey})`);
                }
                
                // Add newly adjacent blocks to the system
                if (newlyAdjacentBlocks.length > 0 && this.autoGenerateBlocks) {
                    console.log('üöÄ Adding newly adjacent blocks to queue:', newlyAdjacentBlocks);
                    
                    for (const blockKey of newlyAdjacentBlocks) {
                        this.outfillBlocks.set(blockKey, { status: 'queued', progress: 0, imageData: null });
                        this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                        this.generationQueue.push(blockKey);
                    }
                    
                    this.processGenerationQueue();
                }
            }

            isBlockAdjacentToOriginalImage(gridX, gridY) {
                // Original image occupies blocks from (0,0) to (blockDivisions-1, blockDivisions-1)
                const originalMinX = 0;
                const originalMaxX = this.blockDivisions - 1;
                const originalMinY = 0;
                const originalMaxY = this.blockDivisions - 1;
                
                // Check if block is directly adjacent to the original image bounds
                const isLeftAdjacent = gridX === originalMinX - 1 && gridY >= originalMinY && gridY <= originalMaxY;
                const isRightAdjacent = gridX === originalMaxX + 1 && gridY >= originalMinY && gridY <= originalMaxY;
                const isTopAdjacent = gridY === originalMinY - 1 && gridX >= originalMinX && gridX <= originalMaxX;
                const isBottomAdjacent = gridY === originalMaxY + 1 && gridX >= originalMinX && gridX <= originalMaxX;
                
                // Check corner adjacency
                const isTopLeftCorner = gridX === originalMinX - 1 && gridY === originalMinY - 1;
                const isTopRightCorner = gridX === originalMaxX + 1 && gridY === originalMinY - 1;
                const isBottomLeftCorner = gridX === originalMinX - 1 && gridY === originalMaxY + 1;
                const isBottomRightCorner = gridX === originalMaxX + 1 && gridY === originalMaxY + 1;
                
                return isLeftAdjacent || isRightAdjacent || isTopAdjacent || isBottomAdjacent ||
                       isTopLeftCorner || isTopRightCorner || isBottomLeftCorner || isBottomRightCorner;
            }

            checkVisibleBlocks() {
                const currentVisibleBlocks = this.getVisibleBlocks();
                
                // Update debug info
                this.debugInfo.innerHTML = `
                    <div>Image: ${this.imageWidth}x${this.imageHeight}</div>
                    <div>Container: ${this.containerWidth}x${this.containerHeight}</div>
                    <div>Transform: ${this.translateX.toFixed(1)}, ${this.translateY.toFixed(1)}</div>
                    <div>Scale: ${this.scale.toFixed(2)}</div>
                    <div>Visible Blocks: ${currentVisibleBlocks.size}</div>
                    <div>Queue: ${this.generationQueue.length}</div>
                    <div>Active: ${this.activeGenerations}</div>
                `;
                
                // Find new blocks that weren't visible before (only if auto-generation is enabled)
                const newBlocks = [];
                if (this.autoGenerateBlocks) {
                    currentVisibleBlocks.forEach(blockKey => {
                        // Skip the original image block (0,0)
                        if (blockKey === '0,0') return;
                        
                        if (!this.lastVisibleBlocks.has(blockKey) && !this.outfillBlocks.has(blockKey)) {
                            // Only add blocks that are adjacent to existing content
                            if (this.isBlockAdjacentToContent(blockKey)) {
                                newBlocks.push(blockKey);
                                this.outfillBlocks.set(blockKey, { status: 'queued', progress: 0, imageData: null });
                                this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                                console.log('üéØ New adjacent outfill block detected:', blockKey);
                            } else {
                                console.log('üö´ Skipping isolated block (not adjacent to content):', blockKey);
                            }
                        }
                    });
                    
                    // Add new blocks to generation queue
                    if (newBlocks.length > 0) {
                        console.log('üöÄ Adding adjacent blocks to queue:', newBlocks);
                        this.generationQueue.push(...newBlocks);
                        this.processGenerationQueue();
                    } else if (this.generationQueue.length > 0) {
                        // Resort existing queue when visibility changes
                        this.updateGenerationQueue();
                    }
                } else {
                    console.log('üîÑ Auto-generation disabled - not adding visible blocks automatically');
                }
                
                this.lastVisibleBlocks = currentVisibleBlocks;
            }
            
            calculateBlockPriority(blockKey) {
                const [x, y] = blockKey.split(',').map(Number);
                const blockSizeX = this.imageWidth / this.blockDivisions;
                const blockSizeY = this.imageHeight / this.blockDivisions;
                
                // Calculate block bounds in image coordinates
                const blockLeft = x * blockSizeX;
                const blockTop = y * blockSizeY;
                const blockRight = blockLeft + blockSizeX;
                const blockBottom = blockTop + blockSizeY;
                
                // Get current viewport bounds in image coordinates
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + (this.containerWidth / this.scale);
                const viewportBottom = viewportTop + (this.containerHeight / this.scale);
                
                // Calculate intersection
                const intersectLeft = Math.max(blockLeft, viewportLeft);
                const intersectTop = Math.max(blockTop, viewportTop);
                const intersectRight = Math.min(blockRight, viewportRight);
                const intersectBottom = Math.min(blockBottom, viewportBottom);
                
                // Calculate visibility percentage
                let visibilityPercentage = 0;
                if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
                    const intersectArea = (intersectRight - intersectLeft) * (intersectBottom - intersectTop);
                    const blockArea = blockSizeX * blockSizeY;
                    visibilityPercentage = intersectArea / blockArea;
                }
                
                // Calculate distance from original image center (prioritize blocks closer to original content)
                const originalCenterX = this.imageWidth / 2;
                const originalCenterY = this.imageHeight / 2;
                const blockCenterX = blockLeft + blockSizeX / 2;
                const blockCenterY = blockTop + blockSizeY / 2;
                const distanceFromOriginal = Math.sqrt(
                    Math.pow(blockCenterX - originalCenterX, 2) + 
                    Math.pow(blockCenterY - originalCenterY, 2)
                );
                
                // Calculate distance from viewport center
                const viewportCenterX = viewportLeft + (this.containerWidth / this.scale) / 2;
                const viewportCenterY = viewportTop + (this.containerHeight / this.scale) / 2;
                const distanceFromViewport = Math.sqrt(
                    Math.pow(blockCenterX - viewportCenterX, 2) + 
                    Math.pow(blockCenterY - viewportCenterY, 2)
                );
                
                // Normalize distances
                const maxDistance = Math.sqrt(
                    Math.pow(this.imageWidth * 2, 2) + Math.pow(this.imageHeight * 2, 2)
                );
                const normalizedDistanceFromOriginal = 1 - (distanceFromOriginal / maxDistance);
                const normalizedDistanceFromViewport = 1 - (distanceFromViewport / maxDistance);
                
                // Calculate priority score
                let priority = visibilityPercentage * 100; // Base score from visibility (0-100)
                priority += normalizedDistanceFromOriginal * 50; // Proximity to original content (0-50)
                priority += normalizedDistanceFromViewport * 20; // Proximity to viewport (0-20)
                
                // Bonus for fully visible blocks
                if (visibilityPercentage >= 0.99) {
                    priority += 30;
                }
                
                // Extra bonus for blocks directly adjacent to original image
                if (this.isBlockAdjacentToOriginalImage(x, y)) {
                    priority += 100; // High priority for first-ring outpaint
                }
                
                return priority;
            }

            updateGenerationQueue() {
                // Calculate priorities for all queued blocks
                const queuedBlocks = this.generationQueue.map(blockKey => ({
                    blockKey,
                    priority: this.calculateBlockPriority(blockKey)
                }));
                
                // Sort by priority (highest first)
                queuedBlocks.sort((a, b) => b.priority - a.priority);
                
                // Update the queue with sorted block keys
                this.generationQueue = queuedBlocks.map(item => item.blockKey);
                
                // Update queue indicator
                this.updateQueueIndicator();
            }

            // üß© 3-BLOCK TRICK: Strategic Multi-Block Generation Functions
            
            findStrategicMultiBlockOpportunity() {
                if (this.generationQueue.length < 2) return null; // Need at least 2 blocks for efficiency
                
                // Look for diagonal blocks that can benefit from 3-block trick
                for (let i = 0; i < this.generationQueue.length; i++) {
                    const blockKey = this.generationQueue[i];
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    
                    // Check if this is a diagonal block (both X and Y non-zero)
                    if (gridX !== 0 && gridY !== 0) {
                        // Check if we can generate useful adjacent blocks
                        const strategicCall = this.calculateStrategicCall(blockKey);
                        if (strategicCall && this.isStrategicCallWorthwhile(strategicCall)) {
                            return strategicCall;
                        }
                    }
                }
                
                return null; // No strategic opportunity found
            }
            
            calculateStrategicCall(targetBlockKey) {
                const [targetX, targetY] = targetBlockKey.split(',').map(Number);
                
                // For diagonal block (1,1), we want to make a call that generates:
                // - The target block (1,1)
                // - Useful adjacent blocks like (1,0) and (0,1)
                
                // Strategy: Call from (0,0) with directions that include the target
                const strategicOrigin = '0,0'; // Always use original image as reference
                const directionX = targetX > 0 ? 1 : -1;
                const directionY = targetY > 0 ? 1 : -1;
                
                // Calculate which blocks this strategic call would generate
                const generatedBlocks = [
                    `${directionX > 0 ? 1 : -1},0`, // Horizontal adjacent
                    `0,${directionY > 0 ? 1 : -1}`, // Vertical adjacent  
                    `${directionX > 0 ? 1 : -1},${directionY > 0 ? 1 : -1}` // Diagonal target
                ];
                
                return {
                    originBlock: strategicOrigin,
                    directionX: directionX,
                    directionY: directionY,
                    targetBlock: targetBlockKey,
                    generatedBlocks: generatedBlocks
                };
            }
            
            isStrategicCallWorthwhile(strategicCall) {
                // Check how many of the generated blocks are actually needed
                let neededBlocks = 0;
                let queuedBlocks = [];
                
                strategicCall.generatedBlocks.forEach(blockKey => {
                    if (this.generationQueue.includes(blockKey) || 
                        (!this.outfillBlocks.has(blockKey) && this.isBlockAdjacentToContent(blockKey))) {
                        neededBlocks++;
                        if (this.generationQueue.includes(blockKey)) {
                            queuedBlocks.push(blockKey);
                        }
                    }
                });
                
                // Strategic call is worthwhile if we need at least 2 of the 3 blocks
                const isWorthwhile = neededBlocks >= 2;
                
                if (isWorthwhile) {
                    console.log(`üéØ Strategic call worthwhile: ${neededBlocks}/3 blocks needed`, {
                        target: strategicCall.targetBlock,
                        generated: strategicCall.generatedBlocks,
                        queued: queuedBlocks
                    });
                }
                
                return isWorthwhile;
            }
            
            async executeStrategicMultiBlockCall(strategicCall) {
                this.activeGenerations++;
                
                // Mark all generated blocks as generating
                strategicCall.generatedBlocks.forEach(blockKey => {
                    // Remove from queue if present
                    const queueIndex = this.generationQueue.indexOf(blockKey);
                    if (queueIndex !== -1) {
                        this.generationQueue.splice(queueIndex, 1);
                    }
                    
                    // Create or update block status
                    if (!this.outfillBlocks.has(blockKey)) {
                        this.outfillBlocks.set(blockKey, { status: 'generating', progress: 0, imageData: null });
                        this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                    } else {
                        const block = this.outfillBlocks.get(blockKey);
                        block.status = 'generating';
                        this.updateOutfillBlock(blockKey, block);
                    }
                });
                
                console.log(`üß© Executing strategic multi-block call for ${strategicCall.generatedBlocks.length} blocks:`, strategicCall.generatedBlocks);
                
                try {
                    // Use the strategic origin and directions for the API call
                    if (this.isLiveMode && this.apiKey) {
                        const result = await this.generateStrategicOutfill(strategicCall);
                        console.log('‚úÖ Strategic multi-block generation completed:', result);
                    } else {
                        // Simulate generation for all blocks
                        for (const blockKey of strategicCall.generatedBlocks) {
                            await this.simulateGeneration(blockKey);
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Strategic multi-block generation failed:', error);
                    // Mark all blocks as failed
                    strategicCall.generatedBlocks.forEach(blockKey => {
                        const block = this.outfillBlocks.get(blockKey);
                        if (block) {
                            block.status = 'failed';
                            this.updateOutfillBlock(blockKey, block);
                        }
                    });
                } finally {
                    this.activeGenerations--;
                    this.processGenerationQueue();
                }
            }
            
            async generateStrategicOutfill(strategicCall) {
                console.log('üöÄ Starting strategic generateOutfill:', strategicCall);
                
                if (!this.apiKey) {
                    throw new Error('No API key set');
                }
                
                try {
                    // Get the current image as a blob
                    const imageBlob = await this.getImageAsBlob();
                    console.log('üì∏ Strategic image blob size:', imageBlob.size, 'bytes');
                    
                    // Generate mask for strategic call (2x2 canvas with target areas)
                    const maskBlob = await this.generateStrategicMask(strategicCall);
                    console.log('üé≠ Strategic mask size:', maskBlob.size, 'bytes');
                    
                    // Make API call with strategic directions
                    const response = await this.callStabilityAPIStrategic(imageBlob, maskBlob, strategicCall);
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    // Get the response blob
                    const responseBlob = await response.blob();
                    
                    // Process multi-block response using existing system
                    return await this.processStrategicMultiBlockResponse(responseBlob, strategicCall);
                    
                } catch (error) {
                    console.error('Strategic outfill error:', error);
                    throw error;
                }
            }
            
            async generateStrategicMask(strategicCall) {
                // Create a 2x2 canvas mask for strategic multi-block generation
                const canvas = document.createElement('canvas');
                canvas.width = this.imageWidth * 2;
                canvas.height = this.imageHeight * 2;
                const ctx = canvas.getContext('2d');
                
                // Fill with black (preserve existing content)
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Mark the original image area as black (preserve)
                ctx.fillStyle = 'black';
                ctx.fillRect(
                    this.imageWidth / 2,
                    this.imageHeight / 2,
                    this.imageWidth,
                    this.imageHeight
                );
                
                // Mark all target extension areas as white (outpaint)
                ctx.fillStyle = 'white';
                
                strategicCall.generatedBlocks.forEach(blockKey => {
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    const targetX = this.imageWidth / 2 + (gridX * this.imageWidth);
                    const targetY = this.imageHeight / 2 + (gridY * this.imageHeight);
                    
                    ctx.fillRect(targetX, targetY, this.imageWidth, this.imageHeight);
                    console.log(`üé≠ Strategic mask: marked block ${blockKey} at (${targetX}, ${targetY})`);
                });
                
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
            }
            
            async callStabilityAPIStrategic(imageBlob, maskBlob, strategicCall) {
                const formData = new FormData();
                formData.append('image', imageBlob, 'image.jpg');
                formData.append('mask', maskBlob, 'mask.png');
                formData.append('prompt', this.config.prompt);
                formData.append('output_format', this.config.output_format);
                formData.append('creativity', this.config.creativity.toString());
                
                // Add strategic direction parameters
                const blockSizeX = this.imageWidth;
                const blockSizeY = this.imageHeight;
                
                console.log(`üéØ Strategic API call directions: directionX=${strategicCall.directionX}, directionY=${strategicCall.directionY}`);
                
                // Add direction-based outpaint parameters
                if (strategicCall.directionX > 0) {
                    formData.append('right', blockSizeX.toString());
                } else if (strategicCall.directionX < 0) {
                    formData.append('left', blockSizeX.toString());
                }
                
                if (strategicCall.directionY > 0) {
                    formData.append('down', blockSizeY.toString());
                } else if (strategicCall.directionY < 0) {
                    formData.append('up', blockSizeY.toString());
                }
                
                console.log('üì§ Strategic API request to:', this.config.endpoint);
                
                return fetch(this.config.endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Accept': 'image/*'
                    },
                    body: formData
                });
            }
            
            async processStrategicMultiBlockResponse(responseBlob, strategicCall) {
                try {
                    console.log(`üîÑ Processing strategic multi-block response for ${strategicCall.generatedBlocks.length} blocks`);
                    
                    // Show downloaded image in debug preview
                    this.showDebugPreview(responseBlob, strategicCall.generatedBlocks.join(','), 'Strategic API Response');
                    
                    // Create image from response blob
                    const responseImage = new Image();
                    const imageUrl = URL.createObjectURL(responseBlob);
                    
                    return new Promise((resolve, reject) => {
                        responseImage.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                canvas.width = responseImage.width;
                                canvas.height = responseImage.height;
                                ctx.drawImage(responseImage, 0, 0);
                                
                                // SEAMLESS LAYER APPROACH: Position entire image as one layer
                                this.positionEntireImageAsLayer(imageUrl, strategicCall);
                                
                                // Clean up
                                URL.revokeObjectURL(imageUrl);
                                
                                resolve({
                                    blocksGenerated: strategicCall.generatedBlocks,
                                    size: responseBlob.size
                                });
                                
                            } catch (error) {
                                console.error('Error processing strategic multi-block response:', error);
                                reject(error);
                            }
                        };
                        
                        responseImage.onerror = () => {
                            reject(new Error('Failed to load strategic response image'));
                        };
                        
                        responseImage.src = imageUrl;
                    });
                    
                } catch (error) {
                    console.error('Error in processStrategicMultiBlockResponse:', error);
                    throw error;
                }
            }
            
            positionEntireImageAsLayer(imageUrl, strategicCall) {
                // Create a single layer element for the entire API response
                const layerElement = document.createElement('div');
                layerElement.id = `layer-${Date.now()}`;
                layerElement.style.position = 'absolute';
                layerElement.style.zIndex = '3'; // Above original image (z-index 1) but below UI
                layerElement.style.backgroundImage = `url(${imageUrl})`;
                layerElement.style.backgroundRepeat = 'no-repeat';
                layerElement.style.pointerEvents = 'none'; // Allow interaction with underlying content
                
                // Calculate layer position based on API call direction
                const { directionX, directionY } = strategicCall;
                
                // Position the layer so it aligns with the original image
                // For a right call: left half covers original, right half extends
                // For a down call: top half covers original, bottom half extends
                let layerLeft = 0;
                let layerTop = 0;
                
                if (directionX > 0) {
                    // Right direction: position so left half covers original
                    layerLeft = 0; // Align with original image left edge
                } else if (directionX < 0) {
                    // Left direction: position so right half covers original  
                    layerLeft = -this.imageWidth; // Shift left by one image width
                }
                
                if (directionY > 0) {
                    // Down direction: position so top half covers original
                    layerTop = 0; // Align with original image top edge
                } else if (directionY < 0) {
                    // Up direction: position so bottom half covers original
                    layerTop = -this.imageHeight; // Shift up by one image height
                }
                
                // Set layer dimensions and position
                layerElement.style.width = `${this.imageWidth * 2}px`; // 2x2 response = 2x width
                layerElement.style.height = `${this.imageHeight * 2}px`; // 2x2 response = 2x height
                layerElement.style.left = `${layerLeft}px`;
                layerElement.style.top = `${layerTop}px`;
                layerElement.style.backgroundSize = `${this.imageWidth * 2}px ${this.imageHeight * 2}px`;
                layerElement.style.backgroundPosition = '0px 0px';
                
                // Add to content container (will inherit transforms)
                this.content.appendChild(layerElement);
                
                console.log(`üé® Positioned entire image layer: direction(${directionX},${directionY}), position(${layerLeft},${layerTop}), size(${this.imageWidth * 2}x${this.imageHeight * 2})`);
                
                // Mark the blocks as completed in our tracking system
                strategicCall.generatedBlocks.forEach(blockKey => {
                    this.outfillBlocks.set(blockKey, {
                        status: 'completed',
                        progress: 1,
                        layerId: layerElement.id
                    });
                });
            }

            extractStrategicBlocks(sourceCanvas, strategicCall) {
                const blockSizeX = this.imageWidth;
                const blockSizeY = this.imageHeight;
                
                console.log(`üß© Extracting ${strategicCall.generatedBlocks.length} strategic blocks from ${sourceCanvas.width}x${sourceCanvas.height} canvas`);
                
                // Calculate extraction coordinates for each block
                const blocksToExtract = [];
                
                strategicCall.generatedBlocks.forEach(blockKey => {
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    
                    // Calculate source coordinates in the 2x2 response
                    let sourceX, sourceY;
                    
                    if (strategicCall.directionX > 0 && strategicCall.directionY > 0) {
                        // Down-right diagonal call
                        if (gridX === 1 && gridY === 0) {
                            sourceX = blockSizeX; sourceY = 0; // Top-right
                        } else if (gridX === 0 && gridY === 1) {
                            sourceX = 0; sourceY = blockSizeY; // Bottom-left
                        } else if (gridX === 1 && gridY === 1) {
                            sourceX = blockSizeX; sourceY = blockSizeY; // Bottom-right
                        }
                    } else if (strategicCall.directionX < 0 && strategicCall.directionY > 0) {
                        // Down-left diagonal call
                        if (gridX === -1 && gridY === 0) {
                            sourceX = 0; sourceY = 0; // Top-left
                        } else if (gridX === 0 && gridY === 1) {
                            sourceX = blockSizeX; sourceY = blockSizeY; // Bottom-right
                        } else if (gridX === -1 && gridY === 1) {
                            sourceX = 0; sourceY = blockSizeY; // Bottom-left
                        }
                    }
                    // Add more direction combinations as needed
                    
                    if (sourceX !== undefined && sourceY !== undefined) {
                        blocksToExtract.push({
                            blockKey: blockKey,
                            sourceX: sourceX,
                            sourceY: sourceY,
                            width: blockSizeX,
                            height: blockSizeY
                        });
                    }
                });
                
                // Extract each block using existing system
                blocksToExtract.forEach(block => {
                    this.extractAndUpdateBlock(sourceCanvas, block);
                });
                
                console.log(`‚úÖ Extracted ${blocksToExtract.length} strategic blocks from API response`);
            }

            processGenerationQueue() {
                // Resort queue before processing
                this.updateGenerationQueue();
                
                if (this.generationQueue.length > 0 && this.activeGenerations < 2) {
                    // üéØ 3-BLOCK TRICK: Check if we can use strategic multi-block generation
                    const strategicCall = this.findStrategicMultiBlockOpportunity();
                    
                    if (strategicCall) {
                        console.log('üß© Using 3-block trick for strategic generation:', strategicCall);
                        this.executeStrategicMultiBlockCall(strategicCall);
                    } else {
                        // Fall back to individual block generation
                        const blockKey = this.generationQueue.shift();
                        this.activeGenerations++;
                        
                        // Change status from 'queued' to 'generating'
                        const block = this.outfillBlocks.get(blockKey);
                        if (block) {
                            block.status = 'generating';
                            this.updateOutfillBlock(blockKey, block);
                        }
                        
                        // Use real API generation in live mode, simulation in demo mode
                        if (this.isLiveMode && this.apiKey) {
                            this.generateOutfill(blockKey).then((result) => {
                                console.log('‚úÖ generateOutfill completed successfully for block:', blockKey, result);
                                this.activeGenerations--;
                                this.processGenerationQueue();
                            }).catch((error) => {
                                console.error('‚ùå Generation failed for block:', blockKey, error);
                                // Mark block as failed and continue
                                const block = this.outfillBlocks.get(blockKey);
                                if (block) {
                                    block.status = 'failed';
                                    this.updateOutfillBlock(blockKey, block);
                                }
                                this.activeGenerations--;
                                this.processGenerationQueue();
                            });
                        } else {
                            this.simulateGeneration(blockKey).then(() => {
                                this.activeGenerations--;
                                this.processGenerationQueue();
                            });
                        }
                    }
                }
                
                // Update queue indicator
                this.updateQueueIndicator();
            }

            updateQueueIndicator() {
                const queueCount = this.generationQueue.length;
                const activeCount = this.activeGenerations;
                this.queueIndicator.textContent = `Queue: ${queueCount} | Active: ${activeCount}`;
            }





            async generateMaskForBlock(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // Create a canvas for the mask (2x2 for outpaint extensions)
                const canvas = document.createElement('canvas');
                canvas.width = this.imageWidth * 2;
                canvas.height = this.imageHeight * 2;
                const ctx = canvas.getContext('2d');
                
                // Fill with black (keep existing content)
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // BLOCKSIZE=1 SYSTEM: Original image is at center (0,0)
                // Mark the original image area as black (preserve)
                ctx.fillStyle = 'black';
                ctx.fillRect(
                    this.imageWidth / 2,
                    this.imageHeight / 2,
                    this.imageWidth,
                    this.imageHeight
                );
                
                // Mark the target extension area as white (outpaint)
                ctx.fillStyle = 'white';
                const targetX = this.imageWidth / 2 + (gridX * this.imageWidth);
                const targetY = this.imageHeight / 2 + (gridY * this.imageHeight);
                
                ctx.fillRect(
                    targetX,
                    targetY,
                    this.imageWidth,
                    this.imageHeight
                );
                
                console.log(`üé≠ Generated mask for block ${blockKey}: target area at (${targetX}, ${targetY})`);
                
                // Convert canvas to blob
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
            }

            getOutpaintDirections(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // BLOCKSIZE=1 SYSTEM: Original image is at (0,0), each block is full image size
                // Adjacent blocks: (1,0)=right, (-1,0)=left, (0,1)=down, (0,-1)=up, etc.
                
                // For the 3-block trick, we need to determine which diagonal direction
                // will generate this block as one of the 3 blocks in the response
                
                let directionX = 0;
                let directionY = 0;
                
                // Determine direction based on block position relative to original (0,0)
                if (gridX > 0) directionX = 1;      // Right
                else if (gridX < 0) directionX = -1; // Left
                
                if (gridY > 0) directionY = 1;      // Down  
                else if (gridY < 0) directionY = -1; // Up
                
                return { directionX, directionY, gridX, gridY };
            }

            positionOutpaintBackground(blockElement, blockKey, directions) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                const gridSizeX = this.containerWidth / this.blockDivisions;
                const gridSizeY = this.containerHeight / this.blockDivisions;
                
                console.log(`üé® Positioning outpaint background for block ${blockKey}, directions:`, directions);
                console.log(`üé® Block divisions: ${this.blockDivisions}, Grid size: ${gridSizeX} √ó ${gridSizeY}`);
                console.log(`üé® Container size: ${this.containerWidth} √ó ${this.containerHeight}`);
                
                // The Stability AI outpaint API returns an image that contains:
                // 1. The original image in its original position
                // 2. The extended content in the requested directions
                // We need to position this composite image so that:
                // - The original image portion aligns with the actual original image
                // - Only the extended portion shows in this block
                
                if (directions.includes('right') && !directions.includes('left') && !directions.includes('up') && !directions.includes('bottom')) {
                    // Pure right outpaint
                    // Generated image = [original image][new content]
                    // We want to show only the new content in this block
                    // So we position the background so the new content aligns with this block
                    blockElement.style.backgroundSize = `${this.containerWidth + gridSizeX}px ${this.containerHeight}px`;
                    blockElement.style.backgroundPosition = `${-this.containerWidth}px 0px`;
                    console.log(`üé® Right outpaint: backgroundSize=${this.containerWidth + gridSizeX}x${this.containerHeight}, position=${-this.containerWidth},0`);
                    
                } else if (directions.includes('left') && !directions.includes('right') && !directions.includes('up') && !directions.includes('bottom')) {
                    // Pure left outpaint
                    // Generated image = [new content][original image]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth + gridSizeX}px ${this.containerHeight}px`;
                    blockElement.style.backgroundPosition = `0px 0px`;
                    console.log(`üé® Left outpaint: backgroundSize=${this.containerWidth + gridSizeX}x${this.containerHeight}, position=0,0`);
                    
                } else if (directions.includes('bottom') && !directions.includes('top') && !directions.includes('left') && !directions.includes('right')) {
                    // Pure bottom outpaint
                    // Generated image = [original image]
                    //                   [new content]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth}px ${this.containerHeight + gridSizeY}px`;
                    blockElement.style.backgroundPosition = `0px ${-this.containerHeight}px`;
                    console.log(`üé® Bottom outpaint: backgroundSize=${this.containerWidth}x${this.containerHeight + gridSizeY}, position=0,${-this.containerHeight}`);
                    
                } else if (directions.includes('up') && !directions.includes('bottom') && !directions.includes('left') && !directions.includes('right')) {
                    // Pure top outpaint
                    // Generated image = [new content]
                    //                   [original image]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth}px ${this.containerHeight + gridSizeY}px`;
                    blockElement.style.backgroundPosition = `0px 0px`;
                    console.log(`üé® Top outpaint: backgroundSize=${this.containerWidth}x${this.containerHeight + gridSizeY}, position=0,0`);
                    
                } else if (directions.length > 1) {
                    // Multi-direction outpaint (corner blocks)
                    // Calculate the total size of the generated image
                    const totalWidth = this.containerWidth + (directions.includes('left') ? gridSizeX : 0) + (directions.includes('right') ? gridSizeX : 0);
                    const totalHeight = this.containerHeight + (directions.includes('up') ? gridSizeY : 0) + (directions.includes('bottom') ? gridSizeY : 0);
                    
                    // Calculate the position offset to align the original image portion
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    // If there's left extension, the original image is shifted right in the generated image
                    if (directions.includes('left')) {
                        offsetX = -gridSizeX;
                    }
                    // If there's top extension, the original image is shifted down in the generated image
                    if (directions.includes('up')) {
                        offsetY = -gridSizeY;
                    }
                    
                    // Adjust offset based on which block we're positioning
                    if (directions.includes('right') && gridX >= this.blockDivisions) {
                        offsetX -= this.containerWidth;
                    }
                    if (directions.includes('bottom') && gridY >= this.blockDivisions) {
                        offsetY -= this.containerHeight;
                    }
                    
                    blockElement.style.backgroundSize = `${totalWidth}px ${totalHeight}px`;
                    blockElement.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
                    console.log(`üé® Multi-direction outpaint: backgroundSize=${totalWidth}x${totalHeight}, position=${offsetX},${offsetY}`);
                    
                } else {
                    // Fallback: simple fill
                    blockElement.style.backgroundSize = `${gridSizeX}px ${gridSizeY}px`;
                    blockElement.style.backgroundPosition = '0px 0px';
                    console.log(`üé® Fallback: Simple fill - backgroundSize=${gridSizeX}x${gridSizeY}, position=0,0`);
                }
            }

            adjustBlockPositionForActualDimensions(blockKey, block, generatedDimensions) {
                // This method is now deprecated - positioning is handled in positionOutpaintBackground
                console.log(`üîß adjustBlockPositionForActualDimensions called for ${blockKey} - using new positioning system`);
            }

            async callStabilityAPI(blockKey) {
                if (!this.apiCallsEnabled) {
                    console.log('üö´ API calls disabled - keeping grey loading block');
                    return;
                }
                
                if (!this.apiKey) {
                    throw new Error('No API key available');
                }

                try {
                    const { directionX, directionY, gridX, gridY } = this.getOutpaintDirections(blockKey);
                    
                    // BLOCKSIZE=1: Each block is exactly the original image size
                    const blockSizeX = this.imageWidth;   // 1600px
                    const blockSizeY = this.imageHeight;  // 1024px
                    
                    console.log(`üé® API Call for block ${blockKey}: direction=(${directionX},${directionY}), blockSize=${blockSizeX}x${blockSizeY}`);
                    
                    // Get the original image as blob
                    const imageBlob = await this.getImageAsBlob();
                    
                    // Prepare form data
                    const formData = new FormData();
                    formData.append('image', imageBlob, 'image.jpg');
                    formData.append('prompt', this.apiConfig.prompt);
                    formData.append('creativity', this.apiConfig.creativity.toString());
                    formData.append('output_format', this.apiConfig.output_format);
                    
                    // Add direction-based outpaint parameters
                    if (directionX > 0) {
                        formData.append('right', blockSizeX.toString());
                    } else if (directionX < 0) {
                        formData.append('left', blockSizeX.toString());
                    }
                    
                    if (directionY > 0) {
                        formData.append('down', blockSizeY.toString());
                    } else if (directionY < 0) {
                        formData.append('up', blockSizeY.toString());
                    }
                    
                    // Add optional parameters
                    if (this.apiConfig.seed !== null) {
                        formData.append('seed', this.apiConfig.seed.toString());
                    }
                    if (this.apiConfig.style_preset !== null) {
                        formData.append('style_preset', this.apiConfig.style_preset);
                    }
                    
                    console.log(`üì§ API Request: ${directionX > 0 ? 'right=' + blockSizeX : ''}${directionX < 0 ? 'left=' + blockSizeX : ''}${directionY > 0 ? ' down=' + blockSizeY : ''}${directionY < 0 ? ' up=' + blockSizeY : ''}`);
                    
                    // Make API call
                    const response = await fetch(this.apiConfig.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Accept': 'image/*'
                        },
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API call failed: ${response.status} - ${errorText}`);
                    }
                    
                    // Get the response blob
                    const responseBlob = await response.blob();
                    
                    // Process multi-block response
                    return await this.processMultiBlockResponse(responseBlob, blockKey, directionX, directionY);
                    
                } catch (error) {
                    console.error('Stability API error:', error);
                    throw error;
                }
            }

            async processMultiBlockResponse(responseBlob, originalBlockKey, directionX, directionY) {
                try {
                    console.log(`üîÑ Processing multi-block response for ${originalBlockKey}, direction=(${directionX},${directionY})`);
                    
                    // Create image from response blob to extract blocks
                    const responseImage = new Image();
                    const imageUrl = URL.createObjectURL(responseBlob);
                    
                    return new Promise((resolve, reject) => {
                        responseImage.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                // BLOCKSIZE=1: Response is 2x2 of original image size
                                const originalWidth = this.imageWidth;   // 1600px
                                const originalHeight = this.imageHeight; // 1024px
                                
                                let responseWidth = originalWidth;
                                let responseHeight = originalHeight;
                                
                                if (directionX !== 0) responseWidth *= 2;
                                if (directionY !== 0) responseHeight *= 2;
                                
                                console.log(`üìê Expected response: ${responseWidth}x${responseHeight}, actual: ${responseImage.width}x${responseImage.height}`);
                                
                                // Set canvas to response image size
                                canvas.width = responseImage.width;
                                canvas.height = responseImage.height;
                                ctx.drawImage(responseImage, 0, 0);
                                
                                // Extract and place blocks based on direction
                                this.extractAndPlaceBlocks(canvas, originalBlockKey, directionX, directionY);
                                
                                // Clean up
                                URL.revokeObjectURL(imageUrl);
                                
                                // Return the original block's data URL for backward compatibility
                                resolve(imageUrl);
                                
                            } catch (error) {
                                console.error('Error processing multi-block response:', error);
                                reject(error);
                            }
                        };
                        
                        responseImage.onerror = () => {
                            reject(new Error('Failed to load response image'));
                        };
                        
                        responseImage.src = imageUrl;
                    });
                    
                } catch (error) {
                    console.error('Error in processMultiBlockResponse:', error);
                    throw error;
                }
            }

            extractAndPlaceBlocks(sourceCanvas, originalBlockKey, directionX, directionY) {
                const [originalGridX, originalGridY] = originalBlockKey.split(',').map(Number);
                
                // BLOCKSIZE=1: Each block is exactly the original image size
                const blockSizeX = this.imageWidth;   // 1600px
                const blockSizeY = this.imageHeight;  // 1024px
                
                console.log(`üß© Extracting blocks from ${sourceCanvas.width}x${sourceCanvas.height} canvas`);
                
                // Calculate which blocks to extract based on direction
                const blocksToExtract = [];
                
                if (directionX !== 0 && directionY !== 0) {
                    // Diagonal direction - extracts 3 blocks
                    const rightBlockX = originalGridX + (directionX > 0 ? 1 : -1);
                    const downBlockY = originalGridY + (directionY > 0 ? 1 : -1);
                    
                    blocksToExtract.push({
                        blockKey: `${rightBlockX},${originalGridY}`,
                        sourceX: directionX > 0 ? blockSizeX : 0,
                        sourceY: 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                    blocksToExtract.push({
                        blockKey: `${originalGridX},${downBlockY}`,
                        sourceX: 0,
                        sourceY: directionY > 0 ? blockSizeY : 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                    blocksToExtract.push({
                        blockKey: `${rightBlockX},${downBlockY}`,
                        sourceX: directionX > 0 ? blockSizeX : 0,
                        sourceY: directionY > 0 ? blockSizeY : 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                } else if (directionX !== 0) {
                    // Horizontal direction - extracts 1 block
                    const newBlockX = originalGridX + (directionX > 0 ? 1 : -1);
                    blocksToExtract.push({
                        blockKey: `${newBlockX},${originalGridY}`,
                        sourceX: directionX > 0 ? blockSizeX : 0,
                        sourceY: 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                } else if (directionY !== 0) {
                    // Vertical direction - extracts 1 block
                    const newBlockY = originalGridY + (directionY > 0 ? 1 : -1);
                    blocksToExtract.push({
                        blockKey: `${originalGridX},${newBlockY}`,
                        sourceX: 0,
                        sourceY: directionY > 0 ? blockSizeY : 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                }
                
                // Extract each block and update the system
                blocksToExtract.forEach(block => {
                    this.extractAndUpdateBlock(sourceCanvas, block);
                });
                
                console.log(`‚úÖ Extracted ${blocksToExtract.length} blocks from API response`);
            }

            extractAndUpdateBlock(sourceCanvas, blockInfo) {
                try {
                    // Create canvas for this block
                    const blockCanvas = document.createElement('canvas');
                    const blockCtx = blockCanvas.getContext('2d');
                    
                    blockCanvas.width = blockInfo.width;
                    blockCanvas.height = blockInfo.height;
                    
                    // Extract the block area from source canvas
                    blockCtx.drawImage(
                        sourceCanvas,
                        blockInfo.sourceX, blockInfo.sourceY, blockInfo.width, blockInfo.height,
                        0, 0, blockInfo.width, blockInfo.height
                    );
                    
                    // Convert to data URL
                    const blockDataUrl = blockCanvas.toDataURL('image/jpeg', 0.9);
                    
                    // Update the block in our system
                    this.outfillBlocks.set(blockInfo.blockKey, {
                        status: 'ready',
                        progress: 1,
                        imageData: blockDataUrl
                    });
                    
                    this.updateOutfillBlock(blockInfo.blockKey, this.outfillBlocks.get(blockInfo.blockKey));
                    
                    console.log(`üéØ Block ${blockInfo.blockKey} extracted and updated`);
                    
                    // Check for newly adjacent blocks
                    this.checkForNewlyAdjacentBlocks(blockInfo.blockKey);
                    
                } catch (error) {
                    console.error(`Error extracting block ${blockInfo.blockKey}:`, error);
                }
            }

            async getImageAsBlob() {
                return new Promise(async (resolve, reject) => {
                    // In standalone mode, use embedded base64 data
                    if (window.location.protocol === 'file:') {
                        try {
                            console.log('üîß Using embedded base64 data for standalone mode');
                            
                            // Use the existing image element's src as base64
                            const imgElement = document.querySelector('img[alt="Psychedelic Flora"]');
                            if (imgElement && imgElement.src.startsWith('data:')) {
                                // Image is already a data URL, convert to blob
                                const response = await fetch(imgElement.src);
                                const blob = await response.blob();
                                console.log('üîß Converted data URL to blob for standalone mode:', blob.size, 'bytes');
                                resolve(blob);
                                return;
                            }
                            
                            // Try to fetch the image file directly
                            try {
                                const response = await fetch('./psychedelic-flora.jpg');
                                if (response.ok) {
                                    const blob = await response.blob();
                                    console.log('üîß Successfully fetched image as blob for standalone mode:', blob.size, 'bytes');
                                    resolve(blob);
                                    return;
                                }
                            } catch (e) {
                                console.log('üîß Direct fetch failed, using fallback');
                            }
                            
                            // Fallback: Create a realistic floral pattern instead of gradient
                            console.log('üîß Creating realistic floral pattern for standalone mode');
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            canvas.width = this.imageWidth;
                            canvas.height = this.imageHeight;
                            
                            // Create a more realistic floral background
                            const gradient = ctx.createRadialGradient(
                                canvas.width/2, canvas.height/2, 0,
                                canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2
                            );
                            gradient.addColorStop(0, '#2d5016');
                            gradient.addColorStop(0.3, '#4a7c59');
                            gradient.addColorStop(0.6, '#6b8e23');
                            gradient.addColorStop(1, '#228b22');
                            
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Add floral elements
                            for (let i = 0; i < 50; i++) {
                                const x = Math.random() * canvas.width;
                                const y = Math.random() * canvas.height;
                                const size = Math.random() * 20 + 5;
                                
                                // Flower petals
                                ctx.fillStyle = `hsl(${Math.random() * 60 + 300}, 70%, 60%)`;
                                for (let j = 0; j < 5; j++) {
                                    ctx.beginPath();
                                    ctx.ellipse(x + Math.cos(j * Math.PI * 2 / 5) * size/2, 
                                              y + Math.sin(j * Math.PI * 2 / 5) * size/2, 
                                              size/3, size/6, j * Math.PI * 2 / 5, 0, 2 * Math.PI);
                                    ctx.fill();
                                }
                                
                                // Flower center
                                ctx.fillStyle = '#ffeb3b';
                                ctx.beginPath();
                                ctx.arc(x, y, size/4, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                            
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    console.log('üîß Created realistic floral pattern blob for standalone mode');
                                    resolve(blob);
                                } else {
                                    reject(new Error('Failed to create floral pattern blob'));
                                }
                            }, 'image/jpeg', 0.9);
                            return;
                        } catch (error) {
                            console.error('üö® All approaches failed:', error);
                            reject(error);
                        }
                    }
                    
                    // Server mode - standard approach
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = this.image;

                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);

                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create image blob'));
                        }
                    }, 'image/jpeg', 0.9);
                });
            }

            updateTransform() {
                this.content.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
                this.zoomIndicator.textContent = `${this.scale.toFixed(2)}x`;
                this.drawGrid(); // Redraw grid when transform changes
                this.checkVisibleBlocks();
            }
            

        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // In standalone mode, convert image to data URL to avoid canvas tainting
            if (window.location.protocol === 'file:') {
                const img = document.getElementById('mainImage');
                
                // Wait for image to load, then convert to data URL before initializing viewer
                if (img.complete) {
                    convertAndInitialize();
                } else {
                    img.onload = convertAndInitialize;
                }
                
                function convertAndInitialize() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        ctx.drawImage(img, 0, 0);
                        const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                        img.src = dataURL;
                        console.log('üîß Converted image to data URL for standalone mode');
                        
                        // Initialize viewer after conversion
                        setTimeout(() => {
                            window.viewer = new ImageViewer();
                        }, 100);
                    } catch (error) {
                        console.log('üîß Could not convert image to data URL:', error.message);
                        // Initialize viewer anyway
                        window.viewer = new ImageViewer();
                    }
                }
            } else {
                // Server mode - initialize normally
                window.viewer = new ImageViewer();
            }
        });
        
        // Replace the placeholder image with your actual image
        // Just change the src attribute of the img element to your image path
        // document.getElementById('mainImage').src = 'path/to/your/psychedelic-flora.jpg';
    </script>
</body>
</html>