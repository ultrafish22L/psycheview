<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PsycheView - Standalone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Animated Background */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #fb5607);
            background-size: 400% 400%;
            animation: psychedelicFlow 120s ease-in-out infinite;
        }

        @keyframes psychedelicFlow {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        /* Floating elements */
        .psychedelic-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(2px);
            animation: psychedelicFloat 20s ease-in-out infinite;
        }

        .psychedelic-orb:nth-child(1) {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 0, 110, 0.8), transparent);
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .psychedelic-orb:nth-child(2) {
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(131, 56, 236, 0.8), transparent);
            top: 60%;
            right: 15%;
            animation-delay: -5s;
        }

        .psychedelic-orb:nth-child(3) {
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, rgba(58, 134, 255, 0.8), transparent);
            bottom: 20%;
            left: 20%;
            animation-delay: -10s;
        }

        .psychedelic-orb:nth-child(4) {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(6, 255, 165, 0.8), transparent);
            top: 30%;
            right: 40%;
            animation-delay: -15s;
        }

        @keyframes psychedelicFloat {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            25% { transform: translate(50px, -30px) scale(1.2) rotate(90deg); }
            50% { transform: translate(-30px, 40px) scale(0.8) rotate(180deg); }
            75% { transform: translate(40px, 20px) scale(1.1) rotate(270deg); }
        }

        /* Main container */
        .app-container {
            position: relative;
            min-height: 100vh;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 15px 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            pointer-events: none;
        }

        /* Image Viewer */
        .image-viewer {
            position: relative;
            margin: 60px auto;
            overflow: hidden;
            cursor: grab;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .image-viewer:active {
            cursor: grabbing;
        }

        .viewer-content {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        /* Tiled Background */
        .tiled-background {
            position: absolute;
            width: 1000%;
            height: 1000%;
            top: -450%;
            left: -450%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255, 0, 255, 0.15) 20%, transparent 25%),
                radial-gradient(circle at 0% 0%, rgba(0, 255, 255, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 0%, rgba(255, 255, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 0% 100%, rgba(255, 100, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 100%, rgba(100, 255, 100, 0.12) 15%, transparent 20%),
                linear-gradient(0deg, transparent 45%, rgba(255, 0, 100, 0.08) 47%, rgba(255, 0, 100, 0.08) 53%, transparent 55%),
                linear-gradient(60deg, transparent 45%, rgba(100, 0, 255, 0.08) 47%, rgba(100, 0, 255, 0.08) 53%, transparent 55%),
                linear-gradient(120deg, transparent 45%, rgba(0, 255, 150, 0.08) 47%, rgba(0, 255, 150, 0.08) 53%, transparent 55%),
                radial-gradient(ellipse 30px 52px at 50% 50%, rgba(255, 150, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 0% 0%, rgba(150, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 100% 100%, rgba(255, 0, 150, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 40px 20px at 25% 25%, rgba(255, 255, 0, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 40px 20px at 75% 75%, rgba(0, 255, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 75% 25%, rgba(255, 0, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 25% 75%, rgba(100, 255, 100, 0.06) 0%, transparent 70%);
            background-size: 
                120px 120px,
                240px 240px,
                240px 240px,
                240px 240px,
                240px 240px,
                80px 138px,
                80px 138px,
                80px 138px,
                60px 104px,
                120px 208px,
                120px 208px,
                160px 160px,
                160px 160px,
                160px 160px,
                160px 160px;
            background-position:
                60px 60px,
                0px 0px,
                120px 0px,
                0px 120px,
                120px 120px,
                0px 0px,
                40px 69px,
                80px 0px,
                30px 52px,
                60px 104px,
                90px 156px,
                0px 0px,
                80px 80px,
                40px 120px,
                120px 40px;
            background-repeat: repeat;
            opacity: 0.5;
            mix-blend-mode: multiply;
            filter: saturate(1.3) contrast(1.1) brightness(1.2);
            animation: islamicShift 90s ease-in-out infinite;
        }

        @keyframes islamicShift {
            0%, 100% { 
                filter: saturate(1.3) contrast(1.1) brightness(1.2) hue-rotate(0deg);
                opacity: 0.5;
            }
            25% { 
                filter: saturate(1.6) contrast(1.3) brightness(1.0) hue-rotate(90deg);
                opacity: 0.6;
            }
            50% { 
                filter: saturate(1.4) contrast(1.4) brightness(1.3) hue-rotate(180deg);
                opacity: 0.4;
            }
            75% { 
                filter: saturate(1.8) contrast(1.2) brightness(1.1) hue-rotate(270deg);
                opacity: 0.7;
            }
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            width: 1000%;
            height: 1000%;
            top: -450%;
            left: -450%;
            background-image: 
                linear-gradient(rgba(128, 128, 128, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(128, 128, 128, 0.15) 1px, transparent 1px);
            background-size: 200px 150px;
            pointer-events: none;
            mix-blend-mode: soft-light;
            animation: subtleGridShift 75s ease-in-out infinite;
            z-index: 1;
        }

        @keyframes subtleGridShift {
            0%, 100% { 
                opacity: 0.3;
                filter: hue-rotate(0deg) saturate(1.2);
            }
            33% { 
                opacity: 0.4;
                filter: hue-rotate(120deg) saturate(1.4);
            }
            66% { 
                opacity: 0.2;
                filter: hue-rotate(240deg) saturate(1.1);
            }
        }

        /* Main Image */
        .main-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;

            z-index: 3;
        }

        /* Zoom indicator */
        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="animated-background">
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
    </div>

    <div class="app-container">
        <div class="instructions">
            🎨 Click & drag to pan • Scroll to zoom (0.25x - 4x) • Touch supported
        </div>
        
        <div class="image-viewer" id="imageViewer">
            <div class="viewer-content" id="viewerContent">
                <div class="tiled-background"></div>
                <div class="grid-overlay"></div>
                <img class="main-image" id="mainImage" src="psychedelic-flora.jpg" alt="Psychedelic Flora" draggable="false">
            </div>
            <div class="zoom-indicator" id="zoomIndicator">1.00x</div>
        </div>
    </div>

    <script>
        class ImageViewer {
            constructor() {
                this.viewer = document.getElementById('imageViewer');
                this.content = document.getElementById('viewerContent');
                this.image = document.getElementById('mainImage');
                this.zoomIndicator = document.getElementById('zoomIndicator');
                
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                this.minScale = 0.25;
                this.maxScale = 4;
                
                // Outfill properties
                this.outfillBlocks = new Map();
                this.generationQueue = [];
                this.activeGenerations = 0;
                this.lastVisibleBlocks = new Set();
                this.imageWidth = 0;
                this.imageHeight = 0;
                
                this.init();
            }
            
            init() {
                // Set up container size based on image aspect ratio - windowed approach
                const setupSize = () => {
                    if (this.image.naturalWidth && this.image.naturalHeight) {
                        this.imageWidth = this.image.naturalWidth;
                        this.imageHeight = this.image.naturalHeight;
                        const aspectRatio = this.imageWidth / this.imageHeight;
                        
                        // Create a window sized to fit the image with some margin for the psychedelic background
                        const maxHeight = window.innerHeight - 120;
                        const maxWidth = window.innerWidth - 80;
                        
                        let finalWidth, finalHeight;
                        
                        if (maxWidth / aspectRatio <= maxHeight) {
                            finalWidth = maxWidth;
                            finalHeight = maxWidth / aspectRatio;
                        } else {
                            finalHeight = maxHeight;
                            finalWidth = maxHeight * aspectRatio;
                        }
                        
                        this.viewer.style.width = finalWidth + 'px';
                        this.viewer.style.height = finalHeight + 'px';
                        this.containerWidth = finalWidth;
                        this.containerHeight = finalHeight;
                    } else {
                        // Fallback size if image not loaded yet
                        this.viewer.style.width = '800px';
                        this.viewer.style.height = '600px';
                        this.containerWidth = 800;
                        this.containerHeight = 600;
                    }
                };
                
                this.image.onload = setupSize;
                // Also call immediately in case image is already loaded
                setupSize();
                
                // Mouse events
                this.viewer.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Wheel event for zooming
                this.viewer.addEventListener('wheel', this.handleWheel.bind(this));
                
                // Touch events for mobile
                this.viewer.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.viewer.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.viewer.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Prevent context menu
                this.viewer.addEventListener('contextmenu', e => e.preventDefault());
                
                this.updateTransform();
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.content.style.transition = 'none';
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastX;
                const deltaY = e.clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateTransform();
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.viewer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const mouseX = e.clientX - centerX;
                const mouseY = e.clientY - centerY;
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * delta));
                
                if (newScale !== this.scale) {
                    const scaleDiff = newScale / this.scale;
                    
                    this.translateX = mouseX - (mouseX - this.translateX) * scaleDiff;
                    this.translateY = mouseY - (mouseY - this.translateY) * scaleDiff;
                    
                    this.scale = newScale;
                    this.updateTransform();
                }
            }
            
            handleTouchStart(e) {
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    this.content.style.transition = 'none';
                }
                e.preventDefault();
            }
            
            handleTouchMove(e) {
                if (!this.isDragging || e.touches.length !== 1) return;
                
                const deltaX = e.touches[0].clientX - this.lastX;
                const deltaY = e.touches[0].clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                this.lastX = e.touches[0].clientX;
                this.lastY = e.touches[0].clientY;
                
                this.updateTransform();
                e.preventDefault();
            }
            
            handleTouchEnd() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            getVisibleBlocks() {
                if (!this.containerWidth || !this.containerHeight || !this.imageWidth || !this.imageHeight) return new Set();
                
                const visibleBlocks = new Set();
                const gridSizeX = this.imageWidth / 4;
                const gridSizeY = this.imageHeight / 4;
                
                // Calculate the viewport bounds in image coordinates
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + this.containerWidth / this.scale;
                const viewportBottom = viewportTop + this.containerHeight / this.scale;
                
                // Calculate grid bounds that are visible
                const startGridX = Math.floor(viewportLeft / gridSizeX);
                const endGridX = Math.ceil(viewportRight / gridSizeX);
                const startGridY = Math.floor(viewportTop / gridSizeY);
                const endGridY = Math.ceil(viewportBottom / gridSizeY);
                
                // Add all visible grid blocks, including those outside the original image
                for (let gridX = startGridX; gridX < endGridX; gridX++) {
                    for (let gridY = startGridY; gridY < endGridY; gridY++) {
                        const blockLeft = gridX * gridSizeX;
                        const blockRight = (gridX + 1) * gridSizeX;
                        const blockTop = gridY * gridSizeY;
                        const blockBottom = (gridY + 1) * gridSizeY;
                        
                        // Check if this block extends beyond the original image
                        const isOutsideImage = blockLeft >= this.imageWidth || blockRight <= 0 || 
                                              blockTop >= this.imageHeight || blockBottom <= 0 ||
                                              blockLeft < 0 || blockTop < 0;
                        
                        if (isOutsideImage) {
                            visibleBlocks.add(`${gridX},${gridY}`);
                        }
                    }
                }
                
                return visibleBlocks;
            }
            
            simulateGeneration(blockKey) {
                return new Promise((resolve) => {
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 0.05;
                        const block = this.outfillBlocks.get(blockKey);
                        if (block) {
                            block.progress = progress;
                            this.updateOutfillBlock(blockKey, block);
                        }
                        
                        if (progress >= 1) {
                            clearInterval(interval);
                            this.outfillBlocks.set(blockKey, { 
                                status: 'ready', 
                                progress: 1, 
                                imageData: this.image.src 
                            });
                            this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                            resolve();
                        }
                    }, 200);
                });
            }
            
            updateOutfillBlock(blockKey, block) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                const gridSizeX = this.imageWidth / 4;
                const gridSizeY = this.imageHeight / 4;
                const blockLeft = gridX * gridSizeX;
                const blockTop = gridY * gridSizeY;
                
                let blockElement = document.getElementById(`outfill-${blockKey}`);
                if (!blockElement) {
                    blockElement = document.createElement('div');
                    blockElement.id = `outfill-${blockKey}`;
                    blockElement.style.position = 'absolute';
                    blockElement.style.zIndex = '2';
                    this.content.appendChild(blockElement);
                }
                
                blockElement.style.left = blockLeft + 'px';
                blockElement.style.top = blockTop + 'px';
                blockElement.style.width = gridSizeX + 'px';
                blockElement.style.height = gridSizeY + 'px';
                
                if (block.status === 'ready') {
                    blockElement.style.backgroundImage = `url(${block.imageData})`;
                    blockElement.style.backgroundSize = 'cover';
                    blockElement.style.backgroundPosition = 'center';
                    blockElement.style.backgroundColor = 'transparent';
                    blockElement.innerHTML = '';
                } else if (block.status === 'generating') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                    const progressPercent = Math.round(block.progress * 100);
                    const circumference = 2 * Math.PI * 20; // radius = 20
                    const strokeDashoffset = circumference - (block.progress * circumference);
                    
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 50px;
                            height: 50px;
                        ">
                            <svg width="50" height="50" style="transform: rotate(-90deg);">
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(255, 255, 255, 0.2)" 
                                    stroke-width="3"/>
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(0, 255, 255, 0.8)" 
                                    stroke-width="3"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${strokeDashoffset}"
                                    stroke-linecap="round"
                                    style="transition: stroke-dashoffset 0.2s ease;"/>
                            </svg>
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                color: rgba(255, 255, 255, 0.9);
                                font-size: 10px;
                                font-weight: bold;
                                text-align: center;
                            ">${progressPercent}%</div>
                        </div>
                    `;
                } else if (block.status === 'queued') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.6);
                            font-size: 12px;
                            text-align: center;
                        ">⏳</div>
                    `;
                }
            }
            
            checkVisibleBlocks() {
                const currentVisibleBlocks = this.getVisibleBlocks();
                
                // Find new blocks that weren't visible before
                const newBlocks = [];
                currentVisibleBlocks.forEach(blockKey => {
                    if (!this.lastVisibleBlocks.has(blockKey) && !this.outfillBlocks.has(blockKey)) {
                        newBlocks.push(blockKey);
                        this.outfillBlocks.set(blockKey, { status: 'queued', progress: 0, imageData: null });
                        this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                    }
                });
                
                // Add new blocks to generation queue
                if (newBlocks.length > 0) {
                    this.generationQueue.push(...newBlocks);
                    this.processGenerationQueue();
                }
                
                this.lastVisibleBlocks = currentVisibleBlocks;
            }
            
            processGenerationQueue() {
                if (this.generationQueue.length > 0 && this.activeGenerations < 2) {
                    const blockKey = this.generationQueue.shift();
                    this.activeGenerations++;
                    
                    // Change status from 'queued' to 'generating'
                    const block = this.outfillBlocks.get(blockKey);
                    if (block) {
                        block.status = 'generating';
                        this.updateOutfillBlock(blockKey, block);
                    }
                    
                    this.simulateGeneration(blockKey).then(() => {
                        this.activeGenerations--;
                        this.processGenerationQueue();
                    });
                }
            }

            updateTransform() {
                this.content.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
                this.zoomIndicator.textContent = `${this.scale.toFixed(2)}x`;
                this.checkVisibleBlocks();
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ImageViewer();
        });
        
        // Replace the placeholder image with your actual image
        // Just change the src attribute of the img element to your image path
        // document.getElementById('mainImage').src = 'path/to/your/psychedelic-flora.jpg';
    </script>
</body>
</html>