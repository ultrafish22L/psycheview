<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PsycheView - Standalone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Animated Background */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #fb5607);
            background-size: 400% 400%;
            animation: psychedelicFlow 120s ease-in-out infinite;
        }

        @keyframes psychedelicFlow {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        /* Floating elements */
        .psychedelic-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(2px);
            animation: psychedelicFloat 20s ease-in-out infinite;
        }

        .psychedelic-orb:nth-child(1) {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 0, 110, 0.8), transparent);
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .psychedelic-orb:nth-child(2) {
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(131, 56, 236, 0.8), transparent);
            top: 60%;
            right: 15%;
            animation-delay: -5s;
        }

        .psychedelic-orb:nth-child(3) {
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, rgba(58, 134, 255, 0.8), transparent);
            bottom: 20%;
            left: 20%;
            animation-delay: -10s;
        }

        .psychedelic-orb:nth-child(4) {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(6, 255, 165, 0.8), transparent);
            top: 30%;
            right: 40%;
            animation-delay: -15s;
        }

        @keyframes psychedelicFloat {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            25% { transform: translate(50px, -30px) scale(1.2) rotate(90deg); }
            50% { transform: translate(-30px, 40px) scale(0.8) rotate(180deg); }
            75% { transform: translate(40px, 20px) scale(1.1) rotate(270deg); }
        }

        /* Main container */
        .app-container {
            position: relative;
            min-height: 100vh;
        }



        /* Image Viewer */
        .image-viewer {
            position: relative;
            margin: 60px auto;
            overflow: hidden;
            cursor: grab;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.4);
        }

        .image-viewer:active {
            cursor: grabbing;
        }

        .viewer-content {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        /* Tiled Background */
        .tiled-background {
            position: absolute;
            width: 1000%;
            height: 1000%;
            top: -450%;
            left: -450%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255, 0, 255, 0.15) 20%, transparent 25%),
                radial-gradient(circle at 0% 0%, rgba(0, 255, 255, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 0%, rgba(255, 255, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 0% 100%, rgba(255, 100, 0, 0.12) 15%, transparent 20%),
                radial-gradient(circle at 100% 100%, rgba(100, 255, 100, 0.12) 15%, transparent 20%),
                linear-gradient(0deg, transparent 45%, rgba(255, 0, 100, 0.08) 47%, rgba(255, 0, 100, 0.08) 53%, transparent 55%),
                linear-gradient(60deg, transparent 45%, rgba(100, 0, 255, 0.08) 47%, rgba(100, 0, 255, 0.08) 53%, transparent 55%),
                linear-gradient(120deg, transparent 45%, rgba(0, 255, 150, 0.08) 47%, rgba(0, 255, 150, 0.08) 53%, transparent 55%),
                radial-gradient(ellipse 30px 52px at 50% 50%, rgba(255, 150, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 0% 0%, rgba(150, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 30px 52px at 100% 100%, rgba(255, 0, 150, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 40px 20px at 25% 25%, rgba(255, 255, 0, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 40px 20px at 75% 75%, rgba(0, 255, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 75% 25%, rgba(255, 0, 255, 0.06) 0%, transparent 70%),
                radial-gradient(ellipse 20px 40px at 25% 75%, rgba(100, 255, 100, 0.06) 0%, transparent 70%);
            background-size: 
                120px 120px,
                240px 240px,
                240px 240px,
                240px 240px,
                240px 240px,
                80px 138px,
                80px 138px,
                80px 138px,
                60px 104px,
                120px 208px,
                120px 208px,
                160px 160px,
                160px 160px,
                160px 160px,
                160px 160px;
            background-position:
                60px 60px,
                0px 0px,
                120px 0px,
                0px 120px,
                120px 120px,
                0px 0px,
                40px 69px,
                80px 0px,
                30px 52px,
                60px 104px,
                90px 156px,
                0px 0px,
                80px 80px,
                40px 120px,
                120px 40px;
            background-repeat: repeat;
            opacity: 0.5;
            mix-blend-mode: multiply;
            filter: saturate(1.3) contrast(1.1) brightness(1.2);
            animation: islamicShift 90s ease-in-out infinite;
        }

        @keyframes islamicShift {
            0%, 100% { 
                filter: saturate(1.3) contrast(1.1) brightness(1.2) hue-rotate(0deg);
                opacity: 0.5;
            }
            25% { 
                filter: saturate(1.6) contrast(1.3) brightness(1.0) hue-rotate(90deg);
                opacity: 0.6;
            }
            50% { 
                filter: saturate(1.4) contrast(1.4) brightness(1.3) hue-rotate(180deg);
                opacity: 0.4;
            }
            75% { 
                filter: saturate(1.8) contrast(1.2) brightness(1.1) hue-rotate(270deg);
                opacity: 0.7;
            }
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes subtleGridShift {
            0%, 100% { 
                opacity: 0.3;
                filter: hue-rotate(0deg) saturate(1.2);
            }
            33% { 
                opacity: 0.4;
                filter: hue-rotate(120deg) saturate(1.4);
            }
            66% { 
                opacity: 0.2;
                filter: hue-rotate(240deg) saturate(1.1);
            }
        }

        /* Main Image - Fill container for consistent sizing */
        .main-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;  /* Maintain aspect ratio, fit within container */
            z-index: 3;
        }

        /* Zoom indicator - hidden by default, shown only in debug mode */
        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-family: monospace;
            display: none;
        }

        /* Queue indicator - always visible, positioned top-right but left of debug windows */
        .queue-indicator {
            position: fixed;
            top: 20px;
            right: 300px; /* Left of debug windows (280px width + 20px margin) */
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            display: block; /* Always visible */
        }



        /* API Key Input */
        .api-key-input {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }

        .api-key-input input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            width: 200px;
            outline: none;
        }

        .api-key-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .api-key-input input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .api-key-input button {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .api-key-input button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .api-key-input button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }



        /* Debug Preview Window - styled like debug windows, no header/footer */
        .debug-preview {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 280px;
            height: 50vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-right: 2px solid #444;
            border-top: 2px solid #444;
            z-index: 1000;
            display: none;
            overflow: hidden;
            padding: 0;
        }

        .debug-preview.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .debug-preview-image {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
        }
    </style>
</head>
<body>
    <div class="animated-background">
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
        <div class="psychedelic-orb"></div>
    </div>

    <div class="app-container">

        


        <div class="api-key-input" id="apiKeyContainer">
            <input type="password" id="apiKeyInput" placeholder="Enter Stability AI API Key" />
            <button id="setApiKeyBtn">Set Key</button>


        </div>

        <div class="image-viewer" id="imageViewer">
            <canvas class="grid-overlay" id="gridCanvas"></canvas>
            <div class="viewer-content" id="viewerContent">
                <div class="tiled-background"></div>
                <img class="main-image" id="mainImage" src="psychedelic-flora.jpg" alt="Psychedelic Flora" draggable="false">
            </div>
            <div class="zoom-indicator" id="zoomIndicator">1.00x</div>

        </div>
    </div>

    <!-- Queue indicator - always visible in top row -->
    <div class="queue-indicator" id="queueIndicator">Queue: 0 | Active: 0</div>

    <!-- Debug windows positioned outside app-container for true browser window positioning -->
    <div class="debug-info" id="debugInfo" style="position: fixed; top: 0; right: 0; width: 280px; height: 50vh; background: rgba(0,0,0,0.85); color: white; padding: 12px; font-family: monospace; font-size: 10px; z-index: 1000; overflow-y: auto; border-left: 2px solid #444; backdrop-filter: blur(10px); display: none;">
        Debug Info
    </div>
    
    <!-- Console capture div positioned outside app-container for true browser window positioning -->
    <div id="consoleCapture" style="position: fixed; top: 50vh; right: 0; width: 280px; height: 50vh; background: rgba(0,0,0,0.9); color: #00ff00; padding: 12px; font-family: monospace; font-size: 9px; z-index: 1001; overflow-y: auto; border-left: 2px solid #333; backdrop-filter: blur(10px); display: none;">
        <div style="color: #ffff00; margin-bottom: 8px; font-weight: bold;">🖥️ CONSOLE OUTPUT:</div>
        <div id="consoleLogs"></div>
    </div>

    <!-- Debug Preview Window - simplified, no header/footer -->
    <div class="debug-preview" id="debugPreview">
        <img class="debug-preview-image" id="debugPreviewImage" alt="Generated Image" style="display: none;">
    </div>

    <script>
        // Override console to capture logs
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const logs = [];
        
        console.log = function(...args) {
            logs.push({type: 'log', message: args.join(' '), time: new Date().toLocaleTimeString()});
            originalConsoleLog.apply(console, args);
            updateDebugConsole();
            updateConsoleCapture();
        };
        
        console.error = function(...args) {
            logs.push({type: 'error', message: args.join(' '), time: new Date().toLocaleTimeString()});
            originalConsoleError.apply(console, args);
            updateDebugConsole();
            updateConsoleCapture();
        };
        
        function updateDebugConsole() {
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                const lastLogs = logs.slice(-10); // Show last 10 logs
                debugInfo.innerHTML = 'Debug Console:<br>' + lastLogs.map(log => 
                    `<span style="color: ${log.type === 'error' ? '#ff4444' : '#44ff44'}">[${log.time}] ${log.message}</span>`
                ).join('<br>');
                // Auto-scroll to bottom
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        function updateConsoleCapture() {
            const consoleDiv = document.getElementById('consoleLogs');
            if (consoleDiv) {
                const lastLogs = logs.slice(-20); // Show last 20 logs
                consoleDiv.innerHTML = lastLogs.map(log =>
                    `<div style="color: ${log.type === 'error' ? '#ff4444' : '#00ff00'}; margin-bottom: 2px; font-size: 10px;">[${log.time}] ${log.message}</div>`
                ).join('');
                // Auto-scroll to bottom
                const captureDiv = document.getElementById('consoleCapture');
                if (captureDiv) {
                    captureDiv.scrollTop = captureDiv.scrollHeight;
                }
            }
        }
        
        class ImageViewer {
            constructor() {
                this.viewer = document.getElementById('imageViewer');
                this.content = document.getElementById('viewerContent');
                this.image = document.getElementById('mainImage');
                
                // API Configuration
                this.config = {
                    endpoint: 'https://api.stability.ai/v2beta/stable-image/edit/outpaint',
                    prompt: "Extend this image of a portion of a yakuza's body tatoo.  Match the scale of the floral pattern and extend it in the same style.  Then embedded within the pattern just like the lizard in the input image, are style matching yōkai, all the great ones includinge kappa, tengu, oni, and kitsune, etc.",
                    output_format: 'jpeg',
                    creativity: 0.35,
                    seed: 0
                };
                this.zoomIndicator = document.getElementById('zoomIndicator');
                this.queueIndicator = document.getElementById('queueIndicator');

                this.debugInfo = document.getElementById('debugInfo');
                this.apiKeyInput = document.getElementById('apiKeyInput');
                this.setApiKeyBtn = document.getElementById('setApiKeyBtn');
                this.testApiBtn = document.getElementById('testApiBtn');

                this.autoGenToggleBtn = document.getElementById('autoGenToggleBtn');
                this.apiCallsToggleBtn = document.getElementById('apiCallsToggleBtn');
                this.testPanBtn = document.getElementById('testPanBtn');
                this.zoomOutMaxBtn = document.getElementById('zoomOutMaxBtn');
                this.imageOpacityBtn = document.getElementById('imageOpacityBtn');
                this.blockLayerBtn = document.getElementById('blockLayerBtn');

                
                // Debug preview elements
                this.debugPreview = document.getElementById('debugPreview');
                this.debugPreviewImage = document.getElementById('debugPreviewImage');

                

                

                

                

                

                
                this.scale = 0.25;
                this.translateX = 0;
                this.translateY = 0;
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                this.minScale = 0.25;
                this.maxScale = 4;
                
                // Block size configuration (1 = same size as image, 4 = quarter size, etc.)
                this.blockDivisions = 1; // Default: blocks are same size as image for easier testing
                
                // Auto-generation control (default: true - blocks are added automatically)
                this.autoGenerateBlocks = true;
                
                // 🌀 SPIRAL SYSTEM: Breakthrough composite layering
                this.spiralRings = []; // Array of rings, each ring is array of block coordinates
                this.currentRing = 0;
                this.currentRingPosition = 0;
                this.spiralInitialized = false;
                
                // API calls control
                this.apiCallsEnabled = true;
                
                // Image opacity control (false = 100%, true = 50%)
                this.imageTranslucent = false;
                
                // Block layer control (false = under image, true = over image)
                this.blocksOverImage = false;
                
                // Grid visibility control (false = hidden, true = visible)
                this.gridVisible = false;
                
                // API system - always try API calls if key available
                this.apiKey = 'sk-khSJsDLcgZd4LxCCRoylXQhiZmPwbAWfdiKCuZ71YzkoJvm8';

                
                // Stability AI API Configuration
                this.apiConfig = {
                    endpoint: 'https://api.stability.ai/v2beta/stable-image/edit/outpaint',
                    prompt: "Extend this image of a portion of a yakuza's body tatoo.  Match the scale of the floral pattern and extend it in the same style.  Then embedded within the pattern just like the lizard in the input image, are style matching yōkai, all the great ones includinge kappa, tengu, oni, and kitsune, etc.",
                    seed: null, // null for random seed
                    output_format: 'jpeg',
                    creativity: 0.35,
                    style_preset: null // null for default style
                };
                
                // Outfill properties
                this.outfillBlocks = new Map();
                this.generationQueue = [];
                this.activeGenerations = 0;
                this.lastVisibleBlocks = new Set();
                this.imageWidth = 0;
                this.imageHeight = 0;
                
                this.init();
            }
            
            init() {
                // Set up container size based on image aspect ratio - windowed approach
                const setupSize = () => {
                    // In standalone mode, provide fallback dimensions since image may not load due to CORS
                    if (window.location.protocol === 'file:' && (!this.image.naturalWidth || !this.image.naturalHeight)) {
                        console.log('🔧 Standalone mode: Using fallback image dimensions (1600x1024)');
                        this.imageWidth = 1600;
                        this.imageHeight = 1024;
                    } else if (this.image.naturalWidth && this.image.naturalHeight) {
                        this.imageWidth = this.image.naturalWidth;
                        this.imageHeight = this.image.naturalHeight;
                    } else {
                        // Fallback size if image not loaded yet
                        this.imageWidth = 1600;
                        this.imageHeight = 1024;
                    }
                    
                    const aspectRatio = this.imageWidth / this.imageHeight;
                    
                    // Create a window sized to fit the image with some margin for the psychedelic background
                    const maxHeight = window.innerHeight - 120;
                    const maxWidth = window.innerWidth - 80;
                    
                    let finalWidth, finalHeight;
                    
                    if (maxWidth / aspectRatio <= maxHeight) {
                        finalWidth = maxWidth;
                        finalHeight = maxWidth / aspectRatio;
                    } else {
                        finalHeight = maxHeight;
                        finalWidth = maxHeight * aspectRatio;
                    }
                    
                    this.viewer.style.width = finalWidth + 'px';
                    this.viewer.style.height = finalHeight + 'px';
                    this.containerWidth = finalWidth;
                    this.containerHeight = finalHeight;
                    
                    // Update grid size to match image dimensions
                    this.updateGridSize();
                };
                
                this.image.onload = setupSize;
                // Also call immediately in case image is already loaded
                setupSize();
                
                // Mouse events
                this.viewer.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Wheel event for zooming
                this.viewer.addEventListener('wheel', this.handleWheel.bind(this));
                
                // Touch events for mobile
                this.viewer.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.viewer.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.viewer.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Prevent context menu
                this.viewer.addEventListener('contextmenu', e => e.preventDefault());
                

                
                // API key input
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.onclick = () => {
                        this.setApiKey();
                    };
                }
                
                if (this.apiKeyInput) {
                    this.apiKeyInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.setApiKey();
                        }
                    });
                }
                
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.addEventListener('click', () => this.setApiKey());
                }
                
                if (this.testApiBtn) {
                    this.testApiBtn.addEventListener('click', () => this.testApiCall());
                }
                


                if (this.autoGenToggleBtn) {
                    this.autoGenToggleBtn.addEventListener('click', () => this.toggleAutoGeneration());
                }

                if (this.apiCallsToggleBtn) {
                    this.apiCallsToggleBtn.addEventListener('click', () => this.toggleApiCalls());
                }

                if (this.testPanBtn) {
                    this.testPanBtn.addEventListener('click', () => this.testPan());
                }

                if (this.zoomOutMaxBtn) {
                    this.zoomOutMaxBtn.addEventListener('click', () => this.zoomOutMax());
                }
                
                if (this.imageOpacityBtn) {
                    this.imageOpacityBtn.addEventListener('click', () => this.toggleImageOpacity());
                }
                
                if (this.blockLayerBtn) {
                    this.blockLayerBtn.addEventListener('click', () => this.toggleBlockLayer());
                }
                
                // Debug preview close functionality removed (no close button)
                

                
                // Try to load API key from environment on startup
                this.initializeApiKey();
                
                // Set initial UI state for pre-configured API key
                this.updateInitialUIState();
                
                // Hide debug windows by default
                const debugInfo = document.getElementById('debugInfo');
                const consoleCapture = document.getElementById('consoleCapture');
                if (debugInfo && consoleCapture) {
                    debugInfo.style.display = 'none';
                    consoleCapture.style.display = 'none';
                }
                
                this.updateTransform();
                
                // Add resize handler to redraw grid
                window.addEventListener('resize', () => {
                    setTimeout(() => this.drawGrid(), 100);
                });
                
                // Add keyboard shortcut to toggle debug windows
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F12' || (e.ctrlKey && e.key === 'd')) {
                        e.preventDefault();
                        this.toggleDebug();
                    } else if (e.ctrlKey && (e.key === 'g' || e.key === 'G')) {
                        e.preventDefault();
                        this.toggleGrid();
                    }
                });
            }
            
            updateInitialUIState() {
                // Update API key input UI
                if (this.apiKey && this.apiKeyInput) {
                    this.apiKeyInput.placeholder = 'API Key Set ✓';
                    this.apiKeyInput.value = '';
                }
                
                if (this.setApiKeyBtn) {
                    this.setApiKeyBtn.textContent = 'Update';
                }
                
                // Live mode is always enabled
                
                console.log('🔑 API key pre-configured and live mode enabled');
            }
            
            setApiKey() {
                const apiKey = this.apiKeyInput.value.trim();
                if (apiKey) {
                    this.apiKey = apiKey;
                    this.apiKeyInput.value = '';
                    this.apiKeyInput.placeholder = 'API Key Set ✓';
                    this.setApiKeyBtn.textContent = 'Update';
                    
                    // Live mode is always enabled
                    
                    console.log('API key set successfully');
                } else {
                    alert('Please enter a valid API key');
                }
            }
            
            async testApiCall() {
                if (!this.apiKey) {
                    alert('Please set an API key first');
                    return;
                }

                if (!this.apiCallsEnabled) {
                    console.log('🚫 API calls disabled - creating grey loading block only');
                    this.testApiBtn.textContent = 'Test API';
                    this.testApiBtn.disabled = false;
                    
                    // Clear existing blocks first to test new sizing
                    this.outfillBlocks.clear();
                    const existingBlocks = document.querySelectorAll('[id^="outfill-"]');
                    existingBlocks.forEach(block => block.remove());
                    
                    // Create grey loading block for testing scaling
                    const testBlockKey = '1,0';
                    this.outfillBlocks.set(testBlockKey, { status: 'generating', progress: 0, imageData: null });
                    this.updateOutfillBlock(testBlockKey, this.outfillBlocks.get(testBlockKey));
                    console.log('🎯 Grey loading block created for scaling test');
                    return;
                }
                
                console.log('🧪 Testing API call...');
                this.testApiBtn.textContent = 'Testing...';
                this.testApiBtn.disabled = true;
                
                try {
                    // Manually trigger an outfill for testing (works regardless of auto-generation setting)
                    const testBlockKey = '1,0'; // Block to the right of the image (outside image bounds)
                    this.outfillBlocks.set(testBlockKey, { status: 'generating', progress: 0, imageData: null });
                    this.updateOutfillBlock(testBlockKey, this.outfillBlocks.get(testBlockKey));
                    
                    // Use the EXACT same code path as auto-filled blocks
                    const result = await this.generateOutfill(testBlockKey);
                    console.log('✅ API test successful!', result);
                    
                    // The debug preview is already shown by generateOutfill, just log success
                    console.log('🎯 Test API completed - check debug preview window for results');
                    
                } catch (error) {
                    console.error('❌ API test failed:', error);
                    
                    // Show error in debug preview window
                    this.showDebugError('API Test Failed', error.message);
                } finally {
                    this.testApiBtn.textContent = 'Test API';
                    this.testApiBtn.disabled = false;
                }
            }

            testPan() {
                console.log('🧪 Testing pan functionality...');
                
                // Pan the image to the right by 200px to expose left edge
                this.translateX += 200;
                this.updateTransform();
                this.checkVisibleBlocks();
                
                console.log('✅ Pan test completed - image moved right by 200px');
            }

            zoomOutMax() {
                console.log('🔍 Zooming out to maximum...');
                
                // Set scale to minimum (0.25x)
                this.scale = 0.25;
                this.updateTransform();
                this.checkVisibleBlocks();
                
                console.log('✅ Zoomed out to maximum scale: 0.25x');
            }
            
            async generateOutfill(blockKey) {
                console.log('🚀 Starting generateOutfill for block:', blockKey);
                
                if (!this.apiKey) {
                    throw new Error('No API key set');
                }
                
                try {
                    // 🌀 BREAKTHROUGH: Use composite sampling instead of original image
                    const imageBlob = await this.getCompositeImageForBlock(blockKey);
                    console.log('🌀 Composite image blob size:', imageBlob.size, 'bytes');
                    
                    // Generate mask for the block
                    const maskBlob = await this.generateMaskForBlock(blockKey);
                    console.log('🎭 Mask blob size:', maskBlob.size, 'bytes');
                    
                    // Prepare form data
                    const formData = new FormData();
                    formData.append('image', imageBlob, 'image.jpg');
                    
                    // Always add mask - required by Stability AI outpaint API
                    formData.append('mask', maskBlob, 'mask.png');
                    console.log('🎭 Adding mask for outpaint (required by API)');
                    
                    formData.append('prompt', this.config.prompt);
                    formData.append('output_format', this.config.output_format);
                    formData.append('creativity', this.config.creativity.toString());
                    
                    // Add outpaint directions based on block position
                    const { directionX, directionY, gridX, gridY } = this.getOutpaintDirections(blockKey);
                    const blockSizeX = Math.round(this.imageWidth / this.blockDivisions);
                    const blockSizeY = Math.round(this.imageHeight / this.blockDivisions);
                    
                    console.log(`🎯 Block ${blockKey} outpaint directions: directionX=${directionX}, directionY=${directionY} (${blockSizeX}x${blockSizeY}px)`);
                    
                    // Add direction-based outpaint parameters
                    if (directionX > 0) {
                        formData.append('right', blockSizeX.toString());
                    } else if (directionX < 0) {
                        formData.append('left', blockSizeX.toString());
                    }
                    
                    if (directionY > 0) {
                        formData.append('down', blockSizeY.toString());
                    } else if (directionY < 0) {
                        formData.append('up', blockSizeY.toString());
                    }
                    
                    if (this.config.seed) {
                        formData.append('seed', this.config.seed.toString());
                    }
                    
                    console.log('📤 Sending API request to:', this.config.endpoint);
                    
                    // Log detailed FormData contents
                    console.log('📤 Request FormData contents:');
                    for (let [key, value] of formData.entries()) {
                        if (value instanceof File || value instanceof Blob) {
                            console.log(`  ${key}: ${value.constructor.name} (${value.size} bytes, type: ${value.type})`);
                        } else {
                            console.log(`  ${key}: ${JSON.stringify(value)}`);
                        }
                    }
                    
                    // Build request summary with actual directions being sent
                    const requestSummary = {
                        prompt: this.config.prompt,
                        output_format: this.config.output_format,
                        creativity: this.config.creativity,
                        seed: this.config.seed,
                        imageSize: imageBlob.size,
                        maskSize: maskBlob.size
                    };
                    
                    // Add the actual outpaint directions being sent
                    if (directionX > 0) {
                        requestSummary['right'] = blockSizeX.toString();
                    } else if (directionX < 0) {
                        requestSummary['left'] = blockSizeX.toString();
                    }
                    
                    if (directionY > 0) {
                        requestSummary['down'] = blockSizeY.toString();
                    } else if (directionY < 0) {
                        requestSummary['up'] = blockSizeY.toString();
                    }
                    console.log('📤 Request parameters summary:', JSON.stringify(requestSummary, null, 2));
                    
                    // Make API call
                    const requestHeaders = {
                        'Authorization': `Bearer ${this.apiKey.substring(0, 10)}...${this.apiKey.substring(this.apiKey.length - 4)}`,
                        'Accept': 'image/*'
                    };
                    console.log('📤 Request headers:', JSON.stringify(requestHeaders, null, 2));
                    
                    // Log all FormData entries for debugging
                    console.log('📤 FormData entries:');
                    const formDataEntries = {};
                    for (let [key, value] of formData.entries()) {
                        if (value instanceof File || value instanceof Blob) {
                            console.log(`  ${key}: ${value.constructor.name} (${value.size} bytes, type: ${value.type})`);
                            formDataEntries[key] = `${value.constructor.name} (${value.size} bytes, type: ${value.type})`;
                        } else {
                            console.log(`  ${key}: ${value}`);
                            formDataEntries[key] = value;
                        }
                    }
                    console.log('📤 Complete FormData summary:', JSON.stringify(formDataEntries, null, 2));
                    
                    const response = await fetch(this.config.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Accept': 'image/*'
                        },
                        body: formData
                    });
                    
                    const responseHeaders = Object.fromEntries(response.headers.entries());
                    console.log('📥 API Response status:', response.status);
                    console.log('📥 API Response headers:', JSON.stringify(responseHeaders, null, 2));
                    console.log('📥 API Response content-type:', response.headers.get('content-type'));
                    console.log('📥 API Response content-length:', response.headers.get('content-length'));
                    
                    // Check response status and content type
                    const contentType = response.headers.get('content-type');
                    console.log('📥 Response status:', response.status, response.statusText);
                    console.log('📥 Response ok:', response.ok);
                    
                    if (!response.ok) {
                        // Handle error responses - read as text to get error details
                        try {
                            const errorText = await response.text();
                            console.error('🚨 API Error Response (raw):', errorText);
                            
                            // Try to parse as JSON for better error details
                            let errorMessage = `API Error (${response.status}): `;
                            try {
                                const errorJson = JSON.parse(errorText);
                                console.error('🚨 API Error Response (parsed):', JSON.stringify(errorJson, null, 2));
                                if (errorJson.errors && Array.isArray(errorJson.errors)) {
                                    errorMessage += errorJson.errors.join(', ');
                                } else if (errorJson.error) {
                                    errorMessage += errorJson.error;
                                } else {
                                    errorMessage += errorText;
                                }
                            } catch (parseError) {
                                console.error('🚨 Could not parse error as JSON:', parseError);
                                errorMessage += errorText;
                            }
                            throw new Error(errorMessage);
                        } catch (textError) {
                            console.error('🚨 Could not read error response:', textError);
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                    }
                    
                    // Check if successful response is JSON (unexpected for image generation)
                    if (contentType && contentType.includes('application/json')) {
                        const jsonResponse = await response.json();
                        console.log('📥 API JSON Response (unexpected success):', JSON.stringify(jsonResponse, null, 2));
                        throw new Error(`API returned JSON instead of image: ${JSON.stringify(jsonResponse)}`);
                    }
                    
                    // Get the generated image (successful image response)
                    const imageBlob2 = await response.blob();
                    console.log('✅ API Response successful!');
                    const blobDetails = {
                        size: imageBlob2.size,
                        type: imageBlob2.type,
                        sizeKB: Math.round(imageBlob2.size / 1024),
                        sizeMB: Math.round(imageBlob2.size / 1024 / 1024 * 100) / 100
                    };
                    console.log('✅ Generated image blob details:', JSON.stringify(blobDetails, null, 2));
                    
                    // Save debug blob to file and show preview if debug mode is enabled
                    this.saveDebugBlob(imageBlob2, blockKey, 'stability-ai-outpaint');
                    this.showDebugPreview(imageBlob2, blockKey, 'Stability AI Outpaint');
                    
                    // Convert to data URL for display
                    const imageUrl = URL.createObjectURL(imageBlob2);
                    console.log('✅ Generated image URL:', imageUrl);
                    
                    // Get image dimensions and adjust block positioning
                    const img = new Image();
                    img.onload = () => {
                        const generatedDimensions = {
                            width: img.width,
                            height: img.height,
                            aspectRatio: Math.round(img.width / img.height * 100) / 100
                        };
                        console.log('📏 Generated image dimensions:', generatedDimensions);
                        
                        // Adjust block positioning based on actual returned image dimensions
                        // Block positioning is now handled by positionOutpaintBackground
                    };
                    img.src = imageUrl;
                    
                    // Update the outfill block with the generated image
                    const block = this.outfillBlocks.get(blockKey);
                    console.log('🔍 Block lookup for', blockKey, ':', block ? 'found' : 'NOT FOUND');
                    if (block) {
                        console.log('🔍 Block before update:', JSON.stringify(block, null, 2));
                        block.status = 'completed';
                        block.imageData = imageUrl;
                        console.log('🔍 About to call updateOutfillBlock with:', blockKey, block.status, block.imageData ? 'imageData present' : 'NO imageData');
                        this.updateOutfillBlock(blockKey, block);
                        console.log('✅ Block', blockKey, 'generation completed');
                        
                        // 🌀 SPIRAL SYSTEM: No need for adjacent block detection, spiral handles order
                        // this.checkForNewlyAdjacentBlocks(blockKey); // DISABLED
                    } else {
                        console.error('❌ Block not found in outfillBlocks map for key:', blockKey);
                        console.log('🔍 Current outfillBlocks keys:', Array.from(this.outfillBlocks.keys()));
                    }
                    
                    return {
                        imageUrl,
                        blockKey,
                        size: imageBlob2.size
                    };
                    
                } catch (error) {
                    console.error('❌ generateOutfill error:', error);
                    throw error;
                }
            }
            
            async getImageAsBlob() {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = this.image;
                    
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create image blob'));
                        }
                    }, 'image/jpeg', 0.9);
                });
            }
            
            // 🌀 BREAKTHROUGH: Sample composite image for next generation
            async getCompositeImageForBlock(blockKey) {
                console.log(`🌀 Sampling composite image for block ${blockKey}...`);
                
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas to image size (1 block size)
                    canvas.width = this.imageWidth;
                    canvas.height = this.imageHeight;
                    
                    // Get the block position to determine what adjacent area to sample
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    
                    // Calculate the source area to sample from the composite
                    // This should be the adjacent block that will be used as input
                    let sourceGridX, sourceGridY;
                    
                    // Determine which adjacent block to sample based on direction
                    if (gridX > 0) {
                        // Extending right, sample from left adjacent block
                        sourceGridX = gridX - 1;
                        sourceGridY = gridY;
                    } else if (gridX < 0) {
                        // Extending left, sample from right adjacent block  
                        sourceGridX = gridX + 1;
                        sourceGridY = gridY;
                    } else if (gridY > 0) {
                        // Extending down, sample from up adjacent block
                        sourceGridX = gridX;
                        sourceGridY = gridY - 1;
                    } else if (gridY < 0) {
                        // Extending up, sample from down adjacent block
                        sourceGridX = gridX;
                        sourceGridY = gridY + 1;
                    } else {
                        // This shouldn't happen for outfill blocks
                        console.error('🚨 Invalid block position for outfill:', blockKey);
                        sourceGridX = 0;
                        sourceGridY = 0;
                    }
                    
                    console.log(`🌀 Block ${blockKey} will sample from adjacent block (${sourceGridX},${sourceGridY})`);
                    
                    // Sample the appropriate area from the current composite
                    if (sourceGridX === 0 && sourceGridY === 0) {
                        // Sample from original image
                        ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
                        console.log(`🌀 Sampled original image for block ${blockKey}`);
                    } else {
                        // Sample from existing outfill block
                        const sourceBlockKey = `${sourceGridX},${sourceGridY}`;
                        const sourceBlock = this.outfillBlocks.get(sourceBlockKey);
                        
                        if (sourceBlock && sourceBlock.imageData && sourceBlock.status === 'completed') {
                            // Create temporary image to sample from
                            const tempImg = new Image();
                            tempImg.onload = () => {
                                // The source block image is 2x2 (2*imageWidth x 2*imageHeight)
                                // We need to extract the portion that will be adjacent to the new block
                                const sourceWidth = tempImg.width;
                                const sourceHeight = tempImg.height;
                                
                                // Calculate which quadrant to sample based on direction
                                let sampleX, sampleY;
                                const quadrantWidth = sourceWidth / 2;
                                const quadrantHeight = sourceHeight / 2;
                                
                                // Determine sampling quadrant based on relative position
                                if (gridX > sourceGridX) {
                                    // New block is to the right, sample right edge of source
                                    sampleX = quadrantWidth; // Right half
                                } else if (gridX < sourceGridX) {
                                    // New block is to the left, sample left edge of source
                                    sampleX = 0; // Left half
                                } else {
                                    // Same X, sample center
                                    sampleX = quadrantWidth / 2;
                                }
                                
                                if (gridY > sourceGridY) {
                                    // New block is below, sample bottom edge of source
                                    sampleY = quadrantHeight; // Bottom half
                                } else if (gridY < sourceGridY) {
                                    // New block is above, sample top edge of source
                                    sampleY = 0; // Top half
                                } else {
                                    // Same Y, sample center
                                    sampleY = quadrantHeight / 2;
                                }
                                
                                const sampleWidth = quadrantWidth;
                                const sampleHeight = quadrantHeight;
                                
                                ctx.drawImage(tempImg, 
                                    sampleX, sampleY, sampleWidth, sampleHeight,
                                    0, 0, this.imageWidth, this.imageHeight
                                );
                                
                                console.log(`🌀 Sampled from block ${sourceBlockKey} for block ${blockKey}`);
                                
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        resolve(blob);
                                    } else {
                                        reject(new Error('Failed to create composite image blob'));
                                    }
                                }, 'image/jpeg', 0.9);
                            };
                            tempImg.onerror = () => {
                                console.error(`🚨 Failed to load source block image for ${sourceBlockKey}`);
                                // Fallback to original image
                                ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
                                canvas.toBlob(resolve, 'image/jpeg', 0.9);
                            };
                            tempImg.src = sourceBlock.imageData;
                        } else {
                            console.warn(`🚨 Source block ${sourceBlockKey} not available, using original image`);
                            // Fallback to original image
                            ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Failed to create fallback image blob'));
                                }
                            }, 'image/jpeg', 0.9);
                        }
                    }
                });
            }
            
            async initializeApiKey() {
                try {
                    // Try to get API key from environment variable
//                    const response = await fetch('/api/config');
//                    const config = await response.json();
                    
                    if (config.apiKey) {
                        this.apiKey = "sk-khSJsDLcgZd4LxCCRoylXQhiZmPwbAWfdiKCuZ71YzkoJvm8"; //config.apiKey;
                        this.apiKeyInput.placeholder = 'API Key Set ✓';
                        this.setApiKeyBtn.textContent = 'Update';
                        console.log('API key loaded from environment variable');
                        // Live mode is always enabled
                    }
                } catch (error) {
                    console.error('Failed to fetch API config:', error);
                }
            }
            

            
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.content.style.transition = 'none';
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastX;
                const deltaY = e.clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                console.log('🖱️ Mouse move:', { deltaX, deltaY, translateX: this.translateX, translateY: this.translateY });
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateTransform();
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.viewer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const mouseX = e.clientX - centerX;
                const mouseY = e.clientY - centerY;
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * delta));
                
                if (newScale !== this.scale) {
                    const scaleDiff = newScale / this.scale;
                    
                    this.translateX = mouseX - (mouseX - this.translateX) * scaleDiff;
                    this.translateY = mouseY - (mouseY - this.translateY) * scaleDiff;
                    
                    console.log('🔍 Wheel zoom:', { newScale, translateX: this.translateX, translateY: this.translateY });
                    
                    this.scale = newScale;
                    this.updateTransform();
                }
            }
            
            handleTouchStart(e) {
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    this.content.style.transition = 'none';
                }
                e.preventDefault();
            }
            
            handleTouchMove(e) {
                if (!this.isDragging || e.touches.length !== 1) return;
                
                const deltaX = e.touches[0].clientX - this.lastX;
                const deltaY = e.touches[0].clientY - this.lastY;
                
                this.translateX += deltaX;
                this.translateY += deltaY;
                
                this.lastX = e.touches[0].clientX;
                this.lastY = e.touches[0].clientY;
                
                this.updateTransform();
                e.preventDefault();
            }
            
            handleTouchEnd() {
                this.isDragging = false;
                this.content.style.transition = 'transform 0.1s ease-out';
            }
            
            getVisibleBlocks() {
                if (!this.containerWidth || !this.containerHeight || !this.imageWidth || !this.imageHeight) {
                    return new Set();
                }

                const visibleBlocks = new Set();
                
                // BLOCK SYSTEM: Each block is exactly the original image size
                const blockWidth = this.imageWidth;
                const blockHeight = this.imageHeight;

                // Calculate viewport bounds in world coordinates
                // Original image is at world position (0,0) to (imageWidth, imageHeight)
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + this.containerWidth / this.scale;
                const viewportBottom = viewportTop + this.containerHeight / this.scale;

                // Calculate which blocks are visible
                const leftmostBlock = Math.floor(viewportLeft / blockWidth);
                const rightmostBlock = Math.ceil(viewportRight / blockWidth);
                const topmostBlock = Math.floor(viewportTop / blockHeight);
                const bottommostBlock = Math.ceil(viewportBottom / blockHeight);

                // Add all visible blocks (including original at 0,0)
                for (let x = leftmostBlock; x < rightmostBlock; x++) {
                    for (let y = topmostBlock; y < bottommostBlock; y++) {
                        visibleBlocks.add(`${x},${y}`);
                    }
                }

                return visibleBlocks;
            }
            
            updateGridSize() {
                this.drawGrid();
            }
            
            drawGrid() {
                // GRID ALIGNMENT: Grid lines should align with actual image boundaries
                // Need to account for how the image is positioned within the container
                
                const canvas = document.getElementById('gridCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Exit early if grid is not visible
                if (!this.gridVisible) return;
                
                // Block dimensions (each block = full image size)
                const blockWidth = this.imageWidth || 1600;   // 1600px
                const blockHeight = this.imageHeight || 1024; // 1024px
                
                // Calculate where the actual image is positioned within the container
                // The image uses object-fit: contain, so it's centered and scaled to fit
                const containerWidth = this.containerWidth;
                const containerHeight = this.containerHeight;
                const imageAspect = blockWidth / blockHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let actualImageWidth, actualImageHeight, imageOffsetX, imageOffsetY;
                
                if (imageAspect > containerAspect) {
                    // Image is wider - fits to container width
                    actualImageWidth = containerWidth;
                    actualImageHeight = containerWidth / imageAspect;
                    imageOffsetX = 0;
                    imageOffsetY = (containerHeight - actualImageHeight) / 2;
                } else {
                    // Image is taller - fits to container height
                    actualImageWidth = containerHeight * imageAspect;
                    actualImageHeight = containerHeight;
                    imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    imageOffsetY = 0;
                }
                
                console.log(`🔍 IMAGE POSITIONING: container=${containerWidth}x${containerHeight}, actual=${actualImageWidth}x${actualImageHeight}, offset=(${imageOffsetX},${imageOffsetY})`);
                
                // Set grid line style
                ctx.strokeStyle = 'rgba(255, 255, 255, 1.0)';
                ctx.lineWidth = 1;
                
                // Draw complete infinite grid with image boundaries as reference
                // Image occupies one grid cell, bounded by grid lines
                
                // Calculate the center of the container (where image is positioned before transform)
                const containerCenterX = canvas.width / 2;
                const containerCenterY = canvas.height / 2;
                
                // Calculate where the top-left corner of the actual image appears
                // Image is centered, so top-left is at center minus half the scaled image size
                const scaledImageWidth = actualImageWidth * this.scale;
                const scaledImageHeight = actualImageHeight * this.scale;
                
                const imageTopLeftX = containerCenterX - (scaledImageWidth / 2) + this.translateX;
                const imageTopLeftY = containerCenterY - (scaledImageHeight / 2) + this.translateY;
                
                // Grid spacing equals scaled image dimensions
                const gridSpacingX = scaledImageWidth;
                const gridSpacingY = scaledImageHeight;
                
                // Draw vertical grid lines extending infinitely
                for (let i = -50; i <= 50; i++) {
                    const lineX = imageTopLeftX + (i * gridSpacingX);
                    
                    // Only draw lines that could be visible
                    if (lineX >= -canvas.width && lineX <= canvas.width * 2) {
                        ctx.beginPath();
                        ctx.moveTo(lineX, 0);
                        ctx.lineTo(lineX, canvas.height);
                        ctx.stroke();
                    }
                }
                
                // Draw horizontal grid lines extending infinitely
                for (let i = -50; i <= 50; i++) {
                    const lineY = imageTopLeftY + (i * gridSpacingY);
                    
                    // Only draw lines that could be visible
                    if (lineY >= -canvas.height && lineY <= canvas.height * 2) {
                        ctx.beginPath();
                        ctx.moveTo(0, lineY);
                        ctx.lineTo(canvas.width, lineY);
                        ctx.stroke();
                    }
                }
                
                console.log(`🔍 INFINITE GRID: topLeft=(${imageTopLeftX},${imageTopLeftY}), spacing=(${gridSpacingX},${gridSpacingY}), scale=${this.scale}`);
            }
            
            async simulateGeneration(blockKey) {
                // Always try API generation - no more demo mode
                if (this.apiKey) {
                    return this.generateWithAPI(blockKey);
                } else {
                    // Show "not connected" overlay and log the issue
                    console.log(`⚠️ Block ${blockKey}: API key not available, showing not connected overlay`);
                    this.showNotConnectedOverlay(blockKey);
                    return { success: false, error: 'No API key available' };
                }
            }

            showNotConnectedOverlay(blockKey) {
                const block = this.outfillBlocks.get(blockKey);
                if (block) {
                    block.status = 'not-connected';
                    this.updateOutfillBlock(blockKey, block);
                }
            }





            async generateWithAPI(blockKey) {
                try {
                    // Update progress to show API call in progress
                    const block = this.outfillBlocks.get(blockKey);
                    if (block) {
                        block.progress = 0.1;
                        this.updateOutfillBlock(blockKey, block);
                    }

                    console.log(`🚀 Starting API generation for block ${blockKey}`);
                    
                    // Call Stability AI API - this now handles multi-block responses internally
                    await this.callStabilityAPI(blockKey);
                    
                    console.log(`✅ API generation completed for block ${blockKey} and adjacent blocks`);
                    
                } catch (error) {
                    console.error('API generation failed:', error);
                    
                    // Mark as failed
                    this.outfillBlocks.set(blockKey, { 
                        status: 'failed', 
                        progress: 0, 
                        error: error.message 
                    });
                    this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                    
                    // Show error to user
                    alert(`Generation failed: ${error.message}`);
                }
            }

            blobToDataUrl(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // Debug function to save blob to file
            saveDebugBlob(blob, blockKey, description = 'api-response') {

                
                try {
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const filename = `${description}_block-${blockKey}_${timestamp}.${blob.type.split('/')[1] || 'jpg'}`;
                    
                    // Create download link - COMMENTED OUT
                    // const url = URL.createObjectURL(blob);
                    // const a = document.createElement('a');
                    // a.href = url;
                    // a.download = filename;
                    // a.style.display = 'none';
                    
                    // // Trigger download
                    // document.body.appendChild(a);
                    // a.click();
                    // document.body.removeChild(a);
                    
                    // // Clean up URL
                    // setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    console.log('🐛 DEBUG: Saved blob to file:', filename, {
                        size: blob.size,
                        type: blob.type,
                        sizeKB: Math.round(blob.size / 1024)
                    });
                } catch (error) {
                    console.error('❌ Failed to save debug blob:', error);
                }
            }

            // Toggle debug windows and indicators
            toggleDebug() {
                const debugInfo = document.getElementById('debugInfo');
                const consoleCapture = document.getElementById('consoleCapture');

                if (debugInfo && consoleCapture) {
                    const isVisible = debugInfo.style.display !== 'none';
                    const newDisplay = isVisible ? 'none' : 'block';

                    debugInfo.style.display = newDisplay;
                    consoleCapture.style.display = newDisplay;

                    // Toggle zoom indicator only (queue indicator stays always visible)
                    if (this.zoomIndicator) {
                        this.zoomIndicator.style.display = newDisplay;
                    }

                    // Toggle debug preview window visibility (show/hide with debug mode)
                    if (this.debugPreview) {
                        if (newDisplay === 'block') {
                            // Show debug preview window when debug mode is enabled
                            this.debugPreview.classList.add('visible');
                            // Show placeholder or keep image hidden until content loads
                            if (!this.debugPreviewImage.src || this.debugPreviewImage.src === '') {
                                this.debugPreviewImage.style.display = 'none';
                            }
                        } else {
                            // Hide debug preview window when debug mode is disabled
                            this.debugPreview.classList.remove('visible');
                        }
                    }

                    console.log(`🔧 Debug windows ${isVisible ? 'hidden' : 'shown'} (F12 or Ctrl+D to toggle)`);
                }
            }

            // Toggle grid visibility
            toggleGrid() {
                this.gridVisible = !this.gridVisible;
                this.drawGrid(); // Redraw grid with new visibility state
                console.log(`🔧 Grid ${this.gridVisible ? 'shown' : 'hidden'} (Ctrl+G to toggle)`);
            }

            // Toggle auto-generation mode
            toggleAutoGeneration() {
                this.autoGenerateBlocks = !this.autoGenerateBlocks;

                if (this.autoGenToggleBtn) {
                    this.autoGenToggleBtn.textContent = this.autoGenerateBlocks ? 'Auto-Gen: ON' : 'Auto-Gen: OFF';
                    this.autoGenToggleBtn.style.background = this.autoGenerateBlocks ? '#4CAF50' : '#757575';
                }

                console.log('🔄 Auto-generation:', this.autoGenerateBlocks ? 'ENABLED' : 'DISABLED');
                console.log('🔄 Blocks will', this.autoGenerateBlocks ? 'be automatically added when visible' : 'NOT be automatically added (manual only)');
            }

            // Toggle API calls
            toggleApiCalls() {
                this.apiCallsEnabled = !this.apiCallsEnabled;

                if (this.apiCallsToggleBtn) {
                    this.apiCallsToggleBtn.textContent = this.apiCallsEnabled ? 'API: ON' : 'API: OFF';
                    this.apiCallsToggleBtn.style.background = this.apiCallsEnabled ? '#4CAF50' : '#757575';
                }

                console.log('🔄 API calls:', this.apiCallsEnabled ? 'ENABLED' : 'DISABLED');
                console.log('🔄 Blocks will', this.apiCallsEnabled ? 'make real API calls' : 'show grey loading blocks only');
            }
            
            // Toggle image opacity
            toggleImageOpacity() {
                this.imageTranslucent = !this.imageTranslucent;
                
                if (this.imageOpacityBtn) {
                    this.imageOpacityBtn.textContent = this.imageTranslucent ? 'Image: 50%' : 'Image: 100%';
                    this.imageOpacityBtn.style.background = this.imageTranslucent ? '#4CAF50' : '#757575';
                }
                
                // Apply opacity to main image
                if (this.image) {
                    this.image.style.opacity = this.imageTranslucent ? '0.5' : '1.0';
                }
                
                console.log('🔄 Image opacity:', this.imageTranslucent ? '50%' : '100%');
            }
            
            // Toggle block layer (under/over image)
            toggleBlockLayer() {
                this.blocksOverImage = !this.blocksOverImage;
                
                if (this.blockLayerBtn) {
                    this.blockLayerBtn.textContent = this.blocksOverImage ? 'Blocks: Over' : 'Blocks: Under';
                    this.blockLayerBtn.style.background = this.blocksOverImage ? '#4CAF50' : '#757575';
                }
                
                // Update z-index of all existing outfill blocks
                const existingBlocks = document.querySelectorAll('[id^="outfill-"]');
                existingBlocks.forEach(block => {
                    block.style.zIndex = this.blocksOverImage ? '4' : '2';
                });
                
                console.log('🔄 Block layer:', this.blocksOverImage ? 'OVER image' : 'UNDER image');
            }
            // Show 2x2 composite preview (2x2 response positioned over original image)
            async show2x2CompositePreview(responseBlob, sourceBlock, directionX, directionY, targetBlockKey) {
                if (!this.debugPreview) return;

                try {
                    console.log(`🖼️ Showing 2x2 response preview: source=${sourceBlock}, direction=(${directionX},${directionY})`);
                    
                    // Simply show the response blob directly to avoid canvas tainting issues
                    this.showDebugPreview(responseBlob, targetBlockKey, `2x2 Response (${directionX},${directionY})`);
                    
                } catch (error) {
                    console.error('❌ Error in show2x2CompositePreview:', error);
                    // Fallback to regular preview
                    this.showDebugPreview(responseBlob, targetBlockKey, '2x2 Response (fallback)');
                }
            }

            // Show debug preview with blob
            showDebugPreview(blob, blockKey, description = 'api-response') {
                if (!this.debugPreview) return;
                
                try {
                    // Create object URL for the blob
                    const imageUrl = URL.createObjectURL(blob);
                    
                    // Load image to get dimensions and resize window
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        // Scale down large images to reasonable preview size
                        const maxWidth = 400;
                        const maxHeight = 300;
                        let width = tempImg.width;
                        let height = tempImg.height;
                        
                        console.log(`🐛 DEBUG PREVIEW: Original image dimensions: ${width}x${height}, aspect ratio: ${(width/height).toFixed(3)}`);
                        
                        // Scale down if too large
                        if (width > maxWidth || height > maxHeight) {
                            const scaleX = maxWidth / width;
                            const scaleY = maxHeight / height;
                            const scale = Math.min(scaleX, scaleY);
                            width = Math.round(width * scale);
                            height = Math.round(height * scale);
                        }
                        
                        console.log(`🐛 DEBUG PREVIEW: Scaled dimensions: ${width}x${height}, aspect ratio: ${(width/height).toFixed(3)}`);
                        
                        // Resize debug preview window to scaled dimensions
                        this.debugPreview.style.width = width + 'px';
                        this.debugPreview.style.height = height + 'px';
                        
                        // Ensure left and bottom positioning
                        this.debugPreview.style.left = '0px';
                        this.debugPreview.style.bottom = '0px';
                        
                        // Update preview content - just show the image
                        this.debugPreviewImage.src = imageUrl;
                        this.debugPreviewImage.style.display = 'block';
                        
                        // Show the preview window
                        this.debugPreview.classList.add('visible');
                    };
                    tempImg.src = imageUrl;
                    
                    // Clean up the URL after a delay
                    setTimeout(() => {
                        URL.revokeObjectURL(imageUrl);
                    }, 30000); // Keep for 30 seconds
                    
                    console.log('🐛 DEBUG: Preview window updated with blob:', {
                        size: blob.size,
                        type: blob.type,
                        blockKey: blockKey,
                        description: description
                    });
                } catch (error) {
                    console.error('❌ Failed to show debug preview:', error);
                }
            }

            // Hide debug preview
            hideDebugPreview() {
                if (this.debugPreview) {
                    this.debugPreview.classList.remove('visible');
                    
                    // Clear the image source to free memory
                    if (this.debugPreviewImage) {
                        this.debugPreviewImage.src = '';
                    }
                }
            }
            
            showDebugError(title, errorMessage) {
                if (!this.debugPreview) return;
                
                // For simplified debug preview, just hide the image on error
                this.debugPreview.classList.add('visible');
                this.debugPreviewImage.style.display = 'none';
                console.error(`❌ ${title}: ${errorMessage}`);
            }
            
            updateOutfillBlock(blockKey, block) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // BLOCK SYSTEM: Each block is exactly the original image size
                const blockWidth = this.imageWidth;   // 1600px
                const blockHeight = this.imageHeight; // 1024px
                
                // Calculate where the original image is positioned within the container
                // The image uses object-fit: contain, so it's centered and scaled to fit
                const containerWidth = this.containerWidth;
                const containerHeight = this.containerHeight;
                const imageAspect = blockWidth / blockHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let actualImageWidth, actualImageHeight, imageOffsetX, imageOffsetY;
                
                if (imageAspect > containerAspect) {
                    // Image is wider - fits to container width
                    actualImageWidth = containerWidth;
                    actualImageHeight = containerWidth / imageAspect;
                    imageOffsetX = 0;
                    imageOffsetY = (containerHeight - actualImageHeight) / 2;
                } else {
                    // Image is taller - fits to container height
                    actualImageWidth = containerHeight * imageAspect;
                    actualImageHeight = containerHeight;
                    imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    imageOffsetY = 0;
                }
                
                // Calculate block position relative to the original image position
                // IMPORTANT: Blocks must be positioned relative to the UNTRANSFORMED image
                // because they are children of this.content which gets the CSS transform applied
                const blockLeft = imageOffsetX + (gridX * actualImageWidth);
                const blockTop = imageOffsetY + (gridY * actualImageHeight);
                
                let blockElement = document.getElementById(`outfill-${blockKey}`);
                if (!blockElement) {
                    blockElement = document.createElement('div');
                    blockElement.id = `outfill-${blockKey}`;
                    blockElement.style.position = 'absolute';
                    blockElement.style.zIndex = this.blocksOverImage ? '4' : '2';
                    this.content.appendChild(blockElement);
                }
                
                // Position block to align with grid (relative to untransformed coordinates)
                // The CSS transform on this.content will handle scaling and translation
                blockElement.style.left = blockLeft + 'px';
                blockElement.style.top = blockTop + 'px';
                blockElement.style.width = actualImageWidth + 'px';
                blockElement.style.height = actualImageHeight + 'px';
                
                console.log(`🔧 Block ${blockKey} positioning: left=${blockLeft}px, top=${blockTop}px, width=${actualImageWidth}px, height=${actualImageHeight}px`);
                
                if (block.status === 'ready' || block.status === 'completed') {
                    console.log('🖼️ Setting block image:', blockKey, 'imageData:', block.imageData.substring(0, 50) + '...');
                    blockElement.style.backgroundImage = `url(${block.imageData})`;
                    blockElement.style.backgroundRepeat = 'no-repeat';
                    blockElement.style.backgroundColor = 'transparent';
                    blockElement.innerHTML = '';
                    
                    // SEAMLESS FIX: The extracted block image is already the correct size (blockSizeX x blockSizeY)
                    // We need to scale it to match the current container-fitted dimensions
                    // This maintains the aspect ratio and ensures seamless alignment
                    blockElement.style.backgroundSize = `${actualImageWidth}px ${actualImageHeight}px`;
                    blockElement.style.backgroundPosition = '0px 0px';
                    
                    console.log('🖼️ Block element updated with proper scaling:', blockElement.id, `extracted->display: ${this.imageWidth}x${this.imageHeight}->${actualImageWidth}x${actualImageHeight}`);
                } else if (block.status === 'generating') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                    const progressPercent = Math.round(block.progress * 100);
                    const circumference = 2 * Math.PI * 20; // radius = 20
                    const strokeDashoffset = circumference - (block.progress * circumference);
                    
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 50px;
                            height: 50px;
                        ">
                            <svg width="50" height="50" style="transform: rotate(-90deg);">
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(255, 255, 255, 0.2)" 
                                    stroke-width="3"/>
                                <circle cx="25" cy="25" r="20" 
                                    fill="none" 
                                    stroke="rgba(0, 255, 255, 0.8)" 
                                    stroke-width="3"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${strokeDashoffset}"
                                    stroke-linecap="round"
                                    style="transition: stroke-dashoffset 0.2s ease;"/>
                            </svg>
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                color: rgba(255, 255, 255, 0.9);
                                font-size: 10px;
                                font-weight: bold;
                                text-align: center;
                            ">${progressPercent}%</div>
                        </div>
                    `;
                } else if (block.status === 'queued') {
                    blockElement.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.6);
                            font-size: 12px;
                            text-align: center;
                        ">⏳</div>
                    `;
                } else if (block.status === 'failed') {
                    blockElement.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.9);
                            font-size: 12px;
                            text-align: center;
                        ">❌</div>
                    `;
                } else if (block.status === 'not-connected') {
                    blockElement.style.backgroundColor = 'rgba(255, 165, 0, 0.3)';
                    blockElement.innerHTML = `
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            color: rgba(255, 255, 255, 0.9);
                            font-size: 10px;
                            text-align: center;
                            line-height: 1.2;
                        ">🔌<br>No API</div>
                    `;
                }
            }
            
            isBlockAdjacentToContent(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // Check if block is adjacent to the original image at (0,0) or any completed blocks
                const adjacentPositions = [
                    [gridX - 1, gridY],     // Left
                    [gridX + 1, gridY],     // Right
                    [gridX, gridY - 1],     // Top
                    [gridX, gridY + 1],     // Bottom
                    [gridX - 1, gridY - 1], // Top-left
                    [gridX + 1, gridY - 1], // Top-right
                    [gridX - 1, gridY + 1], // Bottom-left
                    [gridX + 1, gridY + 1]  // Bottom-right
                ];
                
                for (const [adjX, adjY] of adjacentPositions) {
                    // Check if adjacent to original image at (0,0)
                    if (adjX === 0 && adjY === 0) {
                        return true;
                    }
                    
                    // Check if adjacent to any completed outfill block
                    const adjBlockKey = `${adjX},${adjY}`;
                    const adjBlock = this.outfillBlocks.get(adjBlockKey);
                    if (adjBlock && (adjBlock.status === 'ready' || adjBlock.status === 'completed')) {
                        return true;
                    }
                }
                
                return false;
            }
            
            checkForNewlyAdjacentBlocks(completedBlockKey) {
                const [completedX, completedY] = completedBlockKey.split(',').map(Number);
                
                // Check all positions adjacent to the completed block
                const adjacentPositions = [
                    [completedX - 1, completedY],     // Left
                    [completedX + 1, completedY],     // Right
                    [completedX, completedY - 1],     // Top
                    [completedX, completedY + 1],     // Bottom
                    [completedX - 1, completedY - 1], // Top-left
                    [completedX + 1, completedY - 1], // Top-right
                    [completedX - 1, completedY + 1], // Bottom-left
                    [completedX + 1, completedY + 1]  // Bottom-right
                ];
                
                const newlyAdjacentBlocks = [];
                
                for (const [adjX, adjY] of adjacentPositions) {
                    const adjBlockKey = `${adjX},${adjY}`;
                    
                    // Skip if this position is part of the original image
                    if (adjX >= 0 && adjX < this.blockDivisions && adjY >= 0 && adjY < this.blockDivisions) {
                        continue;
                    }
                    
                    // Skip if this block already exists in our system
                    if (this.outfillBlocks.has(adjBlockKey)) {
                        continue;
                    }
                    
                    // Check if this position is currently visible
                    const currentVisibleBlocks = this.getVisibleBlocks();
                    if (!currentVisibleBlocks.has(adjBlockKey)) {
                        continue;
                    }
                    
                    // This block is now adjacent to completed content and visible
                    newlyAdjacentBlocks.push(adjBlockKey);
                    console.log(`🆕 Found newly adjacent block: ${adjBlockKey} (adjacent to completed ${completedBlockKey})`);
                }
                
                // Add newly adjacent blocks to the system
                if (newlyAdjacentBlocks.length > 0 && this.autoGenerateBlocks) {
                    console.log('🚀 Adding newly adjacent blocks to queue:', newlyAdjacentBlocks);
                    
                    for (const blockKey of newlyAdjacentBlocks) {
                        this.outfillBlocks.set(blockKey, { status: 'queued', progress: 0, imageData: null });
                        this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                        this.generationQueue.push(blockKey);
                    }
                    
                    this.processGenerationQueue();
                }
            }

            isBlockAdjacentToOriginalImage(gridX, gridY) {
                // Original image occupies blocks from (0,0) to (blockDivisions-1, blockDivisions-1)
                const originalMinX = 0;
                const originalMaxX = this.blockDivisions - 1;
                const originalMinY = 0;
                const originalMaxY = this.blockDivisions - 1;
                
                // Check if block is directly adjacent to the original image bounds
                const isLeftAdjacent = gridX === originalMinX - 1 && gridY >= originalMinY && gridY <= originalMaxY;
                const isRightAdjacent = gridX === originalMaxX + 1 && gridY >= originalMinY && gridY <= originalMaxY;
                const isTopAdjacent = gridY === originalMinY - 1 && gridX >= originalMinX && gridX <= originalMaxX;
                const isBottomAdjacent = gridY === originalMaxY + 1 && gridX >= originalMinX && gridX <= originalMaxX;
                
                // Check corner adjacency
                const isTopLeftCorner = gridX === originalMinX - 1 && gridY === originalMinY - 1;
                const isTopRightCorner = gridX === originalMaxX + 1 && gridY === originalMinY - 1;
                const isBottomLeftCorner = gridX === originalMinX - 1 && gridY === originalMaxY + 1;
                const isBottomRightCorner = gridX === originalMaxX + 1 && gridY === originalMaxY + 1;
                
                return isLeftAdjacent || isRightAdjacent || isTopAdjacent || isBottomAdjacent ||
                       isTopLeftCorner || isTopRightCorner || isBottomLeftCorner || isBottomRightCorner;
            }

            checkVisibleBlocks() {
                const currentVisibleBlocks = this.getVisibleBlocks();
                
                // Update debug info
                this.debugInfo.innerHTML = `
                    <div>Image: ${this.imageWidth}x${this.imageHeight}</div>
                    <div>Container: ${this.containerWidth}x${this.containerHeight}</div>
                    <div>Transform: ${this.translateX.toFixed(1)}, ${this.translateY.toFixed(1)}</div>
                    <div>Scale: ${this.scale.toFixed(2)}</div>
                    <div>Visible Blocks: ${currentVisibleBlocks.size}</div>
                    <div>Queue: ${this.generationQueue.length}</div>
                    <div>Active: ${this.activeGenerations}</div>
                `;
                
                // 🌀 SPIRAL SYSTEM: Use spiral-based queue instead of priority-based
                if (this.autoGenerateBlocks) {
                    // Check if we need to queue more spiral blocks
                    if (this.generationQueue.length === 0 && this.activeGenerations === 0) {
                        console.log('🌀 Queue empty, checking for next spiral blocks...');
                        const queuedCount = this.queueVisibleSpiralBlocks();
                        
                        if (queuedCount > 0) {
                            this.processGenerationQueue();
                        }
                    }
                } else {
                    console.log('🔄 Auto-generation disabled - not adding spiral blocks automatically');
                }
                
                this.lastVisibleBlocks = currentVisibleBlocks;
            }
            
            calculateBlockPriority(blockKey) {
                const [x, y] = blockKey.split(',').map(Number);
                const blockSizeX = this.imageWidth / this.blockDivisions;
                const blockSizeY = this.imageHeight / this.blockDivisions;
                
                // Calculate block bounds in image coordinates
                const blockLeft = x * blockSizeX;
                const blockTop = y * blockSizeY;
                const blockRight = blockLeft + blockSizeX;
                const blockBottom = blockTop + blockSizeY;
                
                // Get current viewport bounds in image coordinates
                const viewportLeft = -this.translateX / this.scale;
                const viewportTop = -this.translateY / this.scale;
                const viewportRight = viewportLeft + (this.containerWidth / this.scale);
                const viewportBottom = viewportTop + (this.containerHeight / this.scale);
                
                // Calculate intersection
                const intersectLeft = Math.max(blockLeft, viewportLeft);
                const intersectTop = Math.max(blockTop, viewportTop);
                const intersectRight = Math.min(blockRight, viewportRight);
                const intersectBottom = Math.min(blockBottom, viewportBottom);
                
                // Calculate visibility percentage
                let visibilityPercentage = 0;
                if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
                    const intersectArea = (intersectRight - intersectLeft) * (intersectBottom - intersectTop);
                    const blockArea = blockSizeX * blockSizeY;
                    visibilityPercentage = intersectArea / blockArea;
                }
                
                // Calculate distance from original image center (prioritize blocks closer to original content)
                const originalCenterX = this.imageWidth / 2;
                const originalCenterY = this.imageHeight / 2;
                const blockCenterX = blockLeft + blockSizeX / 2;
                const blockCenterY = blockTop + blockSizeY / 2;
                const distanceFromOriginal = Math.sqrt(
                    Math.pow(blockCenterX - originalCenterX, 2) + 
                    Math.pow(blockCenterY - originalCenterY, 2)
                );
                
                // Calculate distance from viewport center
                const viewportCenterX = viewportLeft + (this.containerWidth / this.scale) / 2;
                const viewportCenterY = viewportTop + (this.containerHeight / this.scale) / 2;
                const distanceFromViewport = Math.sqrt(
                    Math.pow(blockCenterX - viewportCenterX, 2) + 
                    Math.pow(blockCenterY - viewportCenterY, 2)
                );
                
                // Normalize distances
                const maxDistance = Math.sqrt(
                    Math.pow(this.imageWidth * 2, 2) + Math.pow(this.imageHeight * 2, 2)
                );
                const normalizedDistanceFromOriginal = 1 - (distanceFromOriginal / maxDistance);
                const normalizedDistanceFromViewport = 1 - (distanceFromViewport / maxDistance);
                
                // Calculate priority score
                let priority = visibilityPercentage * 100; // Base score from visibility (0-100)
                priority += normalizedDistanceFromOriginal * 50; // Proximity to original content (0-50)
                priority += normalizedDistanceFromViewport * 20; // Proximity to viewport (0-20)
                
                // Bonus for fully visible blocks
                if (visibilityPercentage >= 0.99) {
                    priority += 30;
                }
                
                // Extra bonus for blocks directly adjacent to original image
                if (this.isBlockAdjacentToOriginalImage(x, y)) {
                    priority += 100; // High priority for first-ring outpaint
                }
                
                return priority;
            }

            updateGenerationQueue() {
                // Calculate priorities for all queued blocks
                const queuedBlocks = this.generationQueue.map(blockKey => ({
                    blockKey,
                    priority: this.calculateBlockPriority(blockKey)
                }));
                
                // Sort by priority (highest first)
                queuedBlocks.sort((a, b) => b.priority - a.priority);
                
                // Update the queue with sorted block keys
                this.generationQueue = queuedBlocks.map(item => item.blockKey);
                
                // Update queue indicator
                this.updateQueueIndicator();
            }

            // 🧩 3-BLOCK TRICK: Strategic Multi-Block Generation Functions
            
            findStrategicMultiBlockOpportunity() {
                if (this.generationQueue.length < 2) return null; // Need at least 2 blocks for efficiency
                
                // Look for diagonal blocks that can benefit from 3-block trick
                for (let i = 0; i < this.generationQueue.length; i++) {
                    const blockKey = this.generationQueue[i];
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    
                    // Check if this is a diagonal block (both X and Y non-zero)
                    if (gridX !== 0 && gridY !== 0) {
                        // Check if we can generate useful adjacent blocks
                        const strategicCall = this.calculateStrategicCall(blockKey);
                        if (strategicCall && this.isStrategicCallWorthwhile(strategicCall)) {
                            return strategicCall;
                        }
                    }
                }
                
                return null; // No strategic opportunity found
            }
            
            calculateStrategicCall(targetBlockKey) {
                const [targetX, targetY] = targetBlockKey.split(',').map(Number);
                
                // For diagonal block (1,1), we want to make a call that generates:
                // - The target block (1,1)
                // - Useful adjacent blocks like (1,0) and (0,1)
                
                // Strategy: Call from (0,0) with directions that include the target
                const strategicOrigin = '0,0'; // Always use original image as reference
                const directionX = targetX > 0 ? 1 : -1;
                const directionY = targetY > 0 ? 1 : -1;
                
                // Calculate which blocks this strategic call would generate
                const generatedBlocks = [
                    `${directionX > 0 ? 1 : -1},0`, // Horizontal adjacent
                    `0,${directionY > 0 ? 1 : -1}`, // Vertical adjacent  
                    `${directionX > 0 ? 1 : -1},${directionY > 0 ? 1 : -1}` // Diagonal target
                ];
                
                return {
                    originBlock: strategicOrigin,
                    directionX: directionX,
                    directionY: directionY,
                    targetBlock: targetBlockKey,
                    generatedBlocks: generatedBlocks
                };
            }
            
            isStrategicCallWorthwhile(strategicCall) {
                // Check how many of the generated blocks are actually needed
                let neededBlocks = 0;
                let queuedBlocks = [];
                
                strategicCall.generatedBlocks.forEach(blockKey => {
                    if (this.generationQueue.includes(blockKey) || 
                        (!this.outfillBlocks.has(blockKey) && this.isBlockAdjacentToContent(blockKey))) {
                        neededBlocks++;
                        if (this.generationQueue.includes(blockKey)) {
                            queuedBlocks.push(blockKey);
                        }
                    }
                });
                
                // Strategic call is worthwhile if we need at least 2 of the 3 blocks
                const isWorthwhile = neededBlocks >= 2;
                
                if (isWorthwhile) {
                    console.log(`🎯 Strategic call worthwhile: ${neededBlocks}/3 blocks needed`, {
                        target: strategicCall.targetBlock,
                        generated: strategicCall.generatedBlocks,
                        queued: queuedBlocks
                    });
                }
                
                return isWorthwhile;
            }
            
            async executeStrategicMultiBlockCall(strategicCall) {
                this.activeGenerations++;
                
                // Mark all generated blocks as generating
                strategicCall.generatedBlocks.forEach(blockKey => {
                    // Remove from queue if present
                    const queueIndex = this.generationQueue.indexOf(blockKey);
                    if (queueIndex !== -1) {
                        this.generationQueue.splice(queueIndex, 1);
                    }
                    
                    // Create or update block status
                    if (!this.outfillBlocks.has(blockKey)) {
                        this.outfillBlocks.set(blockKey, { status: 'generating', progress: 0, imageData: null });
                        this.updateOutfillBlock(blockKey, this.outfillBlocks.get(blockKey));
                    } else {
                        const block = this.outfillBlocks.get(blockKey);
                        block.status = 'generating';
                        this.updateOutfillBlock(blockKey, block);
                    }
                });
                
                console.log(`🧩 Executing strategic multi-block call for ${strategicCall.generatedBlocks.length} blocks:`, strategicCall.generatedBlocks);
                
                try {
                    // Use the strategic origin and directions for the API call
                    if (this.apiKey) {
                        const result = await this.generateStrategicOutfill(strategicCall);
                        console.log('✅ Strategic multi-block generation completed:', result);
                    } else {
                        // Show not connected for all blocks
                        for (const blockKey of strategicCall.generatedBlocks) {
                            await this.simulateGeneration(blockKey);
                        }
                    }
                } catch (error) {
                    console.error('❌ Strategic multi-block generation failed:', error);
                    // Mark all blocks as failed
                    strategicCall.generatedBlocks.forEach(blockKey => {
                        const block = this.outfillBlocks.get(blockKey);
                        if (block) {
                            block.status = 'failed';
                            this.updateOutfillBlock(blockKey, block);
                        }
                    });
                } finally {
                    this.activeGenerations--;
                    this.processGenerationQueue();
                }
            }
            
            async generateStrategicOutfill(strategicCall) {
                console.log('🚀 Starting strategic generateOutfill:', strategicCall);
                
                if (!this.apiKey) {
                    throw new Error('No API key set');
                }
                
                try {
                    // Get the current image as a blob
                    const imageBlob = await this.getImageAsBlob();
                    console.log('📸 Strategic image blob size:', imageBlob.size, 'bytes');
                    
                    // Generate mask for strategic call (2x2 canvas with target areas)
                    const maskBlob = await this.generateStrategicMask(strategicCall);
                    console.log('🎭 Strategic mask size:', maskBlob.size, 'bytes');
                    
                    // Make API call with strategic directions
                    const response = await this.callStabilityAPIStrategic(imageBlob, maskBlob, strategicCall);
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    // Get the response blob
                    const responseBlob = await response.blob();
                    
                    // Process multi-block response using existing system
                    return await this.processStrategicMultiBlockResponse(responseBlob, strategicCall);
                    
                } catch (error) {
                    console.error('Strategic outfill error:', error);
                    throw error;
                }
            }
            
            async generateStrategicMask(strategicCall) {
                // Create a 2x2 canvas mask for strategic multi-block generation
                const canvas = document.createElement('canvas');
                canvas.width = this.imageWidth * 2;
                canvas.height = this.imageHeight * 2;
                const ctx = canvas.getContext('2d');
                
                // Fill with black (preserve existing content)
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Mark the original image area as black (preserve)
                ctx.fillStyle = 'black';
                ctx.fillRect(
                    this.imageWidth / 2,
                    this.imageHeight / 2,
                    this.imageWidth,
                    this.imageHeight
                );
                
                // Mark all target extension areas as white (outpaint)
                ctx.fillStyle = 'white';
                
                strategicCall.generatedBlocks.forEach(blockKey => {
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    const targetX = this.imageWidth / 2 + (gridX * this.imageWidth);
                    const targetY = this.imageHeight / 2 + (gridY * this.imageHeight);
                    
                    ctx.fillRect(targetX, targetY, this.imageWidth, this.imageHeight);
                    console.log(`🎭 Strategic mask: marked block ${blockKey} at (${targetX}, ${targetY})`);
                });
                
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
            }
            
            async callStabilityAPIStrategic(imageBlob, maskBlob, strategicCall) {
                const formData = new FormData();
                formData.append('image', imageBlob, 'image.jpg');
                formData.append('mask', maskBlob, 'mask.png');
                formData.append('prompt', this.config.prompt);
                formData.append('output_format', this.config.output_format);
                formData.append('creativity', this.config.creativity.toString());
                
                // Add strategic direction parameters
                const blockSizeX = this.imageWidth;
                const blockSizeY = this.imageHeight;
                
                console.log(`🎯 Strategic API call directions: directionX=${strategicCall.directionX}, directionY=${strategicCall.directionY}`);
                
                // Add direction-based outpaint parameters
                if (strategicCall.directionX > 0) {
                    formData.append('right', blockSizeX.toString());
                } else if (strategicCall.directionX < 0) {
                    formData.append('left', blockSizeX.toString());
                }
                
                if (strategicCall.directionY > 0) {
                    formData.append('down', blockSizeY.toString());
                } else if (strategicCall.directionY < 0) {
                    formData.append('up', blockSizeY.toString());
                }
                
                console.log('📤 Strategic API request to:', this.config.endpoint);
                
                return fetch(this.config.endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Accept': 'image/*'
                    },
                    body: formData
                });
            }
            
            async processStrategicMultiBlockResponse(responseBlob, strategicCall) {
                try {
                    console.log(`🔄 Processing strategic multi-block response for ${strategicCall.generatedBlocks.length} blocks`);
                    
                    // Show downloaded image in debug preview
                    this.showDebugPreview(responseBlob, strategicCall.generatedBlocks.join(','), 'Strategic API Response');
                    
                    // Create image from response blob
                    const responseImage = new Image();
                    const imageUrl = URL.createObjectURL(responseBlob);
                    
                    return new Promise((resolve, reject) => {
                        responseImage.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                canvas.width = responseImage.width;
                                canvas.height = responseImage.height;
                                ctx.drawImage(responseImage, 0, 0);
                                
                                // SEAMLESS LAYER APPROACH: Position entire image as one layer
                                this.positionEntireImageAsLayer(imageUrl, strategicCall);
                                
                                // Clean up
                                URL.revokeObjectURL(imageUrl);
                                
                                resolve({
                                    blocksGenerated: strategicCall.generatedBlocks,
                                    size: responseBlob.size
                                });
                                
                            } catch (error) {
                                console.error('Error processing strategic multi-block response:', error);
                                reject(error);
                            }
                        };
                        
                        responseImage.onerror = () => {
                            reject(new Error('Failed to load strategic response image'));
                        };
                        
                        responseImage.src = imageUrl;
                    });
                    
                } catch (error) {
                    console.error('Error in processStrategicMultiBlockResponse:', error);
                    throw error;
                }
            }
            
            positionEntireImageAsLayer(imageUrl, strategicCall) {
                // Calculate the 3-block area bounds
                const { directionX, directionY } = strategicCall;
                const blocks = strategicCall.generatedBlocks;
                
                // Find min/max coordinates of the 3 blocks
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                blocks.forEach(blockKey => {
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    minX = Math.min(minX, gridX);
                    maxX = Math.max(maxX, gridX);
                    minY = Math.min(minY, gridY);
                    maxY = Math.max(maxY, gridY);
                });
                
                // Calculate 3-block area position and size
                const areaLeft = minX * this.imageWidth;
                const areaTop = minY * this.imageHeight;
                const areaWidth = (maxX - minX + 1) * this.imageWidth;
                const areaHeight = (maxY - minY + 1) * this.imageHeight;
                
                // Create layer element for entire downloaded image
                const layerElement = document.createElement('div');
                layerElement.id = `layer-${Date.now()}`;
                layerElement.style.position = 'absolute';
                layerElement.style.zIndex = '3';
                layerElement.style.backgroundImage = `url(${imageUrl})`;
                layerElement.style.backgroundRepeat = 'no-repeat';
                layerElement.style.pointerEvents = 'none';
                
                // Position entire image in 3-block area (UV 0,0 to 1,1)
                layerElement.style.left = `${areaLeft}px`;
                layerElement.style.top = `${areaTop}px`;
                layerElement.style.width = `${areaWidth}px`;
                layerElement.style.height = `${areaHeight}px`;
                layerElement.style.backgroundSize = `${areaWidth}px ${areaHeight}px`;
                layerElement.style.backgroundPosition = '0px 0px';
                
                this.content.appendChild(layerElement);
                
                console.log(`🎨 Full image in 3-block area: position(${areaLeft},${areaTop}), size(${areaWidth}x${areaHeight})`);
                
                // Mark blocks as completed
                strategicCall.generatedBlocks.forEach(blockKey => {
                    this.outfillBlocks.set(blockKey, {
                        status: 'completed',
                        progress: 1,
                        layerId: layerElement.id
                    });
                });
            }

            // Legacy function - replaced by positionEntireImageAsLayer()
            // Kept for reference but no longer used

            processGenerationQueue() {
                // Resort queue before processing
                this.updateGenerationQueue();
                
                if (this.generationQueue.length > 0 && this.activeGenerations < 1) {
                    // 🌀 SPIRAL SYSTEM: Sequential generation only (no 3-block trick)
                    const blockKey = this.generationQueue.shift();
                    this.activeGenerations++;
                    
                    console.log(`🌀 Starting sequential generation for block: ${blockKey}`);
                    
                    // Change status from 'queued' to 'generating'
                    const block = this.outfillBlocks.get(blockKey);
                    if (block) {
                        block.status = 'generating';
                        this.updateOutfillBlock(blockKey, block);
                    }
                    
                    // Use real API generation if key available
                    if (this.apiKey) {
                        this.generateWithAPI(blockKey).then((result) => {
                            console.log('✅ Spiral generation completed successfully for block:', blockKey, result);
                            this.activeGenerations--;
                            
                            // 🌀 BREAKTHROUGH: After each completion, check for next spiral block
                            this.checkVisibleBlocks();
                        }).catch((error) => {
                            console.error('❌ Spiral generation failed for block:', blockKey, error);
                            // Mark block as failed and continue
                            const block = this.outfillBlocks.get(blockKey);
                            if (block) {
                                block.status = 'failed';
                                this.updateOutfillBlock(blockKey, block);
                            }
                            this.activeGenerations--;
                            
                            // Continue with next spiral block even after failure
                            this.checkVisibleBlocks();
                        });
                    } else {
                        this.simulateGeneration(blockKey).then(() => {
                            this.activeGenerations--;
                            
                            // Continue with next spiral block after simulation
                            this.checkVisibleBlocks();
                        });
                    }
                }
                
                // Update queue indicator
                this.updateQueueIndicator();
            }

            updateQueueIndicator() {
                const queueCount = this.generationQueue.length;
                const activeCount = this.activeGenerations;
                this.queueIndicator.textContent = `Queue: ${queueCount} | Active: ${activeCount} | Ring: ${this.currentRing}`;
            }

            // 🌀 SPIRAL SYSTEM: Breakthrough composite layering functions
            
            initializeSpiralSystem() {
                if (this.spiralInitialized) return;
                
                console.log('🌀 Initializing spiral ring system...');
                
                // Generate spiral rings around original image (0,0)
                this.spiralRings = [];
                
                // Ring 1: 8 blocks immediately around original
                const ring1 = [
                    // Lower right quadrant (start here as specified)
                    [1, 1], [0, 1], [1, 0],
                    // Lower left quadrant  
                    [-1, 1], [-1, 0],
                    // Upper left quadrant
                    [-1, -1], [0, -1],
                    // Upper right quadrant
                    [1, -1]
                ];
                
                // Ring 2: 16 blocks in next ring out
                const ring2 = [
                    // Lower right quadrant
                    [2, 2], [2, 1], [1, 2], [2, 0], [0, 2],
                    // Lower left quadrant
                    [-2, 2], [-2, 1], [-1, 2], [-2, 0],
                    // Upper left quadrant  
                    [-2, -2], [-2, -1], [-1, -2], [0, -2],
                    // Upper right quadrant
                    [2, -2], [2, -1], [1, -2]
                ];
                
                // Ring 3: 24 blocks in next ring out
                const ring3 = [
                    // Lower right quadrant
                    [3, 3], [3, 2], [2, 3], [3, 1], [1, 3], [3, 0], [0, 3],
                    // Lower left quadrant
                    [-3, 3], [-3, 2], [-2, 3], [-3, 1], [-1, 3], [-3, 0],
                    // Upper left quadrant
                    [-3, -3], [-3, -2], [-2, -3], [-3, -1], [-1, -3], [0, -3],
                    // Upper right quadrant
                    [3, -3], [3, -2], [2, -3], [3, -1], [1, -3]
                ];
                
                this.spiralRings = [ring1, ring2, ring3];
                this.currentRing = 0;
                this.currentRingPosition = 0;
                this.spiralInitialized = true;
                
                console.log('🌀 Spiral rings initialized:', this.spiralRings.length, 'rings');
                console.log('🌀 Ring 1:', ring1.length, 'blocks');
                console.log('🌀 Ring 2:', ring2.length, 'blocks'); 
                console.log('🌀 Ring 3:', ring3.length, 'blocks');
            }
            
            getNextSpiralBlock() {
                this.initializeSpiralSystem();
                
                // Check if we have more rings to process
                if (this.currentRing >= this.spiralRings.length) {
                    console.log('🌀 All spiral rings completed');
                    return null;
                }
                
                const currentRingBlocks = this.spiralRings[this.currentRing];
                
                // Check if current ring is completed
                if (this.currentRingPosition >= currentRingBlocks.length) {
                    console.log(`🌀 Ring ${this.currentRing} completed, moving to ring ${this.currentRing + 1}`);
                    this.currentRing++;
                    this.currentRingPosition = 0;
                    
                    // Recursively get next block from new ring
                    return this.getNextSpiralBlock();
                }
                
                // Get next block from current ring
                const [gridX, gridY] = currentRingBlocks[this.currentRingPosition];
                const blockKey = `${gridX},${gridY}`;
                this.currentRingPosition++;
                
                console.log(`🌀 Next spiral block: ${blockKey} (Ring ${this.currentRing}, Position ${this.currentRingPosition - 1})`);
                return blockKey;
            }
            
            isBlockInCurrentVisibleArea(blockKey) {
                const visibleBlocks = this.getVisibleBlocks();
                return visibleBlocks.has(blockKey);
            }
            
            queueVisibleSpiralBlocks() {
                console.log('🌀 Queuing visible spiral blocks...');
                
                let queuedCount = 0;
                
                // Get next block from spiral without advancing position yet
                const nextBlockKey = this.peekNextSpiralBlock();
                
                if (nextBlockKey && !this.outfillBlocks.has(nextBlockKey)) {
                    // Only queue if visible
                    if (this.isBlockInCurrentVisibleArea(nextBlockKey)) {
                        // Now actually advance the spiral position
                        this.getNextSpiralBlock();
                        
                        this.outfillBlocks.set(nextBlockKey, { status: 'queued', progress: 0, imageData: null });
                        this.updateOutfillBlock(nextBlockKey, this.outfillBlocks.get(nextBlockKey));
                        this.generationQueue.push(nextBlockKey);
                        queuedCount++;
                        console.log(`🌀 Queued visible spiral block: ${nextBlockKey}`);
                    }
                }
                
                console.log(`🌀 Queued ${queuedCount} visible spiral blocks`);
                return queuedCount;
            }
            
            peekNextSpiralBlock() {
                this.initializeSpiralSystem();
                
                // Check if we have more rings to process
                if (this.currentRing >= this.spiralRings.length) {
                    return null;
                }
                
                const currentRingBlocks = this.spiralRings[this.currentRing];
                
                // Check if current ring is completed
                if (this.currentRingPosition >= currentRingBlocks.length) {
                    // Would move to next ring, peek at first block of next ring
                    if (this.currentRing + 1 >= this.spiralRings.length) {
                        return null;
                    }
                    const nextRingBlocks = this.spiralRings[this.currentRing + 1];
                    if (nextRingBlocks.length === 0) {
                        return null;
                    }
                    const [gridX, gridY] = nextRingBlocks[0];
                    return `${gridX},${gridY}`;
                }
                
                // Peek at next block from current ring
                const [gridX, gridY] = currentRingBlocks[this.currentRingPosition];
                return `${gridX},${gridY}`;
            }
            
            queueOneRingBeyondVisible() {
                // This will queue blocks that are adjacent to visible area but not yet visible
                // Implementation can be added later for smooth experience
                console.log('🌀 Queuing one ring beyond visible area (placeholder)');
            }





            async generateMaskForBlock(blockKey) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                
                // Create a canvas for the mask (2x2 for outpaint extensions)
                const canvas = document.createElement('canvas');
                canvas.width = this.imageWidth * 2;
                canvas.height = this.imageHeight * 2;
                const ctx = canvas.getContext('2d');
                
                // Fill with black (keep existing content)
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // BLOCKSIZE=1 SYSTEM: Original image is at center (0,0)
                // Mark the original image area as black (preserve)
                ctx.fillStyle = 'black';
                ctx.fillRect(
                    this.imageWidth / 2,
                    this.imageHeight / 2,
                    this.imageWidth,
                    this.imageHeight
                );
                
                // Mark the target extension area as white (outpaint)
                ctx.fillStyle = 'white';
                const targetX = this.imageWidth / 2 + (gridX * this.imageWidth);
                const targetY = this.imageHeight / 2 + (gridY * this.imageHeight);
                
                ctx.fillRect(
                    targetX,
                    targetY,
                    this.imageWidth,
                    this.imageHeight
                );
                
                console.log(`🎭 Generated mask for block ${blockKey}: target area at (${targetX}, ${targetY})`);
                
                // Convert canvas to blob
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
            }

            getOutpaintDirections(blockKey) {
                const [targetGridX, targetGridY] = blockKey.split(',').map(Number);
                
                // CORE CONCEPT: Find the best filled adjacent block to use as source
                // Then calculate direction from source to target
                
                // Find adjacent filled blocks (up, down, left, right)
                const adjacentBlocks = [
                    { key: `${targetGridX-1},${targetGridY}`, dirX: 1, dirY: 0 }, // left neighbor -> go right
                    { key: `${targetGridX+1},${targetGridY}`, dirX: -1, dirY: 0 }, // right neighbor -> go left  
                    { key: `${targetGridX},${targetGridY-1}`, dirX: 0, dirY: 1 }, // up neighbor -> go down
                    { key: `${targetGridX},${targetGridY+1}`, dirX: 0, dirY: -1 }  // down neighbor -> go up
                ];
                
                // Find the first available filled block to use as source
                let sourceBlock = null;
                let directionX = 0;
                let directionY = 0;
                
                for (const adj of adjacentBlocks) {
                    if (this.outfillBlocks.has(adj.key) && this.outfillBlocks.get(adj.key).status === 'completed') {
                        sourceBlock = adj.key;
                        directionX = adj.dirX;
                        directionY = adj.dirY;
                        break;
                    }
                }
                
                // If no adjacent filled blocks, use original (0,0) as source
                if (!sourceBlock) {
                    sourceBlock = '0,0';
                    directionX = targetGridX > 0 ? 1 : (targetGridX < 0 ? -1 : 0);
                    directionY = targetGridY > 0 ? 1 : (targetGridY < 0 ? -1 : 0);
                }
                
                console.log(`🎯 Block ${blockKey}: source=${sourceBlock}, direction=(${directionX},${directionY})`);
                
                return { 
                    directionX, 
                    directionY, 
                    gridX: targetGridX, 
                    gridY: targetGridY,
                    sourceBlock: sourceBlock
                };
            }

            positionOutpaintBackground(blockElement, blockKey, directions) {
                const [gridX, gridY] = blockKey.split(',').map(Number);
                const gridSizeX = this.containerWidth / this.blockDivisions;
                const gridSizeY = this.containerHeight / this.blockDivisions;
                
                console.log(`🎨 Positioning outpaint background for block ${blockKey}, directions:`, directions);
                console.log(`🎨 Block divisions: ${this.blockDivisions}, Grid size: ${gridSizeX} × ${gridSizeY}`);
                console.log(`🎨 Container size: ${this.containerWidth} × ${this.containerHeight}`);
                
                // The Stability AI outpaint API returns an image that contains:
                // 1. The original image in its original position
                // 2. The extended content in the requested directions
                // We need to position this composite image so that:
                // - The original image portion aligns with the actual original image
                // - Only the extended portion shows in this block
                
                if (directions.includes('right') && !directions.includes('left') && !directions.includes('up') && !directions.includes('bottom')) {
                    // Pure right outpaint
                    // Generated image = [original image][new content]
                    // We want to show only the new content in this block
                    // So we position the background so the new content aligns with this block
                    blockElement.style.backgroundSize = `${this.containerWidth + gridSizeX}px ${this.containerHeight}px`;
                    blockElement.style.backgroundPosition = `${-this.containerWidth}px 0px`;
                    console.log(`🎨 Right outpaint: backgroundSize=${this.containerWidth + gridSizeX}x${this.containerHeight}, position=${-this.containerWidth},0`);
                    
                } else if (directions.includes('left') && !directions.includes('right') && !directions.includes('up') && !directions.includes('bottom')) {
                    // Pure left outpaint
                    // Generated image = [new content][original image]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth + gridSizeX}px ${this.containerHeight}px`;
                    blockElement.style.backgroundPosition = `0px 0px`;
                    console.log(`🎨 Left outpaint: backgroundSize=${this.containerWidth + gridSizeX}x${this.containerHeight}, position=0,0`);
                    
                } else if (directions.includes('bottom') && !directions.includes('top') && !directions.includes('left') && !directions.includes('right')) {
                    // Pure bottom outpaint
                    // Generated image = [original image]
                    //                   [new content]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth}px ${this.containerHeight + gridSizeY}px`;
                    blockElement.style.backgroundPosition = `0px ${-this.containerHeight}px`;
                    console.log(`🎨 Bottom outpaint: backgroundSize=${this.containerWidth}x${this.containerHeight + gridSizeY}, position=0,${-this.containerHeight}`);
                    
                } else if (directions.includes('up') && !directions.includes('bottom') && !directions.includes('left') && !directions.includes('right')) {
                    // Pure top outpaint
                    // Generated image = [new content]
                    //                   [original image]
                    // We want to show only the new content in this block
                    blockElement.style.backgroundSize = `${this.containerWidth}px ${this.containerHeight + gridSizeY}px`;
                    blockElement.style.backgroundPosition = `0px 0px`;
                    console.log(`🎨 Top outpaint: backgroundSize=${this.containerWidth}x${this.containerHeight + gridSizeY}, position=0,0`);
                    
                } else if (directions.length > 1) {
                    // Multi-direction outpaint (corner blocks)
                    // Calculate the total size of the generated image
                    const totalWidth = this.containerWidth + (directions.includes('left') ? gridSizeX : 0) + (directions.includes('right') ? gridSizeX : 0);
                    const totalHeight = this.containerHeight + (directions.includes('up') ? gridSizeY : 0) + (directions.includes('bottom') ? gridSizeY : 0);
                    
                    // Calculate the position offset to align the original image portion
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    // If there's left extension, the original image is shifted right in the generated image
                    if (directions.includes('left')) {
                        offsetX = -gridSizeX;
                    }
                    // If there's top extension, the original image is shifted down in the generated image
                    if (directions.includes('up')) {
                        offsetY = -gridSizeY;
                    }
                    
                    // Adjust offset based on which block we're positioning
                    if (directions.includes('right') && gridX >= this.blockDivisions) {
                        offsetX -= this.containerWidth;
                    }
                    if (directions.includes('bottom') && gridY >= this.blockDivisions) {
                        offsetY -= this.containerHeight;
                    }
                    
                    blockElement.style.backgroundSize = `${totalWidth}px ${totalHeight}px`;
                    blockElement.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
                    console.log(`🎨 Multi-direction outpaint: backgroundSize=${totalWidth}x${totalHeight}, position=${offsetX},${offsetY}`);
                    
                } else {
                    // Fallback: simple fill
                    blockElement.style.backgroundSize = `${gridSizeX}px ${gridSizeY}px`;
                    blockElement.style.backgroundPosition = '0px 0px';
                    console.log(`🎨 Fallback: Simple fill - backgroundSize=${gridSizeX}x${gridSizeY}, position=0,0`);
                }
            }

            async getSourceBlockAsBlob(sourceBlockKey) {
                if (sourceBlockKey === '0,0') {
                    // Use original image
                    return await this.getImageAsBlob();
                } else {
                    // Get the filled block's image
                    const sourceBlock = this.outfillBlocks.get(sourceBlockKey);
                    if (sourceBlock && sourceBlock.element && sourceBlock.element.style.backgroundImage) {
                        // Extract the background image URL and convert to blob
                        const bgImage = sourceBlock.element.style.backgroundImage;
                        const urlMatch = bgImage.match(/url\("?([^"]*)"?\)/);
                        if (urlMatch && urlMatch[1]) {
                            const response = await fetch(urlMatch[1]);
                            return await response.blob();
                        }
                    }
                    
                    // Fallback to original image if source block not available
                    console.warn(`⚠️ Source block ${sourceBlockKey} not available, using original image`);
                    return await this.getImageAsBlob();
                }
            }

            async callStabilityAPI(blockKey) {
                if (!this.apiCallsEnabled) {
                    console.log('🚫 API calls disabled - keeping grey loading block');
                    return;
                }
                
                if (!this.apiKey) {
                    throw new Error('No API key available');
                }

                try {
                    const { directionX, directionY, gridX, gridY, sourceBlock } = this.getOutpaintDirections(blockKey);
                    
                    // BLOCKSIZE=1: Each block is exactly the original image size
                    const blockSizeX = this.imageWidth;   // 1600px
                    const blockSizeY = this.imageHeight;  // 1024px
                    
                    console.log(`🎨 API Call for block ${blockKey}: source=${sourceBlock}, direction=(${directionX},${directionY}), blockSize=${blockSizeX}x${blockSizeY}`);
                    
                    // Get the source block image as blob
                    const imageBlob = await this.getSourceBlockAsBlob(sourceBlock);
                    
                    // Prepare form data
                    const formData = new FormData();
                    formData.append('image', imageBlob, 'image.jpg');
                    formData.append('prompt', this.apiConfig.prompt);
                    formData.append('creativity', this.apiConfig.creativity.toString());
                    formData.append('output_format', this.apiConfig.output_format);
                    
                    // Add direction-based outpaint parameters
                    if (directionX > 0) {
                        formData.append('right', blockSizeX.toString());
                    } else if (directionX < 0) {
                        formData.append('left', blockSizeX.toString());
                    }
                    
                    if (directionY > 0) {
                        formData.append('down', blockSizeY.toString());
                    } else if (directionY < 0) {
                        formData.append('up', blockSizeY.toString());
                    }
                    
                    // Add optional parameters
                    if (this.apiConfig.seed !== null) {
                        formData.append('seed', this.apiConfig.seed.toString());
                    }
                    if (this.apiConfig.style_preset !== null) {
                        formData.append('style_preset', this.apiConfig.style_preset);
                    }
                    
                    console.log(`📤 API Request: ${directionX > 0 ? 'right=' + blockSizeX : ''}${directionX < 0 ? 'left=' + blockSizeX : ''}${directionY > 0 ? ' down=' + blockSizeY : ''}${directionY < 0 ? ' up=' + blockSizeY : ''}`);
                    
                    // Make API call
                    const response = await fetch(this.apiConfig.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Accept': 'image/*'
                        },
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API call failed: ${response.status} - ${errorText}`);
                    }
                    
                    // Get the response blob
                    const responseBlob = await response.blob();
                    
                    // Process multi-block response
                    return await this.processMultiBlockResponse(responseBlob, blockKey, directionX, directionY);
                    
                } catch (error) {
                    console.error('Stability API error:', error);
                    throw error;
                }
            }

            async processMultiBlockResponse(responseBlob, targetBlockKey, directionX, directionY) {
                try {
                    const { sourceBlock } = this.getOutpaintDirections(targetBlockKey);
                    console.log(`🔄 Processing 2x2 response: target=${targetBlockKey}, source=${sourceBlock}, direction=(${directionX},${directionY})`);
                    
                    // Show 2x2 composite in debug preview (positioned over original)
                    this.show2x2CompositePreview(responseBlob, sourceBlock, directionX, directionY, targetBlockKey);
                    
                    // Create image from response blob
                    const responseImage = new Image();
                    const imageUrl = URL.createObjectURL(responseBlob);
                    
                    return new Promise((resolve, reject) => {
                        responseImage.onload = () => {
                            try {
                                // CORE CONCEPT: API returns 2x2 image where top-left quarter = source block
                                // We need to position this 2x2 so top-left aligns with source, filling 3 blocks
                                
                                const blockWidth = this.imageWidth;   // 1600px
                                const blockHeight = this.imageHeight; // 1024px
                                
                                console.log(`📐 Response image: ${responseImage.width}x${responseImage.height}`);
                                console.log(`📐 Expected 2x2: ${blockWidth*2}x${blockHeight*2}`);
                                
                                // Calculate which 3 blocks will be filled by this 2x2 response
                                const [sourceGridX, sourceGridY] = sourceBlock.split(',').map(Number);
                                const filledBlocks = [
                                    sourceBlock, // Source block (top-left quarter)
                                    `${sourceGridX + directionX},${sourceGridY}`, // Horizontal extension
                                    `${sourceGridX},${sourceGridY + directionY}`, // Vertical extension
                                    `${sourceGridX + directionX},${sourceGridY + directionY}` // Diagonal (if both directions)
                                ];
                                
                                // Remove duplicates and source block (already filled)
                                const newBlocks = filledBlocks.filter((block, index) => 
                                    index > 0 && !this.outfillBlocks.has(block)
                                );
                                
                                console.log(`🧩 2x2 response will be displayed as single overlay`);
                                
                                // Display full 2x2 response as single overlay positioned over original
                                this.create2x2Overlay(responseImage, sourceBlock, directionX, directionY, targetBlockKey);
                                
                                // Clean up
                                URL.revokeObjectURL(imageUrl);
                                resolve(imageUrl);
                                
                            } catch (error) {
                                console.error('Error processing 2x2 response:', error);
                                reject(error);
                            }
                        };
                        
                        responseImage.onerror = () => {
                            reject(new Error('Failed to load response image'));
                        };
                        
                        responseImage.src = imageUrl;
                    });
                    
                } catch (error) {
                    console.error('Error in processMultiBlockResponse:', error);
                    throw error;
                }
            }

            // Create single 2x2 overlay positioned over original image
            create2x2Overlay(responseImage, sourceBlock, directionX, directionY, targetBlockKey) {
                try {
                    console.log(`🖼️ Creating 2x2 overlay: source=${sourceBlock}, direction=(${directionX},${directionY})`);
                    
                    const [sourceGridX, sourceGridY] = sourceBlock.split(',').map(Number);
                    const blockWidth = this.imageWidth;   // 1600px
                    const blockHeight = this.imageHeight; // 1024px
                    
                    // Create overlay element
                    const overlayDiv = document.createElement('div');
                    overlayDiv.className = 'outfill-block overlay-2x2';
                    overlayDiv.style.position = 'absolute';
                    overlayDiv.style.pointerEvents = 'none';
                    overlayDiv.style.zIndex = '10'; // Above regular blocks
                    
                    // Size = 2x2 blocks
                    overlayDiv.style.width = (blockWidth * 2) + 'px';
                    overlayDiv.style.height = (blockHeight * 2) + 'px';
                    
                    // Position so top-left aligns with source block
                    const sourceLeft = sourceGridX * blockWidth;
                    const sourceTop = sourceGridY * blockHeight;
                    overlayDiv.style.left = sourceLeft + 'px';
                    overlayDiv.style.top = sourceTop + 'px';
                    
                    // Create image element
                    const img = document.createElement('img');
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.display = 'block';
                    
                    // Convert response image to blob URL
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = responseImage.width;
                    canvas.height = responseImage.height;
                    ctx.drawImage(responseImage, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            const imageUrl = URL.createObjectURL(blob);
                            img.src = imageUrl;
                            
                            // Clean up URL after image loads
                            img.onload = () => {
                                setTimeout(() => URL.revokeObjectURL(imageUrl), 1000);
                            };
                        }
                    }, 'image/jpeg', 0.9);
                    
                    overlayDiv.appendChild(img);
                    
                    // Add to viewer content container
                    const viewerContent = document.querySelector('.viewer-content');
                    if (viewerContent) {
                        viewerContent.appendChild(overlayDiv);
                        console.log(`✅ 2x2 overlay created: ${blockWidth*2}x${blockHeight*2} at (${sourceLeft},${sourceTop})`);
                    } else {
                        console.error('❌ Viewer content container not found for 2x2 overlay');
                    }
                    
                    // Store overlay reference for cleanup
                    const overlayKey = `overlay-${targetBlockKey}`;
                    if (!this.overlays) this.overlays = new Map();
                    this.overlays.set(overlayKey, overlayDiv);
                    
                } catch (error) {
                    console.error('❌ Error creating 2x2 overlay:', error);
                }
            }

            extract2x2Blocks(responseImage, sourceBlock, directionX, directionY, newBlocks) {
                const blockWidth = this.imageWidth;   // 1600px
                const blockHeight = this.imageHeight; // 1024px
                
                console.log(`🧩 Extracting blocks from 2x2 response: ${responseImage.width}x${responseImage.height}`);
                
                // Create canvas for extraction
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = blockWidth;
                canvas.height = blockHeight;
                
                // Extract each new block from the 2x2 response
                for (const blockKey of newBlocks) {
                    const [gridX, gridY] = blockKey.split(',').map(Number);
                    const [sourceGridX, sourceGridY] = sourceBlock.split(',').map(Number);
                    
                    // Calculate position in 2x2 response
                    let sourceX = 0;
                    let sourceY = 0;
                    
                    if (gridX > sourceGridX) sourceX = blockWidth;  // Right half
                    if (gridY > sourceGridY) sourceY = blockHeight; // Bottom half
                    
                    console.log(`🧩 Extracting block ${blockKey} from position (${sourceX},${sourceY})`);
                    
                    // Clear canvas and extract block
                    ctx.clearRect(0, 0, blockWidth, blockHeight);
                    ctx.drawImage(responseImage, sourceX, sourceY, blockWidth, blockHeight, 0, 0, blockWidth, blockHeight);
                    
                    // Convert to blob and create block
                    canvas.toBlob((blob) => {
                        if (blob) {
                            const imageUrl = URL.createObjectURL(blob);
                            this.createFilledBlock(blockKey, imageUrl);
                        }
                    }, 'image/jpeg', 0.9);
                }
            }
            
            createFilledBlock(blockKey, imageUrl) {
                console.log(`✅ Creating filled block ${blockKey}`);
                
                // Create block element
                const blockElement = document.createElement('div');
                blockElement.className = 'outfill-block';
                blockElement.style.backgroundImage = `url(${imageUrl})`;
                blockElement.style.backgroundSize = 'cover';
                blockElement.style.backgroundPosition = 'center';
                
                // Position block in grid
                const [gridX, gridY] = blockKey.split(',').map(Number);
                const blockSizeX = this.containerWidth;
                const blockSizeY = this.containerHeight;
                
                blockElement.style.position = 'absolute';
                blockElement.style.left = (gridX * blockSizeX) + 'px';
                blockElement.style.top = (gridY * blockSizeY) + 'px';
                blockElement.style.width = blockSizeX + 'px';
                blockElement.style.height = blockSizeY + 'px';
                blockElement.style.zIndex = this.blocksOverImage ? '5' : '1';
                
                // Add to container
                this.content.appendChild(blockElement);
                
                // Store in blocks map
                this.outfillBlocks.set(blockKey, {
                    status: 'completed',
                    progress: 1,
                    element: blockElement,
                    imageUrl: imageUrl
                });
                
                console.log(`✅ Block ${blockKey} created and positioned`);
            }

            // Legacy method - keeping for compatibility but not used in new system
            extractAndPlaceBlocks(sourceCanvas, originalBlockKey, directionX, directionY) {
                console.log(`⚠️ Legacy extractAndPlaceBlocks called - should use extract2x2Blocks instead`);
                const [originalGridX, originalGridY] = originalBlockKey.split(',').map(Number);
                
                // BLOCKSIZE=1: Each block is exactly the original image size
                const blockSizeX = this.imageWidth;   // 1600px
                const blockSizeY = this.imageHeight;  // 1024px
                
                console.log(`🧩 Extracting blocks from ${sourceCanvas.width}x${sourceCanvas.height} canvas`);
                
                // Calculate which blocks to extract based on direction
                const blocksToExtract = [];
                
                if (directionX !== 0 && directionY !== 0) {
                    // Diagonal direction - extracts 3 blocks
                    const rightBlockX = originalGridX + (directionX > 0 ? 1 : -1);
                    const downBlockY = originalGridY + (directionY > 0 ? 1 : -1);
                    
                    blocksToExtract.push({
                        blockKey: `${rightBlockX},${originalGridY}`,
                        sourceX: directionX > 0 ? blockSizeX : 0,
                        sourceY: 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                    blocksToExtract.push({
                        blockKey: `${originalGridX},${downBlockY}`,
                        sourceX: 0,
                        sourceY: directionY > 0 ? blockSizeY : 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                    blocksToExtract.push({
                        blockKey: `${rightBlockX},${downBlockY}`,
                        sourceX: directionX > 0 ? blockSizeX : 0,
                        sourceY: directionY > 0 ? blockSizeY : 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                } else if (directionX !== 0) {
                    // Horizontal direction - extracts 1 block
                    const newBlockX = originalGridX + (directionX > 0 ? 1 : -1);
                    blocksToExtract.push({
                        blockKey: `${newBlockX},${originalGridY}`,
                        sourceX: directionX > 0 ? blockSizeX : 0,
                        sourceY: 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                    
                } else if (directionY !== 0) {
                    // Vertical direction - extracts 1 block
                    const newBlockY = originalGridY + (directionY > 0 ? 1 : -1);
                    blocksToExtract.push({
                        blockKey: `${originalGridX},${newBlockY}`,
                        sourceX: 0,
                        sourceY: directionY > 0 ? blockSizeY : 0,
                        width: blockSizeX,
                        height: blockSizeY
                    });
                }
                
                // Extract each block and update the system
                blocksToExtract.forEach(block => {
                    this.extractAndUpdateBlock(sourceCanvas, block);
                });
                
                console.log(`✅ Extracted ${blocksToExtract.length} blocks from API response`);
            }

            extractAndUpdateBlock(sourceCanvas, blockInfo) {
                try {
                    // Create canvas for this block
                    const blockCanvas = document.createElement('canvas');
                    const blockCtx = blockCanvas.getContext('2d');
                    
                    blockCanvas.width = blockInfo.width;
                    blockCanvas.height = blockInfo.height;
                    
                    // Extract the block area from source canvas
                    blockCtx.drawImage(
                        sourceCanvas,
                        blockInfo.sourceX, blockInfo.sourceY, blockInfo.width, blockInfo.height,
                        0, 0, blockInfo.width, blockInfo.height
                    );
                    
                    // Convert to data URL
                    const blockDataUrl = blockCanvas.toDataURL('image/jpeg', 0.9);
                    
                    // Update the block in our system
                    this.outfillBlocks.set(blockInfo.blockKey, {
                        status: 'ready',
                        progress: 1,
                        imageData: blockDataUrl
                    });
                    
                    this.updateOutfillBlock(blockInfo.blockKey, this.outfillBlocks.get(blockInfo.blockKey));
                    
                    console.log(`🎯 Block ${blockInfo.blockKey} extracted and updated`);
                    
                    // Check for newly adjacent blocks
                    this.checkForNewlyAdjacentBlocks(blockInfo.blockKey);
                    
                } catch (error) {
                    console.error(`Error extracting block ${blockInfo.blockKey}:`, error);
                }
            }



            updateTransform() {
                this.content.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
                this.zoomIndicator.textContent = `${this.scale.toFixed(2)}x`;
                this.drawGrid(); // Redraw grid when transform changes
                this.checkVisibleBlocks();
            }
            

        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // In standalone mode, convert image to data URL to avoid canvas tainting
            if (window.location.protocol === 'file:') {
                const img = document.getElementById('mainImage');
                
                // Wait for image to load, then convert to data URL before initializing viewer
                if (img.complete) {
                    convertAndInitialize();
                } else {
                    img.onload = convertAndInitialize;
                }
                
                function convertAndInitialize() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        ctx.drawImage(img, 0, 0);
                        const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                        img.src = dataURL;
                        console.log('🔧 Converted image to data URL for standalone mode');
                        
                        // Initialize viewer after conversion
                        setTimeout(() => {
                            window.viewer = new ImageViewer();
                        }, 100);
                    } catch (error) {
                        console.log('🔧 Could not convert image to data URL:', error.message);
                        // Initialize viewer anyway
                        window.viewer = new ImageViewer();
                    }
                }
            } else {
                // Server mode - initialize normally
                window.viewer = new ImageViewer();
            }
        });
        
        // Replace the placeholder image with your actual image
        // Just change the src attribute of the img element to your image path
        // document.getElementById('mainImage').src = 'path/to/your/psychedelic-flora.jpg';
    </script>
</body>
</html>